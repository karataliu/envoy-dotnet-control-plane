// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.Filters.Network.HttpConnectionManager.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto</summary>
  public static partial class HttpConnectionManagerReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static HttpConnectionManagerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ClllbnZveS9leHRlbnNpb25zL2ZpbHRlcnMvbmV0d29yay9odHRwX2Nvbm5l",
            "Y3Rpb25fbWFuYWdlci92My9odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci5wcm90",
            "bxI7ZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25u",
            "ZWN0aW9uX21hbmFnZXIudjMaKWVudm95L2NvbmZpZy9hY2Nlc3Nsb2cvdjMv",
            "YWNjZXNzbG9nLnByb3RvGiJlbnZveS9jb25maWcvY29yZS92My9hZGRyZXNz",
            "LnByb3RvGh9lbnZveS9jb25maWcvY29yZS92My9iYXNlLnByb3RvGihlbnZv",
            "eS9jb25maWcvY29yZS92My9jb25maWdfc291cmNlLnByb3RvGiRlbnZveS9j",
            "b25maWcvY29yZS92My9leHRlbnNpb24ucHJvdG8aI2Vudm95L2NvbmZpZy9j",
            "b3JlL3YzL3Byb3RvY29sLnByb3RvGjVlbnZveS9jb25maWcvY29yZS92My9z",
            "dWJzdGl0dXRpb25fZm9ybWF0X3N0cmluZy5wcm90bxohZW52b3kvY29uZmln",
            "L3JvdXRlL3YzL3JvdXRlLnByb3RvGihlbnZveS9jb25maWcvcm91dGUvdjMv",
            "c2NvcGVkX3JvdXRlLnByb3RvGidlbnZveS9jb25maWcvdHJhY2UvdjMvaHR0",
            "cF90cmFjZXIucHJvdG8aLGVudm95L3R5cGUvaHR0cC92My9wYXRoX3RyYW5z",
            "Zm9ybWF0aW9uLnByb3RvGiZlbnZveS90eXBlL3RyYWNpbmcvdjMvY3VzdG9t",
            "X3RhZy5wcm90bxobZW52b3kvdHlwZS92My9wZXJjZW50LnByb3RvGhlnb29n",
            "bGUvcHJvdG9idWYvYW55LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRp",
            "b24ucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90bxoedWRw",
            "YS9hbm5vdGF0aW9ucy9taWdyYXRlLnByb3RvGh91ZHBhL2Fubm90YXRpb25z",
            "L3NlY3VyaXR5LnByb3RvGh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5wcm90",
            "bxohdWRwYS9hbm5vdGF0aW9ucy92ZXJzaW9uaW5nLnByb3RvGhd2YWxpZGF0",
            "ZS92YWxpZGF0ZS5wcm90byLEMQoVSHR0cENvbm5lY3Rpb25NYW5hZ2VyEnoK",
            "CmNvZGVjX3R5cGUYASABKA4yXC5lbnZveS5leHRlbnNpb25zLmZpbHRlcnMu",
            "bmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52My5IdHRwQ29ubmVj",
            "dGlvbk1hbmFnZXIuQ29kZWNUeXBlQgj6QgWCAQIQARIcCgtzdGF0X3ByZWZp",
            "eBgCIAEoCUIH+kIEcgIQARJPCgNyZHMYAyABKAsyQC5lbnZveS5leHRlbnNp",
            "b25zLmZpbHRlcnMubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52",
            "My5SZHNIABJBCgxyb3V0ZV9jb25maWcYBCABKAsyKS5lbnZveS5jb25maWcu",
            "cm91dGUudjMuUm91dGVDb25maWd1cmF0aW9uSAASYgoNc2NvcGVkX3JvdXRl",
            "cxgfIAEoCzJJLmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5uZXR3b3JrLmh0",
            "dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLlNjb3BlZFJvdXRlc0gAEl0KDGh0",
            "dHBfZmlsdGVycxgFIAMoCzJHLmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5u",
            "ZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLkh0dHBGaWx0ZXIS",
            "MgoOYWRkX3VzZXJfYWdlbnQYBiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9v",
            "bFZhbHVlEmsKB3RyYWNpbmcYByABKAsyWi5lbnZveS5leHRlbnNpb25zLmZp",
            "bHRlcnMubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52My5IdHRw",
            "Q29ubmVjdGlvbk1hbmFnZXIuVHJhY2luZxJYChxjb21tb25faHR0cF9wcm90",
            "b2NvbF9vcHRpb25zGCMgASgLMikuZW52b3kuY29uZmlnLmNvcmUudjMuSHR0",
            "cFByb3RvY29sT3B0aW9uc0IHipO3KgIIARJJChVodHRwX3Byb3RvY29sX29w",
            "dGlvbnMYCCABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5IdHRwMVByb3Rv",
            "Y29sT3B0aW9ucxJTChZodHRwMl9wcm90b2NvbF9vcHRpb25zGAkgASgLMiou",
            "ZW52b3kuY29uZmlnLmNvcmUudjMuSHR0cDJQcm90b2NvbE9wdGlvbnNCB4qT",
            "tyoCCAESSgoWaHR0cDNfcHJvdG9jb2xfb3B0aW9ucxgsIAEoCzIqLmVudm95",
            "LmNvbmZpZy5jb3JlLnYzLkh0dHAzUHJvdG9jb2xPcHRpb25zEiAKC3NlcnZl",
            "cl9uYW1lGAogASgJQgv6QghyBsABAsgBABKdAQocc2VydmVyX2hlYWRlcl90",
            "cmFuc2Zvcm1hdGlvbhgiIAEoDjJtLmVudm95LmV4dGVuc2lvbnMuZmlsdGVy",
            "cy5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLkh0dHBDb25u",
            "ZWN0aW9uTWFuYWdlci5TZXJ2ZXJIZWFkZXJUcmFuc2Zvcm1hdGlvbkII+kIF",
            "ggECEAESVgocc2NoZW1lX2hlYWRlcl90cmFuc2Zvcm1hdGlvbhgwIAEoCzIw",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLlNjaGVtZUhlYWRlclRyYW5zZm9ybWF0",
            "aW9uEkgKFm1heF9yZXF1ZXN0X2hlYWRlcnNfa2IYHSABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuVUludDMyVmFsdWVCCvpCByoFGIBAIAASPwoTc3RyZWFtX2lk",
            "bGVfdGltZW91dBgYIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIH",
            "ipO3KgIIARI7Cg9yZXF1ZXN0X3RpbWVvdXQYHCABKAsyGS5nb29nbGUucHJv",
            "dG9idWYuRHVyYXRpb25CB4qTtyoCCAESSwoXcmVxdWVzdF9oZWFkZXJzX3Rp",
            "bWVvdXQYKSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CD/pCBaoB",
            "AjIAipO3KgIIARIwCg1kcmFpbl90aW1lb3V0GAwgASgLMhkuZ29vZ2xlLnBy",
            "b3RvYnVmLkR1cmF0aW9uEjgKFWRlbGF5ZWRfY2xvc2VfdGltZW91dBgaIAEo",
            "CzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI4CgphY2Nlc3NfbG9nGA0g",
            "AygLMiQuZW52b3kuY29uZmlnLmFjY2Vzc2xvZy52My5BY2Nlc3NMb2cSSgoZ",
            "YWNjZXNzX2xvZ19mbHVzaF9pbnRlcnZhbBg2IAEoCzIZLmdvb2dsZS5wcm90",
            "b2J1Zi5EdXJhdGlvbkIM+kIJqgEGMgQQwIQ9EicKH2ZsdXNoX2FjY2Vzc19s",
            "b2dfb25fbmV3X3JlcXVlc3QYNyABKAgSPwoSdXNlX3JlbW90ZV9hZGRyZXNz",
            "GA4gASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZUIHipO3KgIIARIc",
            "ChR4ZmZfbnVtX3RydXN0ZWRfaG9wcxgTIAEoDRJUCiBvcmlnaW5hbF9pcF9k",
            "ZXRlY3Rpb25fZXh0ZW5zaW9ucxguIAMoCzIqLmVudm95LmNvbmZpZy5jb3Jl",
            "LnYzLlR5cGVkRXh0ZW5zaW9uQ29uZmlnElQKIGVhcmx5X2hlYWRlcl9tdXRh",
            "dGlvbl9leHRlbnNpb25zGDQgAygLMiouZW52b3kuY29uZmlnLmNvcmUudjMu",
            "VHlwZWRFeHRlbnNpb25Db25maWcSiQEKF2ludGVybmFsX2FkZHJlc3NfY29u",
            "ZmlnGBkgASgLMmguZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsu",
            "aHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMuSHR0cENvbm5lY3Rpb25NYW5h",
            "Z2VyLkludGVybmFsQWRkcmVzc0NvbmZpZxIXCg9za2lwX3hmZl9hcHBlbmQY",
            "FSABKAgSGAoDdmlhGBYgASgJQgv6QghyBsABAsgBABI3ChNnZW5lcmF0ZV9y",
            "ZXF1ZXN0X2lkGA8gASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIk",
            "ChxwcmVzZXJ2ZV9leHRlcm5hbF9yZXF1ZXN0X2lkGCAgASgIEikKIWFsd2F5",
            "c19zZXRfcmVxdWVzdF9pZF9pbl9yZXNwb25zZRglIAEoCBKaAQobZm9yd2Fy",
            "ZF9jbGllbnRfY2VydF9kZXRhaWxzGBAgASgOMmsuZW52b3kuZXh0ZW5zaW9u",
            "cy5maWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMu",
            "SHR0cENvbm5lY3Rpb25NYW5hZ2VyLkZvcndhcmRDbGllbnRDZXJ0RGV0YWls",
            "c0II+kIFggECEAESlwEKH3NldF9jdXJyZW50X2NsaWVudF9jZXJ0X2RldGFp",
            "bHMYESABKAsybi5lbnZveS5leHRlbnNpb25zLmZpbHRlcnMubmV0d29yay5o",
            "dHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52My5IdHRwQ29ubmVjdGlvbk1hbmFn",
            "ZXIuU2V0Q3VycmVudENsaWVudENlcnREZXRhaWxzEhoKEnByb3h5XzEwMF9j",
            "b250aW51ZRgSIAEoCBI5CjFyZXByZXNlbnRfaXB2NF9yZW1vdGVfYWRkcmVz",
            "c19hc19pcHY0X21hcHBlZF9pcHY2GBQgASgIEnkKD3VwZ3JhZGVfY29uZmln",
            "cxgXIAMoCzJgLmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5uZXR3b3JrLmh0",
            "dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLkh0dHBDb25uZWN0aW9uTWFuYWdl",
            "ci5VcGdyYWRlQ29uZmlnEjIKDm5vcm1hbGl6ZV9wYXRoGB4gASgLMhouZ29v",
            "Z2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIVCg1tZXJnZV9zbGFzaGVzGCEgASgI",
            "EpkBCiBwYXRoX3dpdGhfZXNjYXBlZF9zbGFzaGVzX2FjdGlvbhgtIAEoDjJv",
            "LmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5uZXR3b3JrLmh0dHBfY29ubmVj",
            "dGlvbl9tYW5hZ2VyLnYzLkh0dHBDb25uZWN0aW9uTWFuYWdlci5QYXRoV2l0",
            "aEVzY2FwZWRTbGFzaGVzQWN0aW9uEm0KFHJlcXVlc3RfaWRfZXh0ZW5zaW9u",
            "GCQgASgLMk8uZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsuaHR0",
            "cF9jb25uZWN0aW9uX21hbmFnZXIudjMuUmVxdWVzdElERXh0ZW5zaW9uEmkK",
            "EmxvY2FsX3JlcGx5X2NvbmZpZxgmIAEoCzJNLmVudm95LmV4dGVuc2lvbnMu",
            "ZmlsdGVycy5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLkxv",
            "Y2FsUmVwbHlDb25maWcSOQoYc3RyaXBfbWF0Y2hpbmdfaG9zdF9wb3J0GCcg",
            "ASgIQhfymP6PBRESD3N0cmlwX3BvcnRfbW9kZRIdChNzdHJpcF9hbnlfaG9z",
            "dF9wb3J0GCogASgISAESSAokc3RyZWFtX2Vycm9yX29uX2ludmFsaWRfaHR0",
            "cF9tZXNzYWdlGCggASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRKP",
            "AQoacGF0aF9ub3JtYWxpemF0aW9uX29wdGlvbnMYKyABKAsyay5lbnZveS5l",
            "eHRlbnNpb25zLmZpbHRlcnMubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFu",
            "YWdlci52My5IdHRwQ29ubmVjdGlvbk1hbmFnZXIuUGF0aE5vcm1hbGl6YXRp",
            "b25PcHRpb25zEh8KF3N0cmlwX3RyYWlsaW5nX2hvc3RfZG90GC8gASgIEoEB",
            "ChNwcm94eV9zdGF0dXNfY29uZmlnGDEgASgLMmQuZW52b3kuZXh0ZW5zaW9u",
            "cy5maWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMu",
            "SHR0cENvbm5lY3Rpb25NYW5hZ2VyLlByb3h5U3RhdHVzQ29uZmlnElIKHnR5",
            "cGVkX2hlYWRlcl92YWxpZGF0aW9uX2NvbmZpZxgyIAEoCzIqLmVudm95LmNv",
            "bmZpZy5jb3JlLnYzLlR5cGVkRXh0ZW5zaW9uQ29uZmlnEh8KF2FwcGVuZF94",
            "X2ZvcndhcmRlZF9wb3J0GDMgASgIEkcKI2FkZF9wcm94eV9wcm90b2NvbF9j",
            "b25uZWN0aW9uX3N0YXRlGDUgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xW",
            "YWx1ZRqUBAoHVHJhY2luZxIvCg9jbGllbnRfc2FtcGxpbmcYAyABKAsyFi5l",
            "bnZveS50eXBlLnYzLlBlcmNlbnQSLwoPcmFuZG9tX3NhbXBsaW5nGAQgASgL",
            "MhYuZW52b3kudHlwZS52My5QZXJjZW50EjAKEG92ZXJhbGxfc2FtcGxpbmcY",
            "BSABKAsyFi5lbnZveS50eXBlLnYzLlBlcmNlbnQSDwoHdmVyYm9zZRgGIAEo",
            "CBI5ChNtYXhfcGF0aF90YWdfbGVuZ3RoGAcgASgLMhwuZ29vZ2xlLnByb3Rv",
            "YnVmLlVJbnQzMlZhbHVlEjUKC2N1c3RvbV90YWdzGAggAygLMiAuZW52b3ku",
            "dHlwZS50cmFjaW5nLnYzLkN1c3RvbVRhZxI1Cghwcm92aWRlchgJIAEoCzIj",
            "LmVudm95LmNvbmZpZy50cmFjZS52My5UcmFjaW5nLkh0dHAiKAoNT3BlcmF0",
            "aW9uTmFtZRILCgdJTkdSRVNTEAASCgoGRUdSRVNTEAE6W5rFiB5WClRlbnZv",
            "eS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFn",
            "ZXIudjIuSHR0cENvbm5lY3Rpb25NYW5hZ2VyLlRyYWNpbmdKBAgBEAJKBAgC",
            "EANSDm9wZXJhdGlvbl9uYW1lUhhyZXF1ZXN0X2hlYWRlcnNfZm9yX3RhZ3Ma",
            "zgEKFUludGVybmFsQWRkcmVzc0NvbmZpZxIUCgx1bml4X3NvY2tldHMYASAB",
            "KAgSNAoLY2lkcl9yYW5nZXMYAiADKAsyHy5lbnZveS5jb25maWcuY29yZS52",
            "My5DaWRyUmFuZ2U6aZrFiB5kCmJlbnZveS5jb25maWcuZmlsdGVyLm5ldHdv",
            "cmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjIuSHR0cENvbm5lY3Rpb25N",
            "YW5hZ2VyLkludGVybmFsQWRkcmVzc0NvbmZpZxr4AQobU2V0Q3VycmVudENs",
            "aWVudENlcnREZXRhaWxzEisKB3N1YmplY3QYASABKAsyGi5nb29nbGUucHJv",
            "dG9idWYuQm9vbFZhbHVlEgwKBGNlcnQYAyABKAgSDQoFY2hhaW4YBiABKAgS",
            "CwoDZG5zGAQgASgIEgsKA3VyaRgFIAEoCDpvmsWIHmoKaGVudm95LmNvbmZp",
            "Zy5maWx0ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52Mi5I",
            "dHRwQ29ubmVjdGlvbk1hbmFnZXIuU2V0Q3VycmVudENsaWVudENlcnREZXRh",
            "aWxzSgQIAhADGo8CCg1VcGdyYWRlQ29uZmlnEhQKDHVwZ3JhZGVfdHlwZRgB",
            "IAEoCRJYCgdmaWx0ZXJzGAIgAygLMkcuZW52b3kuZXh0ZW5zaW9ucy5maWx0",
            "ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMuSHR0cEZp",
            "bHRlchIrCgdlbmFibGVkGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xW",
            "YWx1ZTphmsWIHlwKWmVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRw",
            "X2Nvbm5lY3Rpb25fbWFuYWdlci52Mi5IdHRwQ29ubmVjdGlvbk1hbmFnZXIu",
            "VXBncmFkZUNvbmZpZxqxAQoYUGF0aE5vcm1hbGl6YXRpb25PcHRpb25zEkkK",
            "GWZvcndhcmRpbmdfdHJhbnNmb3JtYXRpb24YASABKAsyJi5lbnZveS50eXBl",
            "Lmh0dHAudjMuUGF0aFRyYW5zZm9ybWF0aW9uEkoKGmh0dHBfZmlsdGVyX3Ry",
            "YW5zZm9ybWF0aW9uGAIgASgLMiYuZW52b3kudHlwZS5odHRwLnYzLlBhdGhU",
            "cmFuc2Zvcm1hdGlvbhrjAQoRUHJveHlTdGF0dXNDb25maWcSFgoOcmVtb3Zl",
            "X2RldGFpbHMYASABKAgSLQolcmVtb3ZlX2Nvbm5lY3Rpb25fdGVybWluYXRp",
            "b25fZGV0YWlscxgCIAEoCBIdChVyZW1vdmVfcmVzcG9uc2VfZmxhZ3MYAyAB",
            "KAgSJQodc2V0X3JlY29tbWVuZGVkX3Jlc3BvbnNlX2NvZGUYBCABKAgSFQoL",
            "dXNlX25vZGVfaWQYBSABKAhIABIcChJsaXRlcmFsX3Byb3h5X25hbWUYBiAB",
            "KAlIAEIMCgpwcm94eV9uYW1lIjYKCUNvZGVjVHlwZRIICgRBVVRPEAASCQoF",
            "SFRUUDEQARIJCgVIVFRQMhACEgkKBUhUVFAzEAMiUwoaU2VydmVySGVhZGVy",
            "VHJhbnNmb3JtYXRpb24SDQoJT1ZFUldSSVRFEAASFAoQQVBQRU5EX0lGX0FC",
            "U0VOVBABEhAKDFBBU1NfVEhST1VHSBACInkKGEZvcndhcmRDbGllbnRDZXJ0",
            "RGV0YWlscxIMCghTQU5JVElaRRAAEhAKDEZPUldBUkRfT05MWRABEhIKDkFQ",
            "UEVORF9GT1JXQVJEEAISEAoMU0FOSVRJWkVfU0VUEAMSFwoTQUxXQVlTX0ZP",
            "UldBUkRfT05MWRAEIqABChxQYXRoV2l0aEVzY2FwZWRTbGFzaGVzQWN0aW9u",
            "EiMKH0lNUExFTUVOVEFUSU9OX1NQRUNJRklDX0RFRkFVTFQQABISCg5LRUVQ",
            "X1VOQ0hBTkdFRBABEhIKDlJFSkVDVF9SRVFVRVNUEAISGQoVVU5FU0NBUEVf",
            "QU5EX1JFRElSRUNUEAMSGAoUVU5FU0NBUEVfQU5EX0ZPUldBUkQQBDpTmsWI",
            "Hk4KTGVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rp",
            "b25fbWFuYWdlci52Mi5IdHRwQ29ubmVjdGlvbk1hbmFnZXJCFgoPcm91dGVf",
            "c3BlY2lmaWVyEgP4QgFCEQoPc3RyaXBfcG9ydF9tb2RlSgQIGxAcSgQICxAM",
            "UgxpZGxlX3RpbWVvdXQitQEKEExvY2FsUmVwbHlDb25maWcSXAoHbWFwcGVy",
            "cxgBIAMoCzJLLmVudm95LmV4dGVuc2lvbnMuZmlsdGVycy5uZXR3b3JrLmh0",
            "dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzLlJlc3BvbnNlTWFwcGVyEkMKC2Jv",
            "ZHlfZm9ybWF0GAIgASgLMi4uZW52b3kuY29uZmlnLmNvcmUudjMuU3Vic3Rp",
            "dHV0aW9uRm9ybWF0U3RyaW5nIuACCg5SZXNwb25zZU1hcHBlchJECgZmaWx0",
            "ZXIYASABKAsyKi5lbnZveS5jb25maWcuYWNjZXNzbG9nLnYzLkFjY2Vzc0xv",
            "Z0ZpbHRlckII+kIFigECEAESPgoLc3RhdHVzX2NvZGUYAiABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWVCC/pCCCoGENgEKMgBEi4KBGJvZHkY",
            "AyABKAsyIC5lbnZveS5jb25maWcuY29yZS52My5EYXRhU291cmNlEkwKFGJv",
            "ZHlfZm9ybWF0X292ZXJyaWRlGAQgASgLMi4uZW52b3kuY29uZmlnLmNvcmUu",
            "djMuU3Vic3RpdHV0aW9uRm9ybWF0U3RyaW5nEkoKDmhlYWRlcnNfdG9fYWRk",
            "GAUgAygLMicuZW52b3kuY29uZmlnLmNvcmUudjMuSGVhZGVyVmFsdWVPcHRp",
            "b25CCfpCBpIBAxDoByKoAQoDUmRzEkMKDWNvbmZpZ19zb3VyY2UYASABKAsy",
            "Ii5lbnZveS5jb25maWcuY29yZS52My5Db25maWdTb3VyY2VCCPpCBYoBAhAB",
            "EhkKEXJvdXRlX2NvbmZpZ19uYW1lGAIgASgJOkGaxYgePAo6ZW52b3kuY29u",
            "ZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYy",
            "LlJkcyLcAQodU2NvcGVkUm91dGVDb25maWd1cmF0aW9uc0xpc3QSXgobc2Nv",
            "cGVkX3JvdXRlX2NvbmZpZ3VyYXRpb25zGAEgAygLMi8uZW52b3kuY29uZmln",
            "LnJvdXRlLnYzLlNjb3BlZFJvdXRlQ29uZmlndXJhdGlvbkII+kIFkgECCAE6",
            "W5rFiB5WClRlbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25u",
            "ZWN0aW9uX21hbmFnZXIudjIuU2NvcGVkUm91dGVDb25maWd1cmF0aW9uc0xp",
            "c3Qisw0KDFNjb3BlZFJvdXRlcxIVCgRuYW1lGAEgASgJQgf6QgRyAhABEn4K",
            "EXNjb3BlX2tleV9idWlsZGVyGAIgASgLMlkuZW52b3kuZXh0ZW5zaW9ucy5m",
            "aWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMuU2Nv",
            "cGVkUm91dGVzLlNjb3BlS2V5QnVpbGRlckII+kIFigECEAESPQoRcmRzX2Nv",
            "bmZpZ19zb3VyY2UYAyABKAsyIi5lbnZveS5jb25maWcuY29yZS52My5Db25m",
            "aWdTb3VyY2UShgEKIHNjb3BlZF9yb3V0ZV9jb25maWd1cmF0aW9uc19saXN0",
            "GAQgASgLMlouZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsuaHR0",
            "cF9jb25uZWN0aW9uX21hbmFnZXIudjMuU2NvcGVkUm91dGVDb25maWd1cmF0",
            "aW9uc0xpc3RIABJcCgpzY29wZWRfcmRzGAUgASgLMkYuZW52b3kuZXh0ZW5z",
            "aW9ucy5maWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIu",
            "djMuU2NvcGVkUmRzSAAagAkKD1Njb3BlS2V5QnVpbGRlchKGAQoJZnJhZ21l",
            "bnRzGAEgAygLMmkuZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsu",
            "aHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMuU2NvcGVkUm91dGVzLlNjb3Bl",
            "S2V5QnVpbGRlci5GcmFnbWVudEJ1aWxkZXJCCPpCBZIBAggBGocHCg9GcmFn",
            "bWVudEJ1aWxkZXISoAEKFmhlYWRlcl92YWx1ZV9leHRyYWN0b3IYASABKAsy",
            "fi5lbnZveS5leHRlbnNpb25zLmZpbHRlcnMubmV0d29yay5odHRwX2Nvbm5l",
            "Y3Rpb25fbWFuYWdlci52My5TY29wZWRSb3V0ZXMuU2NvcGVLZXlCdWlsZGVy",
            "LkZyYWdtZW50QnVpbGRlci5IZWFkZXJWYWx1ZUV4dHJhY3RvckgAGtcEChRI",
            "ZWFkZXJWYWx1ZUV4dHJhY3RvchIVCgRuYW1lGAEgASgJQgf6QgRyAhABEhkK",
            "EWVsZW1lbnRfc2VwYXJhdG9yGAIgASgJEg8KBWluZGV4GAMgASgNSAASnAEK",
            "B2VsZW1lbnQYBCABKAsyiAEuZW52b3kuZXh0ZW5zaW9ucy5maWx0ZXJzLm5l",
            "dHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjMuU2NvcGVkUm91dGVz",
            "LlNjb3BlS2V5QnVpbGRlci5GcmFnbWVudEJ1aWxkZXIuSGVhZGVyVmFsdWVF",
            "eHRyYWN0b3IuS3ZFbGVtZW50SAAaywEKCUt2RWxlbWVudBIaCglzZXBhcmF0",
            "b3IYASABKAlCB/pCBHICEAESFAoDa2V5GAIgASgJQgf6QgRyAhABOosBmsWI",
            "HoUBCoIBZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVj",
            "dGlvbl9tYW5hZ2VyLnYyLlNjb3BlZFJvdXRlcy5TY29wZUtleUJ1aWxkZXIu",
            "RnJhZ21lbnRCdWlsZGVyLkhlYWRlclZhbHVlRXh0cmFjdG9yLkt2RWxlbWVu",
            "dDp/msWIHnoKeGVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nv",
            "bm5lY3Rpb25fbWFuYWdlci52Mi5TY29wZWRSb3V0ZXMuU2NvcGVLZXlCdWls",
            "ZGVyLkZyYWdtZW50QnVpbGRlci5IZWFkZXJWYWx1ZUV4dHJhY3RvckIOCgxl",
            "eHRyYWN0X3R5cGU6aprFiB5lCmNlbnZveS5jb25maWcuZmlsdGVyLm5ldHdv",
            "cmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjIuU2NvcGVkUm91dGVzLlNj",
            "b3BlS2V5QnVpbGRlci5GcmFnbWVudEJ1aWxkZXJCCwoEdHlwZRID+EIBOlqa",
            "xYgeVQpTZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVj",
            "dGlvbl9tYW5hZ2VyLnYyLlNjb3BlZFJvdXRlcy5TY29wZUtleUJ1aWxkZXI6",
            "SprFiB5FCkNlbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25u",
            "ZWN0aW9uX21hbmFnZXIudjIuU2NvcGVkUm91dGVzQhcKEGNvbmZpZ19zcGVj",
            "aWZpZXISA/hCASLEAQoJU2NvcGVkUmRzEk4KGHNjb3BlZF9yZHNfY29uZmln",
            "X3NvdXJjZRgBIAEoCzIiLmVudm95LmNvbmZpZy5jb3JlLnYzLkNvbmZpZ1Nv",
            "dXJjZUII+kIFigECEAESHgoWc3Jkc19yZXNvdXJjZXNfbG9jYXRvchgCIAEo",
            "CTpHmsWIHkIKQGVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nv",
            "bm5lY3Rpb25fbWFuYWdlci52Mi5TY29wZWRSZHMinAIKCkh0dHBGaWx0ZXIS",
            "FQoEbmFtZRgBIAEoCUIH+kIEcgIQARIsCgx0eXBlZF9jb25maWcYBCABKAsy",
            "FC5nb29nbGUucHJvdG9idWYuQW55SAASRwoQY29uZmlnX2Rpc2NvdmVyeRgF",
            "IAEoCzIrLmVudm95LmNvbmZpZy5jb3JlLnYzLkV4dGVuc2lvbkNvbmZpZ1Nv",
            "dXJjZUgAEhMKC2lzX29wdGlvbmFsGAYgASgIOkiaxYgeQwpBZW52b3kuY29u",
            "ZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYy",
            "Lkh0dHBGaWx0ZXJCDQoLY29uZmlnX3R5cGVKBAgDEARKBAgCEANSBmNvbmZp",
            "ZyKSAQoSUmVxdWVzdElERXh0ZW5zaW9uEioKDHR5cGVkX2NvbmZpZxgBIAEo",
            "CzIULmdvb2dsZS5wcm90b2J1Zi5Bbnk6UJrFiB5LCkllbnZveS5jb25maWcu",
            "ZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjIuUmVx",
            "dWVzdElERXh0ZW5zaW9uIoYBCiBFbnZveU1vYmlsZUh0dHBDb25uZWN0aW9u",
            "TWFuYWdlchJiCgZjb25maWcYASABKAsyUi5lbnZveS5leHRlbnNpb25zLmZp",
            "bHRlcnMubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52My5IdHRw",
            "Q29ubmVjdGlvbk1hbmFnZXJC7wEKSWlvLmVudm95cHJveHkuZW52b3kuZXh0",
            "ZW5zaW9ucy5maWx0ZXJzLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFn",
            "ZXIudjNCGkh0dHBDb25uZWN0aW9uTWFuYWdlclByb3RvUAFafGdpdGh1Yi5j",
            "b20vZW52b3lwcm94eS9nby1jb250cm9sLXBsYW5lL2Vudm95L2V4dGVuc2lv",
            "bnMvZmlsdGVycy9uZXR3b3JrL2h0dHBfY29ubmVjdGlvbl9tYW5hZ2VyL3Yz",
            "O2h0dHBfY29ubmVjdGlvbl9tYW5hZ2VydjO6gMjRBgIQAmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Accesslog.V3.AccesslogReflection.Descriptor, global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor, global::Envoy.Config.Core.V3.SubstitutionFormatStringReflection.Descriptor, global::Envoy.Config.Route.V3.RouteReflection.Descriptor, global::Envoy.Config.Route.V3.ScopedRouteReflection.Descriptor, global::Envoy.Config.Trace.V3.HttpTracerReflection.Descriptor, global::Envoy.Type.Http.V3.PathTransformationReflection.Descriptor, global::Envoy.Type.Tracing.V3.CustomTagReflection.Descriptor, global::Envoy.Type.V3.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.SecurityReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Parser, new[]{ "CodecType", "StatPrefix", "Rds", "RouteConfig", "ScopedRoutes", "HttpFilters", "AddUserAgent", "Tracing", "CommonHttpProtocolOptions", "HttpProtocolOptions", "Http2ProtocolOptions", "Http3ProtocolOptions", "ServerName", "ServerHeaderTransformation", "SchemeHeaderTransformation", "MaxRequestHeadersKb", "StreamIdleTimeout", "RequestTimeout", "RequestHeadersTimeout", "DrainTimeout", "DelayedCloseTimeout", "AccessLog", "AccessLogFlushInterval", "FlushAccessLogOnNewRequest", "UseRemoteAddress", "XffNumTrustedHops", "OriginalIpDetectionExtensions", "EarlyHeaderMutationExtensions", "InternalAddressConfig", "SkipXffAppend", "Via", "GenerateRequestId", "PreserveExternalRequestId", "AlwaysSetRequestIdInResponse", "ForwardClientCertDetails", "SetCurrentClientCertDetails", "Proxy100Continue", "RepresentIpv4RemoteAddressAsIpv4MappedIpv6", "UpgradeConfigs", "NormalizePath", "MergeSlashes", "PathWithEscapedSlashesAction", "RequestIdExtension", "LocalReplyConfig", "StripMatchingHostPort", "StripAnyHostPort", "StreamErrorOnInvalidHttpMessage", "PathNormalizationOptions", "StripTrailingHostDot", "ProxyStatusConfig", "TypedHeaderValidationConfig", "AppendXForwardedPort", "AddProxyProtocolConnectionState" }, new[]{ "RouteSpecifier", "StripPortMode" }, new[]{ typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType), typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation), typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails), typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing.Parser, new[]{ "ClientSampling", "RandomSampling", "OverallSampling", "Verbose", "MaxPathTagLength", "CustomTags", "Provider" }, null, new[]{ typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing.Types.OperationName) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig.Parser, new[]{ "UnixSockets", "CidrRanges" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails.Parser, new[]{ "Subject", "Cert", "Chain", "Dns", "Uri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig.Parser, new[]{ "UpgradeType", "Filters", "Enabled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions.Parser, new[]{ "ForwardingTransformation", "HttpFilterTransformation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig.Parser, new[]{ "RemoveDetails", "RemoveConnectionTerminationDetails", "RemoveResponseFlags", "SetRecommendedResponseCode", "UseNodeId", "LiteralProxyName" }, new[]{ "ProxyName" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig.Parser, new[]{ "Mappers", "BodyFormat" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper.Parser, new[]{ "Filter", "StatusCode", "Body", "BodyFormatOverride", "HeadersToAdd" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds.Parser, new[]{ "ConfigSource", "RouteConfigName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList.Parser, new[]{ "ScopedRouteConfigurations" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Parser, new[]{ "Name", "ScopeKeyBuilder", "RdsConfigSource", "ScopedRouteConfigurationsList", "ScopedRds" }, new[]{ "ConfigSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Parser, new[]{ "Fragments" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Parser, new[]{ "HeaderValueExtractor" }, new[]{ "Type" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Parser, new[]{ "Name", "ElementSeparator", "Index", "Element" }, new[]{ "ExtractType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement.Parser, new[]{ "Separator", "Key" }, null, null, null, null)})})})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds.Parser, new[]{ "ScopedRdsConfigSource", "SrdsResourcesLocator" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter.Parser, new[]{ "Name", "TypedConfig", "ConfigDiscovery", "IsOptional" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension.Parser, new[]{ "TypedConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.EnvoyMobileHttpConnectionManager), global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.EnvoyMobileHttpConnectionManager.Parser, new[]{ "Config" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#next-free-field: 56]
  /// </summary>
  public sealed partial class HttpConnectionManager : pb::IMessage<HttpConnectionManager>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HttpConnectionManager> _parser = new pb::MessageParser<HttpConnectionManager>(() => new HttpConnectionManager());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HttpConnectionManager> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpConnectionManager() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpConnectionManager(HttpConnectionManager other) : this() {
      codecType_ = other.codecType_;
      statPrefix_ = other.statPrefix_;
      httpFilters_ = other.httpFilters_.Clone();
      AddUserAgent = other.AddUserAgent;
      tracing_ = other.tracing_ != null ? other.tracing_.Clone() : null;
      commonHttpProtocolOptions_ = other.commonHttpProtocolOptions_ != null ? other.commonHttpProtocolOptions_.Clone() : null;
      httpProtocolOptions_ = other.httpProtocolOptions_ != null ? other.httpProtocolOptions_.Clone() : null;
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      http3ProtocolOptions_ = other.http3ProtocolOptions_ != null ? other.http3ProtocolOptions_.Clone() : null;
      serverName_ = other.serverName_;
      serverHeaderTransformation_ = other.serverHeaderTransformation_;
      schemeHeaderTransformation_ = other.schemeHeaderTransformation_ != null ? other.schemeHeaderTransformation_.Clone() : null;
      MaxRequestHeadersKb = other.MaxRequestHeadersKb;
      streamIdleTimeout_ = other.streamIdleTimeout_ != null ? other.streamIdleTimeout_.Clone() : null;
      requestTimeout_ = other.requestTimeout_ != null ? other.requestTimeout_.Clone() : null;
      requestHeadersTimeout_ = other.requestHeadersTimeout_ != null ? other.requestHeadersTimeout_.Clone() : null;
      drainTimeout_ = other.drainTimeout_ != null ? other.drainTimeout_.Clone() : null;
      delayedCloseTimeout_ = other.delayedCloseTimeout_ != null ? other.delayedCloseTimeout_.Clone() : null;
      accessLog_ = other.accessLog_.Clone();
      accessLogFlushInterval_ = other.accessLogFlushInterval_ != null ? other.accessLogFlushInterval_.Clone() : null;
      flushAccessLogOnNewRequest_ = other.flushAccessLogOnNewRequest_;
      UseRemoteAddress = other.UseRemoteAddress;
      xffNumTrustedHops_ = other.xffNumTrustedHops_;
      originalIpDetectionExtensions_ = other.originalIpDetectionExtensions_.Clone();
      earlyHeaderMutationExtensions_ = other.earlyHeaderMutationExtensions_.Clone();
      internalAddressConfig_ = other.internalAddressConfig_ != null ? other.internalAddressConfig_.Clone() : null;
      skipXffAppend_ = other.skipXffAppend_;
      via_ = other.via_;
      GenerateRequestId = other.GenerateRequestId;
      preserveExternalRequestId_ = other.preserveExternalRequestId_;
      alwaysSetRequestIdInResponse_ = other.alwaysSetRequestIdInResponse_;
      forwardClientCertDetails_ = other.forwardClientCertDetails_;
      setCurrentClientCertDetails_ = other.setCurrentClientCertDetails_ != null ? other.setCurrentClientCertDetails_.Clone() : null;
      proxy100Continue_ = other.proxy100Continue_;
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = other.representIpv4RemoteAddressAsIpv4MappedIpv6_;
      upgradeConfigs_ = other.upgradeConfigs_.Clone();
      NormalizePath = other.NormalizePath;
      mergeSlashes_ = other.mergeSlashes_;
      pathWithEscapedSlashesAction_ = other.pathWithEscapedSlashesAction_;
      requestIdExtension_ = other.requestIdExtension_ != null ? other.requestIdExtension_.Clone() : null;
      localReplyConfig_ = other.localReplyConfig_ != null ? other.localReplyConfig_.Clone() : null;
      stripMatchingHostPort_ = other.stripMatchingHostPort_;
      StreamErrorOnInvalidHttpMessage = other.StreamErrorOnInvalidHttpMessage;
      pathNormalizationOptions_ = other.pathNormalizationOptions_ != null ? other.pathNormalizationOptions_.Clone() : null;
      stripTrailingHostDot_ = other.stripTrailingHostDot_;
      proxyStatusConfig_ = other.proxyStatusConfig_ != null ? other.proxyStatusConfig_.Clone() : null;
      typedHeaderValidationConfig_ = other.typedHeaderValidationConfig_ != null ? other.typedHeaderValidationConfig_.Clone() : null;
      appendXForwardedPort_ = other.appendXForwardedPort_;
      AddProxyProtocolConnectionState = other.AddProxyProtocolConnectionState;
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          Rds = other.Rds.Clone();
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          RouteConfig = other.RouteConfig.Clone();
          break;
        case RouteSpecifierOneofCase.ScopedRoutes:
          ScopedRoutes = other.ScopedRoutes.Clone();
          break;
      }

      switch (other.StripPortModeCase) {
        case StripPortModeOneofCase.StripAnyHostPort:
          StripAnyHostPort = other.StripAnyHostPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpConnectionManager Clone() {
      return new HttpConnectionManager(this);
    }

    /// <summary>Field number for the "codec_type" field.</summary>
    public const int CodecTypeFieldNumber = 1;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType codecType_ = global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto;
    /// <summary>
    /// Supplies the type of codec that the connection manager should use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType CodecType {
      get { return codecType_; }
      set {
        codecType_ = value;
      }
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 2;
    private string statPrefix_ = "";
    /// <summary>
    /// The human readable prefix to use when emitting statistics for the
    /// connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats>` for
    /// more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rds" field.</summary>
    public const int RdsFieldNumber = 3;
    /// <summary>
    /// The connection manager’s route table will be dynamically loaded via the RDS API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds Rds {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.Rds ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.Rds;
      }
    }

    /// <summary>Field number for the "route_config" field.</summary>
    public const int RouteConfigFieldNumber = 4;
    /// <summary>
    /// The route table for the connection manager is static and is specified in this property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteConfiguration RouteConfig {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig ? (global::Envoy.Config.Route.V3.RouteConfiguration) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.RouteConfig;
      }
    }

    /// <summary>Field number for the "scoped_routes" field.</summary>
    public const int ScopedRoutesFieldNumber = 31;
    /// <summary>
    /// A route table will be dynamically assigned to each request based on request attributes
    /// (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
    /// specified in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes ScopedRoutes {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.ScopedRoutes;
      }
    }

    /// <summary>Field number for the "http_filters" field.</summary>
    public const int HttpFiltersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> _repeated_httpFilters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> httpFilters_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter>();
    /// <summary>
    /// A list of individual HTTP filters that make up the filter chain for
    /// requests made to the connection manager. :ref:`Order matters &lt;arch_overview_http_filters_ordering>`
    /// as the filters are processed sequentially as request events happen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> HttpFilters {
      get { return httpFilters_; }
    }

    /// <summary>Field number for the "add_user_agent" field.</summary>
    public const int AddUserAgentFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_addUserAgent_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? addUserAgent_;
    /// <summary>
    /// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
    /// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
    /// documentation for more information. Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AddUserAgent {
      get { return addUserAgent_; }
      set {
        addUserAgent_ = value;
      }
    }


    /// <summary>Field number for the "tracing" field.</summary>
    public const int TracingFieldNumber = 7;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing tracing_;
    /// <summary>
    /// Presence of the object defines whether the connection manager
    /// emits :ref:`tracing &lt;arch_overview_tracing>` data to the :ref:`configured tracing provider
    /// &lt;envoy_v3_api_msg_config.trace.v3.Tracing>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing Tracing {
      get { return tracing_; }
      set {
        tracing_ = value;
      }
    }

    /// <summary>Field number for the "common_http_protocol_options" field.</summary>
    public const int CommonHttpProtocolOptionsFieldNumber = 35;
    private global::Envoy.Config.Core.V3.HttpProtocolOptions commonHttpProtocolOptions_;
    /// <summary>
    /// Additional settings for HTTP requests handled by the connection manager. These will be
    /// applicable to both HTTP1 and HTTP2 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.HttpProtocolOptions CommonHttpProtocolOptions {
      get { return commonHttpProtocolOptions_; }
      set {
        commonHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 8;
    private global::Envoy.Config.Core.V3.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
    /// [#comment:TODO: The following fields are ignored when the
    /// :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    /// is present:
    /// 1. :ref:`allow_chunked_length &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length>`]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 9;
    private global::Envoy.Config.Core.V3.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http3_protocol_options" field.</summary>
    public const int Http3ProtocolOptionsFieldNumber = 44;
    private global::Envoy.Config.Core.V3.Http3ProtocolOptions http3ProtocolOptions_;
    /// <summary>
    /// Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http3ProtocolOptions Http3ProtocolOptions {
      get { return http3ProtocolOptions_; }
      set {
        http3ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "server_name" field.</summary>
    public const int ServerNameFieldNumber = 10;
    private string serverName_ = "";
    /// <summary>
    /// An optional override that the connection manager will write to the server
    /// header in responses. If not set, the default is ``envoy``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServerName {
      get { return serverName_; }
      set {
        serverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_header_transformation" field.</summary>
    public const int ServerHeaderTransformationFieldNumber = 34;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation serverHeaderTransformation_ = global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite;
    /// <summary>
    /// Defines the action to be applied to the Server header on the response path.
    /// By default, Envoy will overwrite the header with the value specified in
    /// server_name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation ServerHeaderTransformation {
      get { return serverHeaderTransformation_; }
      set {
        serverHeaderTransformation_ = value;
      }
    }

    /// <summary>Field number for the "scheme_header_transformation" field.</summary>
    public const int SchemeHeaderTransformationFieldNumber = 48;
    private global::Envoy.Config.Core.V3.SchemeHeaderTransformation schemeHeaderTransformation_;
    /// <summary>
    /// Allows for explicit transformation of the :scheme header on the request path.
    /// If not set, Envoy's default :ref:`scheme  &lt;config_http_conn_man_headers_scheme>`
    /// handling applies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SchemeHeaderTransformation SchemeHeaderTransformation {
      get { return schemeHeaderTransformation_; }
      set {
        schemeHeaderTransformation_ = value;
      }
    }

    /// <summary>Field number for the "max_request_headers_kb" field.</summary>
    public const int MaxRequestHeadersKbFieldNumber = 29;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestHeadersKb_codec = pb::FieldCodec.ForStructWrapper<uint>(234);
    private uint? maxRequestHeadersKb_;
    /// <summary>
    /// The maximum request headers size for incoming connections.
    /// If unconfigured, the default max request headers allowed is 60 KiB.
    /// Requests that exceed this limit will receive a 431 response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxRequestHeadersKb {
      get { return maxRequestHeadersKb_; }
      set {
        maxRequestHeadersKb_ = value;
      }
    }


    /// <summary>Field number for the "stream_idle_timeout" field.</summary>
    public const int StreamIdleTimeoutFieldNumber = 24;
    private global::Google.Protobuf.WellKnownTypes.Duration streamIdleTimeout_;
    /// <summary>
    /// The stream idle timeout for connections managed by the connection manager.
    /// If not specified, this defaults to 5 minutes. The default value was selected
    /// so as not to interfere with any smaller configured timeouts that may have
    /// existed in configurations prior to the introduction of this feature, while
    /// introducing robustness to TCP connections that terminate without a FIN.
    ///
    /// This idle timeout applies to new streams and is overridable by the
    /// :ref:`route-level idle_timeout
    /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>`. Even on a stream in
    /// which the override applies, prior to receipt of the initial request
    /// headers, the :ref:`stream_idle_timeout
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
    /// applies. Each time an encode/decode event for headers or data is processed
    /// for the stream, the timer will be reset. If the timeout fires, the stream
    /// is terminated with a 408 Request Timeout error code if no upstream response
    /// header has been received, otherwise a stream reset occurs.
    ///
    /// This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
    /// window to write any remaining stream data once the entirety of stream data (local end stream is
    /// true) has been buffered pending available window. In other words, this timeout defends against
    /// a peer that does not release enough window to completely write the stream, even though all
    /// data has been proxied within available flow control windows. If the timeout is hit in this
    /// case, the :ref:`tx_flush_timeout &lt;config_http_conn_man_stats_per_codec>` counter will be
    /// incremented. Note that :ref:`max_stream_duration
    /// &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` does not apply to
    /// this corner case.
    ///
    /// If the :ref:`overload action &lt;config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
    /// is configured, this timeout is scaled according to the value for
    /// :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
    ///
    /// Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
    /// to the granularity of events presented to the connection manager. For example, while receiving
    /// very large request headers, it may be the case that there is traffic regularly arriving on the
    /// wire while the connection manage is only able to observe the end-of-headers event, hence the
    /// stream may still idle timeout.
    ///
    /// A value of 0 will completely disable the connection manager stream idle
    /// timeout, although per-route idle timeout overrides will continue to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration StreamIdleTimeout {
      get { return streamIdleTimeout_; }
      set {
        streamIdleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "request_timeout" field.</summary>
    public const int RequestTimeoutFieldNumber = 28;
    private global::Google.Protobuf.WellKnownTypes.Duration requestTimeout_;
    /// <summary>
    /// The amount of time that Envoy will wait for the entire request to be received.
    /// The timer is activated when the request is initiated, and is disarmed when the last byte of the
    /// request is sent upstream (i.e. all decoding filters have processed the request), OR when the
    /// response is initiated. If not specified or set to 0, this timeout is disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestTimeout {
      get { return requestTimeout_; }
      set {
        requestTimeout_ = value;
      }
    }

    /// <summary>Field number for the "request_headers_timeout" field.</summary>
    public const int RequestHeadersTimeoutFieldNumber = 41;
    private global::Google.Protobuf.WellKnownTypes.Duration requestHeadersTimeout_;
    /// <summary>
    /// The amount of time that Envoy will wait for the request headers to be received. The timer is
    /// activated when the first byte of the headers is received, and is disarmed when the last byte of
    /// the headers has been received. If not specified or set to 0, this timeout is disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestHeadersTimeout {
      get { return requestHeadersTimeout_; }
      set {
        requestHeadersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "drain_timeout" field.</summary>
    public const int DrainTimeoutFieldNumber = 12;
    private global::Google.Protobuf.WellKnownTypes.Duration drainTimeout_;
    /// <summary>
    /// The time that Envoy will wait between sending an HTTP/2 “shutdown
    /// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
    /// This is used so that Envoy provides a grace period for new streams that
    /// race with the final GOAWAY frame. During this grace period, Envoy will
    /// continue to accept new streams. After the grace period, a final GOAWAY
    /// frame is sent and Envoy will start refusing new streams. Draining occurs
    /// both when a connection hits the idle timeout or during general server
    /// draining. The default grace period is 5000 milliseconds (5 seconds) if this
    /// option is not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DrainTimeout {
      get { return drainTimeout_; }
      set {
        drainTimeout_ = value;
      }
    }

    /// <summary>Field number for the "delayed_close_timeout" field.</summary>
    public const int DelayedCloseTimeoutFieldNumber = 26;
    private global::Google.Protobuf.WellKnownTypes.Duration delayedCloseTimeout_;
    /// <summary>
    /// The delayed close timeout is for downstream connections managed by the HTTP connection manager.
    /// It is defined as a grace period after connection close processing has been locally initiated
    /// during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
    /// from the downstream connection) prior to Envoy closing the socket associated with that
    /// connection.
    /// NOTE: This timeout is enforced even when the socket associated with the downstream connection
    /// is pending a flush of the write buffer. However, any progress made writing data to the socket
    /// will restart the timer associated with this timeout. This means that the total grace period for
    /// a socket in this state will be
    /// &lt;total_time_waiting_for_write_buffer_flushes>+&lt;delayed_close_timeout>.
    ///
    /// Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
    /// sequence mitigates a race condition that exists when downstream clients do not drain/process
    /// data in a connection's receive buffer after a remote close has been detected via a socket
    /// write(). This race leads to such clients failing to process the response code sent by Envoy,
    /// which could result in erroneous downstream processing.
    ///
    /// If the timeout triggers, Envoy will close the connection's socket.
    ///
    /// The default timeout is 1000 ms if this option is not specified.
    ///
    /// .. NOTE::
    ///    To be useful in avoiding the race condition described above, this timeout must be set
    ///    to *at least* &lt;max round trip time expected between clients and Envoy>+&lt;100ms to account for
    ///    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
    ///
    /// .. WARNING::
    ///    A value of 0 will completely disable delayed close processing. When disabled, the downstream
    ///    connection's socket will be closed immediately after the write flush is completed or will
    ///    never close if the write flush does not complete.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DelayedCloseTimeout {
      get { return delayedCloseTimeout_; }
      set {
        delayedCloseTimeout_ = value;
      }
    }

    /// <summary>Field number for the "access_log" field.</summary>
    public const int AccessLogFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Accesslog.V3.AccessLog> _repeated_accessLog_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Accesslog.V3.AccessLog.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog> accessLog_ = new pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog>();
    /// <summary>
    /// Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs>`
    /// emitted by the connection manager.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Accesslog.V3.AccessLog> AccessLog {
      get { return accessLog_; }
    }

    /// <summary>Field number for the "access_log_flush_interval" field.</summary>
    public const int AccessLogFlushIntervalFieldNumber = 54;
    private global::Google.Protobuf.WellKnownTypes.Duration accessLogFlushInterval_;
    /// <summary>
    /// The interval to flush the above access logs. By default, the HCM will flush exactly one access log
    /// on stream close, when the HTTP request is complete. If this field is set, the HCM will flush access
    /// logs periodically at the specified interval. This is especially useful in the case of long-lived
    /// requests, such as CONNECT and Websockets. Final access logs can be detected via the
    /// `requestComplete()` method of `StreamInfo` in access log filters, or thru the `%DURATION%` substitution
    /// string.
    /// The interval must be at least 1 millisecond.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration AccessLogFlushInterval {
      get { return accessLogFlushInterval_; }
      set {
        accessLogFlushInterval_ = value;
      }
    }

    /// <summary>Field number for the "flush_access_log_on_new_request" field.</summary>
    public const int FlushAccessLogOnNewRequestFieldNumber = 55;
    private bool flushAccessLogOnNewRequest_;
    /// <summary>
    /// If set to true, HCM will flush an access log once when a new HTTP request is received, after request
    /// headers have been evaluated, before iterating through the HTTP filter chain.
    /// Details related to upstream cluster, such as upstream host, will not be available for this log.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool FlushAccessLogOnNewRequest {
      get { return flushAccessLogOnNewRequest_; }
      set {
        flushAccessLogOnNewRequest_ = value;
      }
    }

    /// <summary>Field number for the "use_remote_address" field.</summary>
    public const int UseRemoteAddressFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_useRemoteAddress_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? useRemoteAddress_;
    /// <summary>
    /// If set to true, the connection manager will use the real remote address
    /// of the client connection when determining internal versus external origin and manipulating
    /// various headers. If set to false or absent, the connection manager will use the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for`,
    /// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? UseRemoteAddress {
      get { return useRemoteAddress_; }
      set {
        useRemoteAddress_ = value;
      }
    }


    /// <summary>Field number for the "xff_num_trusted_hops" field.</summary>
    public const int XffNumTrustedHopsFieldNumber = 19;
    private uint xffNumTrustedHops_;
    /// <summary>
    /// The number of additional ingress proxy hops from the right side of the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
    /// determining the origin client's IP address. The default is zero if this option
    /// is not specified. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint XffNumTrustedHops {
      get { return xffNumTrustedHops_; }
      set {
        xffNumTrustedHops_ = value;
      }
    }

    /// <summary>Field number for the "original_ip_detection_extensions" field.</summary>
    public const int OriginalIpDetectionExtensionsFieldNumber = 46;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.TypedExtensionConfig> _repeated_originalIpDetectionExtensions_codec
        = pb::FieldCodec.ForMessage(370, global::Envoy.Config.Core.V3.TypedExtensionConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> originalIpDetectionExtensions_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig>();
    /// <summary>
    /// The configuration for the original IP detection extensions.
    ///
    /// When configured the extensions will be called along with the request headers
    /// and information about the downstream connection, such as the directly connected address.
    /// Each extension will then use these parameters to decide the request's effective remote address.
    /// If an extension fails to detect the original IP address and isn't configured to reject
    /// the request, the HCM will try the remaining extensions until one succeeds or rejects
    /// the request. If the request isn't rejected nor any extension succeeds, the HCM will
    /// fallback to using the remote address.
    ///
    /// .. WARNING::
    ///    Extensions cannot be used in conjunction with :ref:`use_remote_address
    ///    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
    ///    nor :ref:`xff_num_trusted_hops
    ///    &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`.
    ///
    /// [#extension-category: envoy.http.original_ip_detection]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> OriginalIpDetectionExtensions {
      get { return originalIpDetectionExtensions_; }
    }

    /// <summary>Field number for the "early_header_mutation_extensions" field.</summary>
    public const int EarlyHeaderMutationExtensionsFieldNumber = 52;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.TypedExtensionConfig> _repeated_earlyHeaderMutationExtensions_codec
        = pb::FieldCodec.ForMessage(418, global::Envoy.Config.Core.V3.TypedExtensionConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> earlyHeaderMutationExtensions_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig>();
    /// <summary>
    /// The configuration for the early header mutation extensions.
    ///
    /// When configured the extensions will be called before any routing, tracing, or any filter processing.
    /// Each extension will be applied in the order they are configured.
    /// If the same header is mutated by multiple extensions, then the last extension will win.
    ///
    /// [#extension-category: envoy.http.early_header_mutation]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> EarlyHeaderMutationExtensions {
      get { return earlyHeaderMutationExtensions_; }
    }

    /// <summary>Field number for the "internal_address_config" field.</summary>
    public const int InternalAddressConfigFieldNumber = 25;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig internalAddressConfig_;
    /// <summary>
    /// Configures what network addresses are considered internal for stats and header sanitation
    /// purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
    /// See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
    /// information about internal/external addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig InternalAddressConfig {
      get { return internalAddressConfig_; }
      set {
        internalAddressConfig_ = value;
      }
    }

    /// <summary>Field number for the "skip_xff_append" field.</summary>
    public const int SkipXffAppendFieldNumber = 21;
    private bool skipXffAppend_;
    /// <summary>
    /// If set, Envoy will not append the remote address to the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
    /// conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
    /// has mutated the request headers. While :ref:`use_remote_address
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
    /// will also suppress XFF addition, it has consequences for logging and other
    /// Envoy uses of the remote address, so ``skip_xff_append`` should be used
    /// when only an elision of XFF addition is intended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SkipXffAppend {
      get { return skipXffAppend_; }
      set {
        skipXffAppend_ = value;
      }
    }

    /// <summary>Field number for the "via" field.</summary>
    public const int ViaFieldNumber = 22;
    private string via_ = "";
    /// <summary>
    /// Via header value to append to request and response headers. If this is
    /// empty, no via header will be appended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Via {
      get { return via_; }
      set {
        via_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "generate_request_id" field.</summary>
    public const int GenerateRequestIdFieldNumber = 15;
    private static readonly pb::FieldCodec<bool?> _single_generateRequestId_codec = pb::FieldCodec.ForStructWrapper<bool>(122);
    private bool? generateRequestId_;
    /// <summary>
    /// Whether the connection manager will generate the :ref:`x-request-id
    /// &lt;config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
    /// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
    /// is not desired it can be disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? GenerateRequestId {
      get { return generateRequestId_; }
      set {
        generateRequestId_ = value;
      }
    }


    /// <summary>Field number for the "preserve_external_request_id" field.</summary>
    public const int PreserveExternalRequestIdFieldNumber = 32;
    private bool preserveExternalRequestId_;
    /// <summary>
    /// Whether the connection manager will keep the :ref:`x-request-id
    /// &lt;config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
    /// (Edge request is the request from external clients to front Envoy) and not reset it, which
    /// is the current Envoy behaviour. This defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PreserveExternalRequestId {
      get { return preserveExternalRequestId_; }
      set {
        preserveExternalRequestId_ = value;
      }
    }

    /// <summary>Field number for the "always_set_request_id_in_response" field.</summary>
    public const int AlwaysSetRequestIdInResponseFieldNumber = 37;
    private bool alwaysSetRequestIdInResponse_;
    /// <summary>
    /// If set, Envoy will always set :ref:`x-request-id &lt;config_http_conn_man_headers_x-request-id>` header in response.
    /// If this is false or not set, the request ID is returned in responses only if tracing is forced using
    /// :ref:`x-envoy-force-trace &lt;config_http_conn_man_headers_x-envoy-force-trace>` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AlwaysSetRequestIdInResponse {
      get { return alwaysSetRequestIdInResponse_; }
      set {
        alwaysSetRequestIdInResponse_ = value;
      }
    }

    /// <summary>Field number for the "forward_client_cert_details" field.</summary>
    public const int ForwardClientCertDetailsFieldNumber = 16;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails forwardClientCertDetails_ = global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize;
    /// <summary>
    /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
    /// header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails ForwardClientCertDetails {
      get { return forwardClientCertDetails_; }
      set {
        forwardClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "set_current_client_cert_details" field.</summary>
    public const int SetCurrentClientCertDetailsFieldNumber = 17;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails setCurrentClientCertDetails_;
    /// <summary>
    /// This field is valid only when :ref:`forward_client_cert_details
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details>`
    /// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
    /// the client certificate to be forwarded. Note that in the
    /// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
    /// ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails SetCurrentClientCertDetails {
      get { return setCurrentClientCertDetails_; }
      set {
        setCurrentClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "proxy_100_continue" field.</summary>
    public const int Proxy100ContinueFieldNumber = 18;
    private bool proxy100Continue_;
    /// <summary>
    /// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
    /// 100-continue" headers upstream, and forward "100 Continue" responses
    /// downstream. If this is false or not set, Envoy will instead strip the
    /// "Expect: 100-continue" header, and send a "100 Continue" response itself.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Proxy100Continue {
      get { return proxy100Continue_; }
      set {
        proxy100Continue_ = value;
      }
    }

    /// <summary>Field number for the "represent_ipv4_remote_address_as_ipv4_mapped_ipv6" field.</summary>
    public const int RepresentIpv4RemoteAddressAsIpv4MappedIpv6FieldNumber = 20;
    private bool representIpv4RemoteAddressAsIpv4MappedIpv6_;
    /// <summary>
    /// If
    /// :ref:`use_remote_address
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
    /// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
    /// an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
    /// This is useful for testing compatibility of upstream services that parse the header value. For
    /// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
    /// &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
    /// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
    /// &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
    /// control.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
      get { return representIpv4RemoteAddressAsIpv4MappedIpv6_; }
      set {
        representIpv4RemoteAddressAsIpv4MappedIpv6_ = value;
      }
    }

    /// <summary>Field number for the "upgrade_configs" field.</summary>
    public const int UpgradeConfigsFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig> _repeated_upgradeConfigs_codec
        = pb::FieldCodec.ForMessage(186, global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig> upgradeConfigs_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.UpgradeConfig> UpgradeConfigs {
      get { return upgradeConfigs_; }
    }

    /// <summary>Field number for the "normalize_path" field.</summary>
    public const int NormalizePathFieldNumber = 30;
    private static readonly pb::FieldCodec<bool?> _single_normalizePath_codec = pb::FieldCodec.ForStructWrapper<bool>(242);
    private bool? normalizePath_;
    /// <summary>
    /// Should paths be normalized according to RFC 3986 before any processing of
    /// requests by HTTP filters or routing? This affects the upstream ``:path`` header
    /// as well. For paths that fail this check, Envoy will respond with 400 to
    /// paths that are malformed. This defaults to false currently but will default
    /// true in the future. When not specified, this value may be overridden by the
    /// runtime variable
    /// :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path>`.
    /// See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6>`_
    /// for details of normalization.
    /// Note that Envoy does not perform
    /// `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
    /// [#comment:TODO: This field is ignored when the
    /// :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    /// is present.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? NormalizePath {
      get { return normalizePath_; }
      set {
        normalizePath_ = value;
      }
    }


    /// <summary>Field number for the "merge_slashes" field.</summary>
    public const int MergeSlashesFieldNumber = 33;
    private bool mergeSlashes_;
    /// <summary>
    /// Determines if adjacent slashes in the path are merged into one before any processing of
    /// requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
    /// setting this option, incoming requests with path ``//dir///file`` will not match against route
    /// with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
    /// `HTTP spec &lt;https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
    /// [#comment:TODO: This field is ignored when the
    /// :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    /// is present.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool MergeSlashes {
      get { return mergeSlashes_; }
      set {
        mergeSlashes_ = value;
      }
    }

    /// <summary>Field number for the "path_with_escaped_slashes_action" field.</summary>
    public const int PathWithEscapedSlashesActionFieldNumber = 45;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction pathWithEscapedSlashesAction_ = global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault;
    /// <summary>
    /// Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
    /// The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action>`
    /// runtime variable.
    /// The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling&lt;config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
    /// variable can be used to apply the action to a portion of all requests.
    /// [#comment:TODO: This field is ignored when the
    /// :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    /// is present.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction PathWithEscapedSlashesAction {
      get { return pathWithEscapedSlashesAction_; }
      set {
        pathWithEscapedSlashesAction_ = value;
      }
    }

    /// <summary>Field number for the "request_id_extension" field.</summary>
    public const int RequestIdExtensionFieldNumber = 36;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension requestIdExtension_;
    /// <summary>
    /// The configuration of the request ID extension. This includes operations such as
    /// generation, validation, and associated tracing operations. If empty, the
    /// :ref:`UuidRequestIdConfig &lt;envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig>`
    /// default extension is used with default parameters. See the documentation for that extension
    /// for details on what it does. Customizing the configuration for the default extension can be
    /// achieved by configuring it explicitly here. For example, to disable trace reason packing,
    /// the following configuration can be used:
    ///
    /// .. validated-code-block:: yaml
    ///   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
    ///
    ///   typed_config:
    ///     "@type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
    ///     pack_trace_reason: false
    ///
    /// [#extension-category: envoy.request_id]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension RequestIdExtension {
      get { return requestIdExtension_; }
      set {
        requestIdExtension_ = value;
      }
    }

    /// <summary>Field number for the "local_reply_config" field.</summary>
    public const int LocalReplyConfigFieldNumber = 38;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig localReplyConfig_;
    /// <summary>
    /// The configuration to customize local reply returned by Envoy. It can customize status code,
    /// body text and response content type. If not specified, status code and text body are hard
    /// coded in Envoy, the response content type is plain text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig LocalReplyConfig {
      get { return localReplyConfig_; }
      set {
        localReplyConfig_ = value;
      }
    }

    /// <summary>Field number for the "strip_matching_host_port" field.</summary>
    public const int StripMatchingHostPortFieldNumber = 39;
    private bool stripMatchingHostPort_;
    /// <summary>
    /// Determines if the port part should be removed from host/authority header before any processing
    /// of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's&lt;envoy_v3_api_field_config.listener.v3.Listener.address>`
    /// local port. This affects the upstream host header unless the method is
    /// CONNECT in which case if no filter adds a port the original port will be restored before headers are
    /// sent upstream.
    /// Without setting this option, incoming requests with host ``example:443`` will not match against
    /// route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
    /// of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
    /// Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StripMatchingHostPort {
      get { return stripMatchingHostPort_; }
      set {
        stripMatchingHostPort_ = value;
      }
    }

    /// <summary>Field number for the "strip_any_host_port" field.</summary>
    public const int StripAnyHostPortFieldNumber = 42;
    /// <summary>
    /// Determines if the port part should be removed from host/authority header before any processing
    /// of request by HTTP filters or routing.
    /// This affects the upstream host header unless the method is CONNECT in
    /// which case if no filter adds a port the original port will be restored before headers are sent upstream.
    /// Without setting this option, incoming requests with host ``example:443`` will not match against
    /// route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
    /// of `HTTP spec &lt;https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
    /// Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StripAnyHostPort {
      get { return stripPortModeCase_ == StripPortModeOneofCase.StripAnyHostPort ? (bool) stripPortMode_ : false; }
      set {
        stripPortMode_ = value;
        stripPortModeCase_ = StripPortModeOneofCase.StripAnyHostPort;
      }
    }

    /// <summary>Field number for the "stream_error_on_invalid_http_message" field.</summary>
    public const int StreamErrorOnInvalidHttpMessageFieldNumber = 40;
    private static readonly pb::FieldCodec<bool?> _single_streamErrorOnInvalidHttpMessage_codec = pb::FieldCodec.ForStructWrapper<bool>(322);
    private bool? streamErrorOnInvalidHttpMessage_;
    /// <summary>
    /// Governs Envoy's behavior when receiving invalid HTTP from downstream.
    /// If this option is false (default), Envoy will err on the conservative side handling HTTP
    /// errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
    /// If this option is set to true, Envoy will be more permissive, only resetting the invalid
    /// stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
    /// request is read for HTTP/1.1)
    /// In general this should be true for deployments receiving trusted traffic (L2 Envoys,
    /// company-internal mesh) and false when receiving untrusted traffic (edge deployments).
    ///
    /// If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
    /// desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
    /// &lt;envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>` or the new HTTP/2 option
    /// :ref:`override_stream_error_on_invalid_http_message
    /// &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
    /// ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
    /// &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? StreamErrorOnInvalidHttpMessage {
      get { return streamErrorOnInvalidHttpMessage_; }
      set {
        streamErrorOnInvalidHttpMessage_ = value;
      }
    }


    /// <summary>Field number for the "path_normalization_options" field.</summary>
    public const int PathNormalizationOptionsFieldNumber = 43;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions pathNormalizationOptions_;
    /// <summary>
    /// [#not-implemented-hide:] Path normalization configuration. This includes
    /// configurations for transformations (e.g. RFC 3986 normalization or merge
    /// adjacent slashes) and the policy to apply them. The policy determines
    /// whether transformations affect the forwarded ``:path`` header. RFC 3986 path
    /// normalization is enabled by default and the default policy is that the
    /// normalized header will be forwarded. See :ref:`PathNormalizationOptions
    /// &lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions>`
    /// for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions PathNormalizationOptions {
      get { return pathNormalizationOptions_; }
      set {
        pathNormalizationOptions_ = value;
      }
    }

    /// <summary>Field number for the "strip_trailing_host_dot" field.</summary>
    public const int StripTrailingHostDotFieldNumber = 47;
    private bool stripTrailingHostDot_;
    /// <summary>
    /// Determines if trailing dot of the host should be removed from host/authority header before any
    /// processing of request by HTTP filters or routing.
    /// This affects the upstream host header.
    /// Without setting this option, incoming requests with host ``example.com.`` will not match against
    /// route with :ref:`domains&lt;envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example.com``. Defaults to ``false``.
    /// When the incoming request contains a host/authority header that includes a port number,
    /// setting this option will strip a trailing dot, if present, from the host section,
    /// leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StripTrailingHostDot {
      get { return stripTrailingHostDot_; }
      set {
        stripTrailingHostDot_ = value;
      }
    }

    /// <summary>Field number for the "proxy_status_config" field.</summary>
    public const int ProxyStatusConfigFieldNumber = 49;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig proxyStatusConfig_;
    /// <summary>
    /// Proxy-Status HTTP response header configuration.
    /// If this config is set, the Proxy-Status HTTP response header field is
    /// populated. By default, it is not.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig ProxyStatusConfig {
      get { return proxyStatusConfig_; }
      set {
        proxyStatusConfig_ = value;
      }
    }

    /// <summary>Field number for the "typed_header_validation_config" field.</summary>
    public const int TypedHeaderValidationConfigFieldNumber = 50;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig typedHeaderValidationConfig_;
    /// <summary>
    /// Configuration options for Header Validation (UHV).
    /// UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
    /// normalization for request attributes, such as URI path.
    /// If the typed_header_validation_config is present it overrides the following options:
    /// ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
    /// ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
    ///
    /// The default UHV checks the following:
    ///
    /// #. HTTP/1 header map validity according to `RFC 7230 section 3.2&lt;https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
    /// #. Syntax of HTTP/1 request target URI and response status
    /// #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2&lt;https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
    /// #. Syntax of HTTP/2 pseudo headers
    /// #. HTTP/3 header map validity according to `RFC 9114 section 4.3 &lt;https://www.rfc-editor.org/rfc/rfc9114.html>`_
    /// #. Syntax of HTTP/3 pseudo headers
    /// #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
    /// #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
    /// #. Normalization of the URI path according to `Normalization and Comparison &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
    ///    without `case normalization &lt;https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
    ///
    /// [#not-implemented-hide:]
    /// [#extension-category: envoy.http.header_validators]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig TypedHeaderValidationConfig {
      get { return typedHeaderValidationConfig_; }
      set {
        typedHeaderValidationConfig_ = value;
      }
    }

    /// <summary>Field number for the "append_x_forwarded_port" field.</summary>
    public const int AppendXForwardedPortFieldNumber = 51;
    private bool appendXForwardedPort_;
    /// <summary>
    /// Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
    /// will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AppendXForwardedPort {
      get { return appendXForwardedPort_; }
      set {
        appendXForwardedPort_ = value;
      }
    }

    /// <summary>Field number for the "add_proxy_protocol_connection_state" field.</summary>
    public const int AddProxyProtocolConnectionStateFieldNumber = 53;
    private static readonly pb::FieldCodec<bool?> _single_addProxyProtocolConnectionState_codec = pb::FieldCodec.ForStructWrapper<bool>(426);
    private bool? addProxyProtocolConnectionState_;
    /// <summary>
    /// Whether the HCM will add ProxyProtocolFilterState to the Connection lifetime filter state. Defaults to `true`.
    /// This should be set to `false` in cases where Envoy's view of the downstream address may not correspond to the
    /// actual client address, for example, if there's another proxy in front of the Envoy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AddProxyProtocolConnectionState {
      get { return addProxyProtocolConnectionState_; }
      set {
        addProxyProtocolConnectionState_ = value;
      }
    }


    private object routeSpecifier_;
    /// <summary>Enum of possible cases for the "route_specifier" oneof.</summary>
    public enum RouteSpecifierOneofCase {
      None = 0,
      Rds = 3,
      RouteConfig = 4,
      ScopedRoutes = 31,
    }
    private RouteSpecifierOneofCase routeSpecifierCase_ = RouteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteSpecifierOneofCase RouteSpecifierCase {
      get { return routeSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRouteSpecifier() {
      routeSpecifierCase_ = RouteSpecifierOneofCase.None;
      routeSpecifier_ = null;
    }

    private object stripPortMode_;
    /// <summary>Enum of possible cases for the "strip_port_mode" oneof.</summary>
    public enum StripPortModeOneofCase {
      None = 0,
      StripAnyHostPort = 42,
    }
    private StripPortModeOneofCase stripPortModeCase_ = StripPortModeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StripPortModeOneofCase StripPortModeCase {
      get { return stripPortModeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStripPortMode() {
      stripPortModeCase_ = StripPortModeOneofCase.None;
      stripPortMode_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HttpConnectionManager);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HttpConnectionManager other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CodecType != other.CodecType) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if (!object.Equals(Rds, other.Rds)) return false;
      if (!object.Equals(RouteConfig, other.RouteConfig)) return false;
      if (!object.Equals(ScopedRoutes, other.ScopedRoutes)) return false;
      if(!httpFilters_.Equals(other.httpFilters_)) return false;
      if (AddUserAgent != other.AddUserAgent) return false;
      if (!object.Equals(Tracing, other.Tracing)) return false;
      if (!object.Equals(CommonHttpProtocolOptions, other.CommonHttpProtocolOptions)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!object.Equals(Http3ProtocolOptions, other.Http3ProtocolOptions)) return false;
      if (ServerName != other.ServerName) return false;
      if (ServerHeaderTransformation != other.ServerHeaderTransformation) return false;
      if (!object.Equals(SchemeHeaderTransformation, other.SchemeHeaderTransformation)) return false;
      if (MaxRequestHeadersKb != other.MaxRequestHeadersKb) return false;
      if (!object.Equals(StreamIdleTimeout, other.StreamIdleTimeout)) return false;
      if (!object.Equals(RequestTimeout, other.RequestTimeout)) return false;
      if (!object.Equals(RequestHeadersTimeout, other.RequestHeadersTimeout)) return false;
      if (!object.Equals(DrainTimeout, other.DrainTimeout)) return false;
      if (!object.Equals(DelayedCloseTimeout, other.DelayedCloseTimeout)) return false;
      if(!accessLog_.Equals(other.accessLog_)) return false;
      if (!object.Equals(AccessLogFlushInterval, other.AccessLogFlushInterval)) return false;
      if (FlushAccessLogOnNewRequest != other.FlushAccessLogOnNewRequest) return false;
      if (UseRemoteAddress != other.UseRemoteAddress) return false;
      if (XffNumTrustedHops != other.XffNumTrustedHops) return false;
      if(!originalIpDetectionExtensions_.Equals(other.originalIpDetectionExtensions_)) return false;
      if(!earlyHeaderMutationExtensions_.Equals(other.earlyHeaderMutationExtensions_)) return false;
      if (!object.Equals(InternalAddressConfig, other.InternalAddressConfig)) return false;
      if (SkipXffAppend != other.SkipXffAppend) return false;
      if (Via != other.Via) return false;
      if (GenerateRequestId != other.GenerateRequestId) return false;
      if (PreserveExternalRequestId != other.PreserveExternalRequestId) return false;
      if (AlwaysSetRequestIdInResponse != other.AlwaysSetRequestIdInResponse) return false;
      if (ForwardClientCertDetails != other.ForwardClientCertDetails) return false;
      if (!object.Equals(SetCurrentClientCertDetails, other.SetCurrentClientCertDetails)) return false;
      if (Proxy100Continue != other.Proxy100Continue) return false;
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6) return false;
      if(!upgradeConfigs_.Equals(other.upgradeConfigs_)) return false;
      if (NormalizePath != other.NormalizePath) return false;
      if (MergeSlashes != other.MergeSlashes) return false;
      if (PathWithEscapedSlashesAction != other.PathWithEscapedSlashesAction) return false;
      if (!object.Equals(RequestIdExtension, other.RequestIdExtension)) return false;
      if (!object.Equals(LocalReplyConfig, other.LocalReplyConfig)) return false;
      if (StripMatchingHostPort != other.StripMatchingHostPort) return false;
      if (StripAnyHostPort != other.StripAnyHostPort) return false;
      if (StreamErrorOnInvalidHttpMessage != other.StreamErrorOnInvalidHttpMessage) return false;
      if (!object.Equals(PathNormalizationOptions, other.PathNormalizationOptions)) return false;
      if (StripTrailingHostDot != other.StripTrailingHostDot) return false;
      if (!object.Equals(ProxyStatusConfig, other.ProxyStatusConfig)) return false;
      if (!object.Equals(TypedHeaderValidationConfig, other.TypedHeaderValidationConfig)) return false;
      if (AppendXForwardedPort != other.AppendXForwardedPort) return false;
      if (AddProxyProtocolConnectionState != other.AddProxyProtocolConnectionState) return false;
      if (RouteSpecifierCase != other.RouteSpecifierCase) return false;
      if (StripPortModeCase != other.StripPortModeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (CodecType != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto) hash ^= CodecType.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) hash ^= Rds.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) hash ^= RouteConfig.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) hash ^= ScopedRoutes.GetHashCode();
      hash ^= httpFilters_.GetHashCode();
      if (addUserAgent_ != null) hash ^= AddUserAgent.GetHashCode();
      if (tracing_ != null) hash ^= Tracing.GetHashCode();
      if (commonHttpProtocolOptions_ != null) hash ^= CommonHttpProtocolOptions.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (http3ProtocolOptions_ != null) hash ^= Http3ProtocolOptions.GetHashCode();
      if (ServerName.Length != 0) hash ^= ServerName.GetHashCode();
      if (ServerHeaderTransformation != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) hash ^= ServerHeaderTransformation.GetHashCode();
      if (schemeHeaderTransformation_ != null) hash ^= SchemeHeaderTransformation.GetHashCode();
      if (maxRequestHeadersKb_ != null) hash ^= MaxRequestHeadersKb.GetHashCode();
      if (streamIdleTimeout_ != null) hash ^= StreamIdleTimeout.GetHashCode();
      if (requestTimeout_ != null) hash ^= RequestTimeout.GetHashCode();
      if (requestHeadersTimeout_ != null) hash ^= RequestHeadersTimeout.GetHashCode();
      if (drainTimeout_ != null) hash ^= DrainTimeout.GetHashCode();
      if (delayedCloseTimeout_ != null) hash ^= DelayedCloseTimeout.GetHashCode();
      hash ^= accessLog_.GetHashCode();
      if (accessLogFlushInterval_ != null) hash ^= AccessLogFlushInterval.GetHashCode();
      if (FlushAccessLogOnNewRequest != false) hash ^= FlushAccessLogOnNewRequest.GetHashCode();
      if (useRemoteAddress_ != null) hash ^= UseRemoteAddress.GetHashCode();
      if (XffNumTrustedHops != 0) hash ^= XffNumTrustedHops.GetHashCode();
      hash ^= originalIpDetectionExtensions_.GetHashCode();
      hash ^= earlyHeaderMutationExtensions_.GetHashCode();
      if (internalAddressConfig_ != null) hash ^= InternalAddressConfig.GetHashCode();
      if (SkipXffAppend != false) hash ^= SkipXffAppend.GetHashCode();
      if (Via.Length != 0) hash ^= Via.GetHashCode();
      if (generateRequestId_ != null) hash ^= GenerateRequestId.GetHashCode();
      if (PreserveExternalRequestId != false) hash ^= PreserveExternalRequestId.GetHashCode();
      if (AlwaysSetRequestIdInResponse != false) hash ^= AlwaysSetRequestIdInResponse.GetHashCode();
      if (ForwardClientCertDetails != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) hash ^= ForwardClientCertDetails.GetHashCode();
      if (setCurrentClientCertDetails_ != null) hash ^= SetCurrentClientCertDetails.GetHashCode();
      if (Proxy100Continue != false) hash ^= Proxy100Continue.GetHashCode();
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) hash ^= RepresentIpv4RemoteAddressAsIpv4MappedIpv6.GetHashCode();
      hash ^= upgradeConfigs_.GetHashCode();
      if (normalizePath_ != null) hash ^= NormalizePath.GetHashCode();
      if (MergeSlashes != false) hash ^= MergeSlashes.GetHashCode();
      if (PathWithEscapedSlashesAction != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault) hash ^= PathWithEscapedSlashesAction.GetHashCode();
      if (requestIdExtension_ != null) hash ^= RequestIdExtension.GetHashCode();
      if (localReplyConfig_ != null) hash ^= LocalReplyConfig.GetHashCode();
      if (StripMatchingHostPort != false) hash ^= StripMatchingHostPort.GetHashCode();
      if (stripPortModeCase_ == StripPortModeOneofCase.StripAnyHostPort) hash ^= StripAnyHostPort.GetHashCode();
      if (streamErrorOnInvalidHttpMessage_ != null) hash ^= StreamErrorOnInvalidHttpMessage.GetHashCode();
      if (pathNormalizationOptions_ != null) hash ^= PathNormalizationOptions.GetHashCode();
      if (StripTrailingHostDot != false) hash ^= StripTrailingHostDot.GetHashCode();
      if (proxyStatusConfig_ != null) hash ^= ProxyStatusConfig.GetHashCode();
      if (typedHeaderValidationConfig_ != null) hash ^= TypedHeaderValidationConfig.GetHashCode();
      if (AppendXForwardedPort != false) hash ^= AppendXForwardedPort.GetHashCode();
      if (addProxyProtocolConnectionState_ != null) hash ^= AddProxyProtocolConnectionState.GetHashCode();
      hash ^= (int) routeSpecifierCase_;
      hash ^= (int) stripPortModeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CodecType != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        output.WriteRawTag(26);
        output.WriteMessage(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(RouteConfig);
      }
      httpFilters_.WriteTo(output, _repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        _single_addUserAgent_codec.WriteTagAndValue(output, AddUserAgent);
      }
      if (tracing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ServerName);
      }
      if (drainTimeout_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(DrainTimeout);
      }
      accessLog_.WriteTo(output, _repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        _single_useRemoteAddress_codec.WriteTagAndValue(output, UseRemoteAddress);
      }
      if (generateRequestId_ != null) {
        _single_generateRequestId_codec.WriteTagAndValue(output, GenerateRequestId);
      }
      if (ForwardClientCertDetails != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Proxy100Continue);
      }
      if (XffNumTrustedHops != 0) {
        output.WriteRawTag(152, 1);
        output.WriteUInt32(XffNumTrustedHops);
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(RepresentIpv4RemoteAddressAsIpv4MappedIpv6);
      }
      if (SkipXffAppend != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(SkipXffAppend);
      }
      if (Via.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(Via);
      }
      upgradeConfigs_.WriteTo(output, _repeated_upgradeConfigs_codec);
      if (streamIdleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(StreamIdleTimeout);
      }
      if (internalAddressConfig_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(InternalAddressConfig);
      }
      if (delayedCloseTimeout_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(DelayedCloseTimeout);
      }
      if (requestTimeout_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(RequestTimeout);
      }
      if (maxRequestHeadersKb_ != null) {
        _single_maxRequestHeadersKb_codec.WriteTagAndValue(output, MaxRequestHeadersKb);
      }
      if (normalizePath_ != null) {
        _single_normalizePath_codec.WriteTagAndValue(output, NormalizePath);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(ScopedRoutes);
      }
      if (PreserveExternalRequestId != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(PreserveExternalRequestId);
      }
      if (MergeSlashes != false) {
        output.WriteRawTag(136, 2);
        output.WriteBool(MergeSlashes);
      }
      if (ServerHeaderTransformation != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        output.WriteRawTag(144, 2);
        output.WriteEnum((int) ServerHeaderTransformation);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(154, 2);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (requestIdExtension_ != null) {
        output.WriteRawTag(162, 2);
        output.WriteMessage(RequestIdExtension);
      }
      if (AlwaysSetRequestIdInResponse != false) {
        output.WriteRawTag(168, 2);
        output.WriteBool(AlwaysSetRequestIdInResponse);
      }
      if (localReplyConfig_ != null) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(LocalReplyConfig);
      }
      if (StripMatchingHostPort != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(StripMatchingHostPort);
      }
      if (streamErrorOnInvalidHttpMessage_ != null) {
        _single_streamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(output, StreamErrorOnInvalidHttpMessage);
      }
      if (requestHeadersTimeout_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(RequestHeadersTimeout);
      }
      if (stripPortModeCase_ == StripPortModeOneofCase.StripAnyHostPort) {
        output.WriteRawTag(208, 2);
        output.WriteBool(StripAnyHostPort);
      }
      if (pathNormalizationOptions_ != null) {
        output.WriteRawTag(218, 2);
        output.WriteMessage(PathNormalizationOptions);
      }
      if (http3ProtocolOptions_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(Http3ProtocolOptions);
      }
      if (PathWithEscapedSlashesAction != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault) {
        output.WriteRawTag(232, 2);
        output.WriteEnum((int) PathWithEscapedSlashesAction);
      }
      originalIpDetectionExtensions_.WriteTo(output, _repeated_originalIpDetectionExtensions_codec);
      if (StripTrailingHostDot != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(StripTrailingHostDot);
      }
      if (schemeHeaderTransformation_ != null) {
        output.WriteRawTag(130, 3);
        output.WriteMessage(SchemeHeaderTransformation);
      }
      if (proxyStatusConfig_ != null) {
        output.WriteRawTag(138, 3);
        output.WriteMessage(ProxyStatusConfig);
      }
      if (typedHeaderValidationConfig_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(TypedHeaderValidationConfig);
      }
      if (AppendXForwardedPort != false) {
        output.WriteRawTag(152, 3);
        output.WriteBool(AppendXForwardedPort);
      }
      earlyHeaderMutationExtensions_.WriteTo(output, _repeated_earlyHeaderMutationExtensions_codec);
      if (addProxyProtocolConnectionState_ != null) {
        _single_addProxyProtocolConnectionState_codec.WriteTagAndValue(output, AddProxyProtocolConnectionState);
      }
      if (accessLogFlushInterval_ != null) {
        output.WriteRawTag(178, 3);
        output.WriteMessage(AccessLogFlushInterval);
      }
      if (FlushAccessLogOnNewRequest != false) {
        output.WriteRawTag(184, 3);
        output.WriteBool(FlushAccessLogOnNewRequest);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CodecType != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        output.WriteRawTag(26);
        output.WriteMessage(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(RouteConfig);
      }
      httpFilters_.WriteTo(ref output, _repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        _single_addUserAgent_codec.WriteTagAndValue(ref output, AddUserAgent);
      }
      if (tracing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ServerName);
      }
      if (drainTimeout_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(DrainTimeout);
      }
      accessLog_.WriteTo(ref output, _repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        _single_useRemoteAddress_codec.WriteTagAndValue(ref output, UseRemoteAddress);
      }
      if (generateRequestId_ != null) {
        _single_generateRequestId_codec.WriteTagAndValue(ref output, GenerateRequestId);
      }
      if (ForwardClientCertDetails != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Proxy100Continue);
      }
      if (XffNumTrustedHops != 0) {
        output.WriteRawTag(152, 1);
        output.WriteUInt32(XffNumTrustedHops);
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(RepresentIpv4RemoteAddressAsIpv4MappedIpv6);
      }
      if (SkipXffAppend != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(SkipXffAppend);
      }
      if (Via.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(Via);
      }
      upgradeConfigs_.WriteTo(ref output, _repeated_upgradeConfigs_codec);
      if (streamIdleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(StreamIdleTimeout);
      }
      if (internalAddressConfig_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(InternalAddressConfig);
      }
      if (delayedCloseTimeout_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(DelayedCloseTimeout);
      }
      if (requestTimeout_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(RequestTimeout);
      }
      if (maxRequestHeadersKb_ != null) {
        _single_maxRequestHeadersKb_codec.WriteTagAndValue(ref output, MaxRequestHeadersKb);
      }
      if (normalizePath_ != null) {
        _single_normalizePath_codec.WriteTagAndValue(ref output, NormalizePath);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(ScopedRoutes);
      }
      if (PreserveExternalRequestId != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(PreserveExternalRequestId);
      }
      if (MergeSlashes != false) {
        output.WriteRawTag(136, 2);
        output.WriteBool(MergeSlashes);
      }
      if (ServerHeaderTransformation != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        output.WriteRawTag(144, 2);
        output.WriteEnum((int) ServerHeaderTransformation);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(154, 2);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (requestIdExtension_ != null) {
        output.WriteRawTag(162, 2);
        output.WriteMessage(RequestIdExtension);
      }
      if (AlwaysSetRequestIdInResponse != false) {
        output.WriteRawTag(168, 2);
        output.WriteBool(AlwaysSetRequestIdInResponse);
      }
      if (localReplyConfig_ != null) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(LocalReplyConfig);
      }
      if (StripMatchingHostPort != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(StripMatchingHostPort);
      }
      if (streamErrorOnInvalidHttpMessage_ != null) {
        _single_streamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(ref output, StreamErrorOnInvalidHttpMessage);
      }
      if (requestHeadersTimeout_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(RequestHeadersTimeout);
      }
      if (stripPortModeCase_ == StripPortModeOneofCase.StripAnyHostPort) {
        output.WriteRawTag(208, 2);
        output.WriteBool(StripAnyHostPort);
      }
      if (pathNormalizationOptions_ != null) {
        output.WriteRawTag(218, 2);
        output.WriteMessage(PathNormalizationOptions);
      }
      if (http3ProtocolOptions_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(Http3ProtocolOptions);
      }
      if (PathWithEscapedSlashesAction != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault) {
        output.WriteRawTag(232, 2);
        output.WriteEnum((int) PathWithEscapedSlashesAction);
      }
      originalIpDetectionExtensions_.WriteTo(ref output, _repeated_originalIpDetectionExtensions_codec);
      if (StripTrailingHostDot != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(StripTrailingHostDot);
      }
      if (schemeHeaderTransformation_ != null) {
        output.WriteRawTag(130, 3);
        output.WriteMessage(SchemeHeaderTransformation);
      }
      if (proxyStatusConfig_ != null) {
        output.WriteRawTag(138, 3);
        output.WriteMessage(ProxyStatusConfig);
      }
      if (typedHeaderValidationConfig_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(TypedHeaderValidationConfig);
      }
      if (AppendXForwardedPort != false) {
        output.WriteRawTag(152, 3);
        output.WriteBool(AppendXForwardedPort);
      }
      earlyHeaderMutationExtensions_.WriteTo(ref output, _repeated_earlyHeaderMutationExtensions_codec);
      if (addProxyProtocolConnectionState_ != null) {
        _single_addProxyProtocolConnectionState_codec.WriteTagAndValue(ref output, AddProxyProtocolConnectionState);
      }
      if (accessLogFlushInterval_ != null) {
        output.WriteRawTag(178, 3);
        output.WriteMessage(AccessLogFlushInterval);
      }
      if (FlushAccessLogOnNewRequest != false) {
        output.WriteRawTag(184, 3);
        output.WriteBool(FlushAccessLogOnNewRequest);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (CodecType != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteConfig);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScopedRoutes);
      }
      size += httpFilters_.CalculateSize(_repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        size += _single_addUserAgent_codec.CalculateSizeWithTag(AddUserAgent);
      }
      if (tracing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tracing);
      }
      if (commonHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonHttpProtocolOptions);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (http3ProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Http3ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServerName);
      }
      if (ServerHeaderTransformation != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ServerHeaderTransformation);
      }
      if (schemeHeaderTransformation_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SchemeHeaderTransformation);
      }
      if (maxRequestHeadersKb_ != null) {
        size += _single_maxRequestHeadersKb_codec.CalculateSizeWithTag(MaxRequestHeadersKb);
      }
      if (streamIdleTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StreamIdleTimeout);
      }
      if (requestTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RequestTimeout);
      }
      if (requestHeadersTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RequestHeadersTimeout);
      }
      if (drainTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DrainTimeout);
      }
      if (delayedCloseTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DelayedCloseTimeout);
      }
      size += accessLog_.CalculateSize(_repeated_accessLog_codec);
      if (accessLogFlushInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AccessLogFlushInterval);
      }
      if (FlushAccessLogOnNewRequest != false) {
        size += 2 + 1;
      }
      if (useRemoteAddress_ != null) {
        size += _single_useRemoteAddress_codec.CalculateSizeWithTag(UseRemoteAddress);
      }
      if (XffNumTrustedHops != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(XffNumTrustedHops);
      }
      size += originalIpDetectionExtensions_.CalculateSize(_repeated_originalIpDetectionExtensions_codec);
      size += earlyHeaderMutationExtensions_.CalculateSize(_repeated_earlyHeaderMutationExtensions_codec);
      if (internalAddressConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InternalAddressConfig);
      }
      if (SkipXffAppend != false) {
        size += 2 + 1;
      }
      if (Via.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Via);
      }
      if (generateRequestId_ != null) {
        size += _single_generateRequestId_codec.CalculateSizeWithTag(GenerateRequestId);
      }
      if (PreserveExternalRequestId != false) {
        size += 2 + 1;
      }
      if (AlwaysSetRequestIdInResponse != false) {
        size += 2 + 1;
      }
      if (ForwardClientCertDetails != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        size += 2 + 1;
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        size += 2 + 1;
      }
      size += upgradeConfigs_.CalculateSize(_repeated_upgradeConfigs_codec);
      if (normalizePath_ != null) {
        size += _single_normalizePath_codec.CalculateSizeWithTag(NormalizePath);
      }
      if (MergeSlashes != false) {
        size += 2 + 1;
      }
      if (PathWithEscapedSlashesAction != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PathWithEscapedSlashesAction);
      }
      if (requestIdExtension_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RequestIdExtension);
      }
      if (localReplyConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LocalReplyConfig);
      }
      if (StripMatchingHostPort != false) {
        size += 2 + 1;
      }
      if (stripPortModeCase_ == StripPortModeOneofCase.StripAnyHostPort) {
        size += 2 + 1;
      }
      if (streamErrorOnInvalidHttpMessage_ != null) {
        size += _single_streamErrorOnInvalidHttpMessage_codec.CalculateSizeWithTag(StreamErrorOnInvalidHttpMessage);
      }
      if (pathNormalizationOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PathNormalizationOptions);
      }
      if (StripTrailingHostDot != false) {
        size += 2 + 1;
      }
      if (proxyStatusConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ProxyStatusConfig);
      }
      if (typedHeaderValidationConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TypedHeaderValidationConfig);
      }
      if (AppendXForwardedPort != false) {
        size += 2 + 1;
      }
      if (addProxyProtocolConnectionState_ != null) {
        size += _single_addProxyProtocolConnectionState_codec.CalculateSizeWithTag(AddProxyProtocolConnectionState);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HttpConnectionManager other) {
      if (other == null) {
        return;
      }
      if (other.CodecType != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType.Auto) {
        CodecType = other.CodecType;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      httpFilters_.Add(other.httpFilters_);
      if (other.addUserAgent_ != null) {
        if (addUserAgent_ == null || other.AddUserAgent != false) {
          AddUserAgent = other.AddUserAgent;
        }
      }
      if (other.tracing_ != null) {
        if (tracing_ == null) {
          Tracing = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing();
        }
        Tracing.MergeFrom(other.Tracing);
      }
      if (other.commonHttpProtocolOptions_ != null) {
        if (commonHttpProtocolOptions_ == null) {
          CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
        }
        CommonHttpProtocolOptions.MergeFrom(other.CommonHttpProtocolOptions);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      if (other.http3ProtocolOptions_ != null) {
        if (http3ProtocolOptions_ == null) {
          Http3ProtocolOptions = new global::Envoy.Config.Core.V3.Http3ProtocolOptions();
        }
        Http3ProtocolOptions.MergeFrom(other.Http3ProtocolOptions);
      }
      if (other.ServerName.Length != 0) {
        ServerName = other.ServerName;
      }
      if (other.ServerHeaderTransformation != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        ServerHeaderTransformation = other.ServerHeaderTransformation;
      }
      if (other.schemeHeaderTransformation_ != null) {
        if (schemeHeaderTransformation_ == null) {
          SchemeHeaderTransformation = new global::Envoy.Config.Core.V3.SchemeHeaderTransformation();
        }
        SchemeHeaderTransformation.MergeFrom(other.SchemeHeaderTransformation);
      }
      if (other.maxRequestHeadersKb_ != null) {
        if (maxRequestHeadersKb_ == null || other.MaxRequestHeadersKb != 0) {
          MaxRequestHeadersKb = other.MaxRequestHeadersKb;
        }
      }
      if (other.streamIdleTimeout_ != null) {
        if (streamIdleTimeout_ == null) {
          StreamIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        StreamIdleTimeout.MergeFrom(other.StreamIdleTimeout);
      }
      if (other.requestTimeout_ != null) {
        if (requestTimeout_ == null) {
          RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestTimeout.MergeFrom(other.RequestTimeout);
      }
      if (other.requestHeadersTimeout_ != null) {
        if (requestHeadersTimeout_ == null) {
          RequestHeadersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestHeadersTimeout.MergeFrom(other.RequestHeadersTimeout);
      }
      if (other.drainTimeout_ != null) {
        if (drainTimeout_ == null) {
          DrainTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DrainTimeout.MergeFrom(other.DrainTimeout);
      }
      if (other.delayedCloseTimeout_ != null) {
        if (delayedCloseTimeout_ == null) {
          DelayedCloseTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DelayedCloseTimeout.MergeFrom(other.DelayedCloseTimeout);
      }
      accessLog_.Add(other.accessLog_);
      if (other.accessLogFlushInterval_ != null) {
        if (accessLogFlushInterval_ == null) {
          AccessLogFlushInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        AccessLogFlushInterval.MergeFrom(other.AccessLogFlushInterval);
      }
      if (other.FlushAccessLogOnNewRequest != false) {
        FlushAccessLogOnNewRequest = other.FlushAccessLogOnNewRequest;
      }
      if (other.useRemoteAddress_ != null) {
        if (useRemoteAddress_ == null || other.UseRemoteAddress != false) {
          UseRemoteAddress = other.UseRemoteAddress;
        }
      }
      if (other.XffNumTrustedHops != 0) {
        XffNumTrustedHops = other.XffNumTrustedHops;
      }
      originalIpDetectionExtensions_.Add(other.originalIpDetectionExtensions_);
      earlyHeaderMutationExtensions_.Add(other.earlyHeaderMutationExtensions_);
      if (other.internalAddressConfig_ != null) {
        if (internalAddressConfig_ == null) {
          InternalAddressConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig();
        }
        InternalAddressConfig.MergeFrom(other.InternalAddressConfig);
      }
      if (other.SkipXffAppend != false) {
        SkipXffAppend = other.SkipXffAppend;
      }
      if (other.Via.Length != 0) {
        Via = other.Via;
      }
      if (other.generateRequestId_ != null) {
        if (generateRequestId_ == null || other.GenerateRequestId != false) {
          GenerateRequestId = other.GenerateRequestId;
        }
      }
      if (other.PreserveExternalRequestId != false) {
        PreserveExternalRequestId = other.PreserveExternalRequestId;
      }
      if (other.AlwaysSetRequestIdInResponse != false) {
        AlwaysSetRequestIdInResponse = other.AlwaysSetRequestIdInResponse;
      }
      if (other.ForwardClientCertDetails != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        ForwardClientCertDetails = other.ForwardClientCertDetails;
      }
      if (other.setCurrentClientCertDetails_ != null) {
        if (setCurrentClientCertDetails_ == null) {
          SetCurrentClientCertDetails = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails();
        }
        SetCurrentClientCertDetails.MergeFrom(other.SetCurrentClientCertDetails);
      }
      if (other.Proxy100Continue != false) {
        Proxy100Continue = other.Proxy100Continue;
      }
      if (other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6;
      }
      upgradeConfigs_.Add(other.upgradeConfigs_);
      if (other.normalizePath_ != null) {
        if (normalizePath_ == null || other.NormalizePath != false) {
          NormalizePath = other.NormalizePath;
        }
      }
      if (other.MergeSlashes != false) {
        MergeSlashes = other.MergeSlashes;
      }
      if (other.PathWithEscapedSlashesAction != global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction.ImplementationSpecificDefault) {
        PathWithEscapedSlashesAction = other.PathWithEscapedSlashesAction;
      }
      if (other.requestIdExtension_ != null) {
        if (requestIdExtension_ == null) {
          RequestIdExtension = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension();
        }
        RequestIdExtension.MergeFrom(other.RequestIdExtension);
      }
      if (other.localReplyConfig_ != null) {
        if (localReplyConfig_ == null) {
          LocalReplyConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig();
        }
        LocalReplyConfig.MergeFrom(other.LocalReplyConfig);
      }
      if (other.StripMatchingHostPort != false) {
        StripMatchingHostPort = other.StripMatchingHostPort;
      }
      if (other.streamErrorOnInvalidHttpMessage_ != null) {
        if (streamErrorOnInvalidHttpMessage_ == null || other.StreamErrorOnInvalidHttpMessage != false) {
          StreamErrorOnInvalidHttpMessage = other.StreamErrorOnInvalidHttpMessage;
        }
      }
      if (other.pathNormalizationOptions_ != null) {
        if (pathNormalizationOptions_ == null) {
          PathNormalizationOptions = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions();
        }
        PathNormalizationOptions.MergeFrom(other.PathNormalizationOptions);
      }
      if (other.StripTrailingHostDot != false) {
        StripTrailingHostDot = other.StripTrailingHostDot;
      }
      if (other.proxyStatusConfig_ != null) {
        if (proxyStatusConfig_ == null) {
          ProxyStatusConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig();
        }
        ProxyStatusConfig.MergeFrom(other.ProxyStatusConfig);
      }
      if (other.typedHeaderValidationConfig_ != null) {
        if (typedHeaderValidationConfig_ == null) {
          TypedHeaderValidationConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        TypedHeaderValidationConfig.MergeFrom(other.TypedHeaderValidationConfig);
      }
      if (other.AppendXForwardedPort != false) {
        AppendXForwardedPort = other.AppendXForwardedPort;
      }
      if (other.addProxyProtocolConnectionState_ != null) {
        if (addProxyProtocolConnectionState_ == null || other.AddProxyProtocolConnectionState != false) {
          AddProxyProtocolConnectionState = other.AddProxyProtocolConnectionState;
        }
      }
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          if (Rds == null) {
            Rds = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds();
          }
          Rds.MergeFrom(other.Rds);
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          if (RouteConfig == null) {
            RouteConfig = new global::Envoy.Config.Route.V3.RouteConfiguration();
          }
          RouteConfig.MergeFrom(other.RouteConfig);
          break;
        case RouteSpecifierOneofCase.ScopedRoutes:
          if (ScopedRoutes == null) {
            ScopedRoutes = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes();
          }
          ScopedRoutes.MergeFrom(other.ScopedRoutes);
          break;
      }

      switch (other.StripPortModeCase) {
        case StripPortModeOneofCase.StripAnyHostPort:
          StripAnyHostPort = other.StripAnyHostPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CodecType = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType) input.ReadEnum();
            break;
          }
          case 18: {
            StatPrefix = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
              subBuilder.MergeFrom(Rds);
            }
            input.ReadMessage(subBuilder);
            Rds = subBuilder;
            break;
          }
          case 34: {
            global::Envoy.Config.Route.V3.RouteConfiguration subBuilder = new global::Envoy.Config.Route.V3.RouteConfiguration();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
              subBuilder.MergeFrom(RouteConfig);
            }
            input.ReadMessage(subBuilder);
            RouteConfig = subBuilder;
            break;
          }
          case 42: {
            httpFilters_.AddEntriesFrom(input, _repeated_httpFilters_codec);
            break;
          }
          case 50: {
            bool? value = _single_addUserAgent_codec.Read(input);
            if (addUserAgent_ == null || value != false) {
              AddUserAgent = value;
            }
            break;
          }
          case 58: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
          case 66: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 74: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 82: {
            ServerName = input.ReadString();
            break;
          }
          case 98: {
            if (drainTimeout_ == null) {
              DrainTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DrainTimeout);
            break;
          }
          case 106: {
            accessLog_.AddEntriesFrom(input, _repeated_accessLog_codec);
            break;
          }
          case 114: {
            bool? value = _single_useRemoteAddress_codec.Read(input);
            if (useRemoteAddress_ == null || value != false) {
              UseRemoteAddress = value;
            }
            break;
          }
          case 122: {
            bool? value = _single_generateRequestId_codec.Read(input);
            if (generateRequestId_ == null || value != false) {
              GenerateRequestId = value;
            }
            break;
          }
          case 128: {
            ForwardClientCertDetails = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails) input.ReadEnum();
            break;
          }
          case 138: {
            if (setCurrentClientCertDetails_ == null) {
              SetCurrentClientCertDetails = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails();
            }
            input.ReadMessage(SetCurrentClientCertDetails);
            break;
          }
          case 144: {
            Proxy100Continue = input.ReadBool();
            break;
          }
          case 152: {
            XffNumTrustedHops = input.ReadUInt32();
            break;
          }
          case 160: {
            RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = input.ReadBool();
            break;
          }
          case 168: {
            SkipXffAppend = input.ReadBool();
            break;
          }
          case 178: {
            Via = input.ReadString();
            break;
          }
          case 186: {
            upgradeConfigs_.AddEntriesFrom(input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 194: {
            if (streamIdleTimeout_ == null) {
              StreamIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(StreamIdleTimeout);
            break;
          }
          case 202: {
            if (internalAddressConfig_ == null) {
              InternalAddressConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig();
            }
            input.ReadMessage(InternalAddressConfig);
            break;
          }
          case 210: {
            if (delayedCloseTimeout_ == null) {
              DelayedCloseTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DelayedCloseTimeout);
            break;
          }
          case 226: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 234: {
            uint? value = _single_maxRequestHeadersKb_codec.Read(input);
            if (maxRequestHeadersKb_ == null || value != 0) {
              MaxRequestHeadersKb = value;
            }
            break;
          }
          case 242: {
            bool? value = _single_normalizePath_codec.Read(input);
            if (normalizePath_ == null || value != false) {
              NormalizePath = value;
            }
            break;
          }
          case 250: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
              subBuilder.MergeFrom(ScopedRoutes);
            }
            input.ReadMessage(subBuilder);
            ScopedRoutes = subBuilder;
            break;
          }
          case 256: {
            PreserveExternalRequestId = input.ReadBool();
            break;
          }
          case 264: {
            MergeSlashes = input.ReadBool();
            break;
          }
          case 272: {
            ServerHeaderTransformation = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation) input.ReadEnum();
            break;
          }
          case 282: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 290: {
            if (requestIdExtension_ == null) {
              RequestIdExtension = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension();
            }
            input.ReadMessage(RequestIdExtension);
            break;
          }
          case 296: {
            AlwaysSetRequestIdInResponse = input.ReadBool();
            break;
          }
          case 306: {
            if (localReplyConfig_ == null) {
              LocalReplyConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig();
            }
            input.ReadMessage(LocalReplyConfig);
            break;
          }
          case 312: {
            StripMatchingHostPort = input.ReadBool();
            break;
          }
          case 322: {
            bool? value = _single_streamErrorOnInvalidHttpMessage_codec.Read(input);
            if (streamErrorOnInvalidHttpMessage_ == null || value != false) {
              StreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 330: {
            if (requestHeadersTimeout_ == null) {
              RequestHeadersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestHeadersTimeout);
            break;
          }
          case 336: {
            StripAnyHostPort = input.ReadBool();
            break;
          }
          case 346: {
            if (pathNormalizationOptions_ == null) {
              PathNormalizationOptions = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions();
            }
            input.ReadMessage(PathNormalizationOptions);
            break;
          }
          case 354: {
            if (http3ProtocolOptions_ == null) {
              Http3ProtocolOptions = new global::Envoy.Config.Core.V3.Http3ProtocolOptions();
            }
            input.ReadMessage(Http3ProtocolOptions);
            break;
          }
          case 360: {
            PathWithEscapedSlashesAction = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction) input.ReadEnum();
            break;
          }
          case 370: {
            originalIpDetectionExtensions_.AddEntriesFrom(input, _repeated_originalIpDetectionExtensions_codec);
            break;
          }
          case 376: {
            StripTrailingHostDot = input.ReadBool();
            break;
          }
          case 386: {
            if (schemeHeaderTransformation_ == null) {
              SchemeHeaderTransformation = new global::Envoy.Config.Core.V3.SchemeHeaderTransformation();
            }
            input.ReadMessage(SchemeHeaderTransformation);
            break;
          }
          case 394: {
            if (proxyStatusConfig_ == null) {
              ProxyStatusConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig();
            }
            input.ReadMessage(ProxyStatusConfig);
            break;
          }
          case 402: {
            if (typedHeaderValidationConfig_ == null) {
              TypedHeaderValidationConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedHeaderValidationConfig);
            break;
          }
          case 408: {
            AppendXForwardedPort = input.ReadBool();
            break;
          }
          case 418: {
            earlyHeaderMutationExtensions_.AddEntriesFrom(input, _repeated_earlyHeaderMutationExtensions_codec);
            break;
          }
          case 426: {
            bool? value = _single_addProxyProtocolConnectionState_codec.Read(input);
            if (addProxyProtocolConnectionState_ == null || value != false) {
              AddProxyProtocolConnectionState = value;
            }
            break;
          }
          case 434: {
            if (accessLogFlushInterval_ == null) {
              AccessLogFlushInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(AccessLogFlushInterval);
            break;
          }
          case 440: {
            FlushAccessLogOnNewRequest = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CodecType = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.CodecType) input.ReadEnum();
            break;
          }
          case 18: {
            StatPrefix = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.Rds();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
              subBuilder.MergeFrom(Rds);
            }
            input.ReadMessage(subBuilder);
            Rds = subBuilder;
            break;
          }
          case 34: {
            global::Envoy.Config.Route.V3.RouteConfiguration subBuilder = new global::Envoy.Config.Route.V3.RouteConfiguration();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
              subBuilder.MergeFrom(RouteConfig);
            }
            input.ReadMessage(subBuilder);
            RouteConfig = subBuilder;
            break;
          }
          case 42: {
            httpFilters_.AddEntriesFrom(ref input, _repeated_httpFilters_codec);
            break;
          }
          case 50: {
            bool? value = _single_addUserAgent_codec.Read(ref input);
            if (addUserAgent_ == null || value != false) {
              AddUserAgent = value;
            }
            break;
          }
          case 58: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
          case 66: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 74: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 82: {
            ServerName = input.ReadString();
            break;
          }
          case 98: {
            if (drainTimeout_ == null) {
              DrainTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DrainTimeout);
            break;
          }
          case 106: {
            accessLog_.AddEntriesFrom(ref input, _repeated_accessLog_codec);
            break;
          }
          case 114: {
            bool? value = _single_useRemoteAddress_codec.Read(ref input);
            if (useRemoteAddress_ == null || value != false) {
              UseRemoteAddress = value;
            }
            break;
          }
          case 122: {
            bool? value = _single_generateRequestId_codec.Read(ref input);
            if (generateRequestId_ == null || value != false) {
              GenerateRequestId = value;
            }
            break;
          }
          case 128: {
            ForwardClientCertDetails = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ForwardClientCertDetails) input.ReadEnum();
            break;
          }
          case 138: {
            if (setCurrentClientCertDetails_ == null) {
              SetCurrentClientCertDetails = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.SetCurrentClientCertDetails();
            }
            input.ReadMessage(SetCurrentClientCertDetails);
            break;
          }
          case 144: {
            Proxy100Continue = input.ReadBool();
            break;
          }
          case 152: {
            XffNumTrustedHops = input.ReadUInt32();
            break;
          }
          case 160: {
            RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = input.ReadBool();
            break;
          }
          case 168: {
            SkipXffAppend = input.ReadBool();
            break;
          }
          case 178: {
            Via = input.ReadString();
            break;
          }
          case 186: {
            upgradeConfigs_.AddEntriesFrom(ref input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 194: {
            if (streamIdleTimeout_ == null) {
              StreamIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(StreamIdleTimeout);
            break;
          }
          case 202: {
            if (internalAddressConfig_ == null) {
              InternalAddressConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.InternalAddressConfig();
            }
            input.ReadMessage(InternalAddressConfig);
            break;
          }
          case 210: {
            if (delayedCloseTimeout_ == null) {
              DelayedCloseTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DelayedCloseTimeout);
            break;
          }
          case 226: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 234: {
            uint? value = _single_maxRequestHeadersKb_codec.Read(ref input);
            if (maxRequestHeadersKb_ == null || value != 0) {
              MaxRequestHeadersKb = value;
            }
            break;
          }
          case 242: {
            bool? value = _single_normalizePath_codec.Read(ref input);
            if (normalizePath_ == null || value != false) {
              NormalizePath = value;
            }
            break;
          }
          case 250: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
              subBuilder.MergeFrom(ScopedRoutes);
            }
            input.ReadMessage(subBuilder);
            ScopedRoutes = subBuilder;
            break;
          }
          case 256: {
            PreserveExternalRequestId = input.ReadBool();
            break;
          }
          case 264: {
            MergeSlashes = input.ReadBool();
            break;
          }
          case 272: {
            ServerHeaderTransformation = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ServerHeaderTransformation) input.ReadEnum();
            break;
          }
          case 282: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 290: {
            if (requestIdExtension_ == null) {
              RequestIdExtension = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.RequestIDExtension();
            }
            input.ReadMessage(RequestIdExtension);
            break;
          }
          case 296: {
            AlwaysSetRequestIdInResponse = input.ReadBool();
            break;
          }
          case 306: {
            if (localReplyConfig_ == null) {
              LocalReplyConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.LocalReplyConfig();
            }
            input.ReadMessage(LocalReplyConfig);
            break;
          }
          case 312: {
            StripMatchingHostPort = input.ReadBool();
            break;
          }
          case 322: {
            bool? value = _single_streamErrorOnInvalidHttpMessage_codec.Read(ref input);
            if (streamErrorOnInvalidHttpMessage_ == null || value != false) {
              StreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 330: {
            if (requestHeadersTimeout_ == null) {
              RequestHeadersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestHeadersTimeout);
            break;
          }
          case 336: {
            StripAnyHostPort = input.ReadBool();
            break;
          }
          case 346: {
            if (pathNormalizationOptions_ == null) {
              PathNormalizationOptions = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathNormalizationOptions();
            }
            input.ReadMessage(PathNormalizationOptions);
            break;
          }
          case 354: {
            if (http3ProtocolOptions_ == null) {
              Http3ProtocolOptions = new global::Envoy.Config.Core.V3.Http3ProtocolOptions();
            }
            input.ReadMessage(Http3ProtocolOptions);
            break;
          }
          case 360: {
            PathWithEscapedSlashesAction = (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.PathWithEscapedSlashesAction) input.ReadEnum();
            break;
          }
          case 370: {
            originalIpDetectionExtensions_.AddEntriesFrom(ref input, _repeated_originalIpDetectionExtensions_codec);
            break;
          }
          case 376: {
            StripTrailingHostDot = input.ReadBool();
            break;
          }
          case 386: {
            if (schemeHeaderTransformation_ == null) {
              SchemeHeaderTransformation = new global::Envoy.Config.Core.V3.SchemeHeaderTransformation();
            }
            input.ReadMessage(SchemeHeaderTransformation);
            break;
          }
          case 394: {
            if (proxyStatusConfig_ == null) {
              ProxyStatusConfig = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Types.ProxyStatusConfig();
            }
            input.ReadMessage(ProxyStatusConfig);
            break;
          }
          case 402: {
            if (typedHeaderValidationConfig_ == null) {
              TypedHeaderValidationConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedHeaderValidationConfig);
            break;
          }
          case 408: {
            AppendXForwardedPort = input.ReadBool();
            break;
          }
          case 418: {
            earlyHeaderMutationExtensions_.AddEntriesFrom(ref input, _repeated_earlyHeaderMutationExtensions_codec);
            break;
          }
          case 426: {
            bool? value = _single_addProxyProtocolConnectionState_codec.Read(ref input);
            if (addProxyProtocolConnectionState_ == null || value != false) {
              AddProxyProtocolConnectionState = value;
            }
            break;
          }
          case 434: {
            if (accessLogFlushInterval_ == null) {
              AccessLogFlushInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(AccessLogFlushInterval);
            break;
          }
          case 440: {
            FlushAccessLogOnNewRequest = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the HttpConnectionManager message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum CodecType {
        /// <summary>
        /// For every new connection, the connection manager will determine which
        /// codec to use. This mode supports both ALPN for TLS listeners as well as
        /// protocol inference for plaintext listeners. If ALPN data is available, it
        /// is preferred, otherwise protocol inference is used. In almost all cases,
        /// this is the right option to choose for this setting.
        /// </summary>
        [pbr::OriginalName("AUTO")] Auto = 0,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/1.1.
        /// </summary>
        [pbr::OriginalName("HTTP1")] Http1 = 1,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/2
        /// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
        /// Prior knowledge is allowed).
        /// </summary>
        [pbr::OriginalName("HTTP2")] Http2 = 2,
        /// <summary>
        /// [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
        /// caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
        /// to distinguish HTTP1 and HTTP2 traffic.
        /// </summary>
        [pbr::OriginalName("HTTP3")] Http3 = 3,
      }

      public enum ServerHeaderTransformation {
        /// <summary>
        /// Overwrite any Server header with the contents of server_name.
        /// </summary>
        [pbr::OriginalName("OVERWRITE")] Overwrite = 0,
        /// <summary>
        /// If no Server header is present, append Server server_name
        /// If a Server header is present, pass it through.
        /// </summary>
        [pbr::OriginalName("APPEND_IF_ABSENT")] AppendIfAbsent = 1,
        /// <summary>
        /// Pass through the value of the server header, and do not append a header
        /// if none is present.
        /// </summary>
        [pbr::OriginalName("PASS_THROUGH")] PassThrough = 2,
      }

      /// <summary>
      /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
      /// header.
      /// </summary>
      public enum ForwardClientCertDetails {
        /// <summary>
        /// Do not send the XFCC header to the next hop. This is the default value.
        /// </summary>
        [pbr::OriginalName("SANITIZE")] Sanitize = 0,
        /// <summary>
        /// When the client connection is mTLS (Mutual TLS), forward the XFCC header
        /// in the request.
        /// </summary>
        [pbr::OriginalName("FORWARD_ONLY")] ForwardOnly = 1,
        /// <summary>
        /// When the client connection is mTLS, append the client certificate
        /// information to the request’s XFCC header and forward it.
        /// </summary>
        [pbr::OriginalName("APPEND_FORWARD")] AppendForward = 2,
        /// <summary>
        /// When the client connection is mTLS, reset the XFCC header with the client
        /// certificate information and send it to the next hop.
        /// </summary>
        [pbr::OriginalName("SANITIZE_SET")] SanitizeSet = 3,
        /// <summary>
        /// Always forward the XFCC header in the request, regardless of whether the
        /// client connection is mTLS.
        /// </summary>
        [pbr::OriginalName("ALWAYS_FORWARD_ONLY")] AlwaysForwardOnly = 4,
      }

      /// <summary>
      /// Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
      /// This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
      /// </summary>
      public enum PathWithEscapedSlashesAction {
        /// <summary>
        /// Default behavior specific to implementation (i.e. Envoy) of this configuration option.
        /// Envoy, by default, takes the KEEP_UNCHANGED action.
        /// NOTE: the implementation may change the default behavior at-will.
        /// </summary>
        [pbr::OriginalName("IMPLEMENTATION_SPECIFIC_DEFAULT")] ImplementationSpecificDefault = 0,
        /// <summary>
        /// Keep escaped slashes.
        /// </summary>
        [pbr::OriginalName("KEEP_UNCHANGED")] KeepUnchanged = 1,
        /// <summary>
        /// Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
        /// The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
        /// </summary>
        [pbr::OriginalName("REJECT_REQUEST")] RejectRequest = 2,
        /// <summary>
        /// Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
        /// Redirect occurs after path normalization and merge slashes transformations if they were configured.
        /// NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
        /// This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
        /// traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
        /// The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
        /// redirected request.
        /// </summary>
        [pbr::OriginalName("UNESCAPE_AND_REDIRECT")] UnescapeAndRedirect = 3,
        /// <summary>
        /// Unescape %2F and %5C sequences.
        /// Note: this option should not be enabled if intermediaries perform path based access control as
        /// it may lead to path confusion vulnerabilities.
        /// </summary>
        [pbr::OriginalName("UNESCAPE_AND_FORWARD")] UnescapeAndForward = 4,
      }

      /// <summary>
      /// [#next-free-field: 10]
      /// </summary>
      public sealed partial class Tracing : pb::IMessage<Tracing>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Tracing() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Tracing(Tracing other) : this() {
          clientSampling_ = other.clientSampling_ != null ? other.clientSampling_.Clone() : null;
          randomSampling_ = other.randomSampling_ != null ? other.randomSampling_.Clone() : null;
          overallSampling_ = other.overallSampling_ != null ? other.overallSampling_.Clone() : null;
          verbose_ = other.verbose_;
          MaxPathTagLength = other.MaxPathTagLength;
          customTags_ = other.customTags_.Clone();
          provider_ = other.provider_ != null ? other.provider_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Tracing Clone() {
          return new Tracing(this);
        }

        /// <summary>Field number for the "client_sampling" field.</summary>
        public const int ClientSamplingFieldNumber = 3;
        private global::Envoy.Type.V3.Percent clientSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be force
        /// traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id>`
        /// header is set. This field is a direct analog for the runtime variable
        /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
        /// &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.V3.Percent ClientSampling {
          get { return clientSampling_; }
          set {
            clientSampling_ = value;
          }
        }

        /// <summary>Field number for the "random_sampling" field.</summary>
        public const int RandomSamplingFieldNumber = 4;
        private global::Envoy.Type.V3.Percent randomSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be randomly
        /// selected for trace generation, if not requested by the client or not forced. This field is
        /// a direct analog for the runtime variable 'tracing.random_sampling' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.V3.Percent RandomSampling {
          get { return randomSampling_; }
          set {
            randomSampling_ = value;
          }
        }

        /// <summary>Field number for the "overall_sampling" field.</summary>
        public const int OverallSamplingFieldNumber = 5;
        private global::Envoy.Type.V3.Percent overallSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be traced
        /// after all other sampling checks have been applied (client-directed, force tracing, random
        /// sampling). This field functions as an upper limit on the total configured sampling rate. For
        /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
        /// of client requests with the appropriate headers to be force traced. This field is a direct
        /// analog for the runtime variable 'tracing.global_enabled' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.V3.Percent OverallSampling {
          get { return overallSampling_; }
          set {
            overallSampling_ = value;
          }
        }

        /// <summary>Field number for the "verbose" field.</summary>
        public const int VerboseFieldNumber = 6;
        private bool verbose_;
        /// <summary>
        /// Whether to annotate spans with additional data. If true, spans will include logs for stream
        /// events.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Verbose {
          get { return verbose_; }
          set {
            verbose_ = value;
          }
        }

        /// <summary>Field number for the "max_path_tag_length" field.</summary>
        public const int MaxPathTagLengthFieldNumber = 7;
        private static readonly pb::FieldCodec<uint?> _single_maxPathTagLength_codec = pb::FieldCodec.ForStructWrapper<uint>(58);
        private uint? maxPathTagLength_;
        /// <summary>
        /// Maximum length of the request path to extract and include in the HttpUrl tag. Used to
        /// truncate lengthy request paths to meet the needs of a tracing backend.
        /// Default: 256
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? MaxPathTagLength {
          get { return maxPathTagLength_; }
          set {
            maxPathTagLength_ = value;
          }
        }


        /// <summary>Field number for the "custom_tags" field.</summary>
        public const int CustomTagsFieldNumber = 8;
        private static readonly pb::FieldCodec<global::Envoy.Type.Tracing.V3.CustomTag> _repeated_customTags_codec
            = pb::FieldCodec.ForMessage(66, global::Envoy.Type.Tracing.V3.CustomTag.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag> customTags_ = new pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag>();
        /// <summary>
        /// A list of custom tags with unique tag name to create tags for the active span.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag> CustomTags {
          get { return customTags_; }
        }

        /// <summary>Field number for the "provider" field.</summary>
        public const int ProviderFieldNumber = 9;
        private global::Envoy.Config.Trace.V3.Tracing.Types.Http provider_;
        /// <summary>
        /// Configuration for an external tracing provider.
        /// If not specified, no tracing will be performed.
        ///
        /// .. attention::
        ///   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
        ///   in Envoy lifetime.
        ///   Any attempts to reconfigure it or to use different configurations for different HCM filters
        ///   will be rejected.
        ///   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
        ///   on OpenCensus side.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Trace.V3.Tracing.Types.Http Provider {
          get { return provider_; }
          set {
            provider_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Tracing);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Tracing other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ClientSampling, other.ClientSampling)) return false;
          if (!object.Equals(RandomSampling, other.RandomSampling)) return false;
          if (!object.Equals(OverallSampling, other.OverallSampling)) return false;
          if (Verbose != other.Verbose) return false;
          if (MaxPathTagLength != other.MaxPathTagLength) return false;
          if(!customTags_.Equals(other.customTags_)) return false;
          if (!object.Equals(Provider, other.Provider)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (clientSampling_ != null) hash ^= ClientSampling.GetHashCode();
          if (randomSampling_ != null) hash ^= RandomSampling.GetHashCode();
          if (overallSampling_ != null) hash ^= OverallSampling.GetHashCode();
          if (Verbose != false) hash ^= Verbose.GetHashCode();
          if (maxPathTagLength_ != null) hash ^= MaxPathTagLength.GetHashCode();
          hash ^= customTags_.GetHashCode();
          if (provider_ != null) hash ^= Provider.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (clientSampling_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ClientSampling);
          }
          if (randomSampling_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(RandomSampling);
          }
          if (overallSampling_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OverallSampling);
          }
          if (Verbose != false) {
            output.WriteRawTag(48);
            output.WriteBool(Verbose);
          }
          if (maxPathTagLength_ != null) {
            _single_maxPathTagLength_codec.WriteTagAndValue(output, MaxPathTagLength);
          }
          customTags_.WriteTo(output, _repeated_customTags_codec);
          if (provider_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(Provider);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (clientSampling_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ClientSampling);
          }
          if (randomSampling_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(RandomSampling);
          }
          if (overallSampling_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OverallSampling);
          }
          if (Verbose != false) {
            output.WriteRawTag(48);
            output.WriteBool(Verbose);
          }
          if (maxPathTagLength_ != null) {
            _single_maxPathTagLength_codec.WriteTagAndValue(ref output, MaxPathTagLength);
          }
          customTags_.WriteTo(ref output, _repeated_customTags_codec);
          if (provider_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(Provider);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (clientSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientSampling);
          }
          if (randomSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomSampling);
          }
          if (overallSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverallSampling);
          }
          if (Verbose != false) {
            size += 1 + 1;
          }
          if (maxPathTagLength_ != null) {
            size += _single_maxPathTagLength_codec.CalculateSizeWithTag(MaxPathTagLength);
          }
          size += customTags_.CalculateSize(_repeated_customTags_codec);
          if (provider_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Provider);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Tracing other) {
          if (other == null) {
            return;
          }
          if (other.clientSampling_ != null) {
            if (clientSampling_ == null) {
              ClientSampling = new global::Envoy.Type.V3.Percent();
            }
            ClientSampling.MergeFrom(other.ClientSampling);
          }
          if (other.randomSampling_ != null) {
            if (randomSampling_ == null) {
              RandomSampling = new global::Envoy.Type.V3.Percent();
            }
            RandomSampling.MergeFrom(other.RandomSampling);
          }
          if (other.overallSampling_ != null) {
            if (overallSampling_ == null) {
              OverallSampling = new global::Envoy.Type.V3.Percent();
            }
            OverallSampling.MergeFrom(other.OverallSampling);
          }
          if (other.Verbose != false) {
            Verbose = other.Verbose;
          }
          if (other.maxPathTagLength_ != null) {
            if (maxPathTagLength_ == null || other.MaxPathTagLength != 0) {
              MaxPathTagLength = other.MaxPathTagLength;
            }
          }
          customTags_.Add(other.customTags_);
          if (other.provider_ != null) {
            if (provider_ == null) {
              Provider = new global::Envoy.Config.Trace.V3.Tracing.Types.Http();
            }
            Provider.MergeFrom(other.Provider);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 26: {
                if (clientSampling_ == null) {
                  ClientSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(ClientSampling);
                break;
              }
              case 34: {
                if (randomSampling_ == null) {
                  RandomSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(RandomSampling);
                break;
              }
              case 42: {
                if (overallSampling_ == null) {
                  OverallSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(OverallSampling);
                break;
              }
              case 48: {
                Verbose = input.ReadBool();
                break;
              }
              case 58: {
                uint? value = _single_maxPathTagLength_codec.Read(input);
                if (maxPathTagLength_ == null || value != 0) {
                  MaxPathTagLength = value;
                }
                break;
              }
              case 66: {
                customTags_.AddEntriesFrom(input, _repeated_customTags_codec);
                break;
              }
              case 74: {
                if (provider_ == null) {
                  Provider = new global::Envoy.Config.Trace.V3.Tracing.Types.Http();
                }
                input.ReadMessage(Provider);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 26: {
                if (clientSampling_ == null) {
                  ClientSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(ClientSampling);
                break;
              }
              case 34: {
                if (randomSampling_ == null) {
                  RandomSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(RandomSampling);
                break;
              }
              case 42: {
                if (overallSampling_ == null) {
                  OverallSampling = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(OverallSampling);
                break;
              }
              case 48: {
                Verbose = input.ReadBool();
                break;
              }
              case 58: {
                uint? value = _single_maxPathTagLength_codec.Read(ref input);
                if (maxPathTagLength_ == null || value != 0) {
                  MaxPathTagLength = value;
                }
                break;
              }
              case 66: {
                customTags_.AddEntriesFrom(ref input, _repeated_customTags_codec);
                break;
              }
              case 74: {
                if (provider_ == null) {
                  Provider = new global::Envoy.Config.Trace.V3.Tracing.Types.Http();
                }
                input.ReadMessage(Provider);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Tracing message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum OperationName {
            /// <summary>
            /// The HTTP listener is used for ingress/incoming requests.
            /// </summary>
            [pbr::OriginalName("INGRESS")] Ingress = 0,
            /// <summary>
            /// The HTTP listener is used for egress/outgoing requests.
            /// </summary>
            [pbr::OriginalName("EGRESS")] Egress = 1,
          }

        }
        #endregion

      }

      public sealed partial class InternalAddressConfig : pb::IMessage<InternalAddressConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InternalAddressConfig> _parser = new pb::MessageParser<InternalAddressConfig>(() => new InternalAddressConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InternalAddressConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalAddressConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalAddressConfig(InternalAddressConfig other) : this() {
          unixSockets_ = other.unixSockets_;
          cidrRanges_ = other.cidrRanges_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InternalAddressConfig Clone() {
          return new InternalAddressConfig(this);
        }

        /// <summary>Field number for the "unix_sockets" field.</summary>
        public const int UnixSocketsFieldNumber = 1;
        private bool unixSockets_;
        /// <summary>
        /// Whether unix socket addresses should be considered internal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UnixSockets {
          get { return unixSockets_; }
          set {
            unixSockets_ = value;
          }
        }

        /// <summary>Field number for the "cidr_ranges" field.</summary>
        public const int CidrRangesFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.CidrRange> _repeated_cidrRanges_codec
            = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Core.V3.CidrRange.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> cidrRanges_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange>();
        /// <summary>
        /// List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
        /// IP addresses will be considered internal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> CidrRanges {
          get { return cidrRanges_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InternalAddressConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InternalAddressConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UnixSockets != other.UnixSockets) return false;
          if(!cidrRanges_.Equals(other.cidrRanges_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UnixSockets != false) hash ^= UnixSockets.GetHashCode();
          hash ^= cidrRanges_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UnixSockets != false) {
            output.WriteRawTag(8);
            output.WriteBool(UnixSockets);
          }
          cidrRanges_.WriteTo(output, _repeated_cidrRanges_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UnixSockets != false) {
            output.WriteRawTag(8);
            output.WriteBool(UnixSockets);
          }
          cidrRanges_.WriteTo(ref output, _repeated_cidrRanges_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UnixSockets != false) {
            size += 1 + 1;
          }
          size += cidrRanges_.CalculateSize(_repeated_cidrRanges_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InternalAddressConfig other) {
          if (other == null) {
            return;
          }
          if (other.UnixSockets != false) {
            UnixSockets = other.UnixSockets;
          }
          cidrRanges_.Add(other.cidrRanges_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UnixSockets = input.ReadBool();
                break;
              }
              case 18: {
                cidrRanges_.AddEntriesFrom(input, _repeated_cidrRanges_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                UnixSockets = input.ReadBool();
                break;
              }
              case 18: {
                cidrRanges_.AddEntriesFrom(ref input, _repeated_cidrRanges_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// [#next-free-field: 7]
      /// </summary>
      public sealed partial class SetCurrentClientCertDetails : pb::IMessage<SetCurrentClientCertDetails>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SetCurrentClientCertDetails> _parser = new pb::MessageParser<SetCurrentClientCertDetails>(() => new SetCurrentClientCertDetails());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SetCurrentClientCertDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SetCurrentClientCertDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SetCurrentClientCertDetails(SetCurrentClientCertDetails other) : this() {
          Subject = other.Subject;
          cert_ = other.cert_;
          chain_ = other.chain_;
          dns_ = other.dns_;
          uri_ = other.uri_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SetCurrentClientCertDetails Clone() {
          return new SetCurrentClientCertDetails(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_subject_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? subject_;
        /// <summary>
        /// Whether to forward the subject of the client cert. Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }


        /// <summary>Field number for the "cert" field.</summary>
        public const int CertFieldNumber = 3;
        private bool cert_;
        /// <summary>
        /// Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
        /// XFCC header comma separated from other values with the value Cert="PEM".
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Cert {
          get { return cert_; }
          set {
            cert_ = value;
          }
        }

        /// <summary>Field number for the "chain" field.</summary>
        public const int ChainFieldNumber = 6;
        private bool chain_;
        /// <summary>
        /// Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
        /// format. This will appear in the XFCC header comma separated from other values with the value
        /// Chain="PEM".
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Chain {
          get { return chain_; }
          set {
            chain_ = value;
          }
        }

        /// <summary>Field number for the "dns" field.</summary>
        public const int DnsFieldNumber = 4;
        private bool dns_;
        /// <summary>
        /// Whether to forward the DNS type Subject Alternative Names of the client cert.
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Dns {
          get { return dns_; }
          set {
            dns_ = value;
          }
        }

        /// <summary>Field number for the "uri" field.</summary>
        public const int UriFieldNumber = 5;
        private bool uri_;
        /// <summary>
        /// Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
        /// false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Uri {
          get { return uri_; }
          set {
            uri_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SetCurrentClientCertDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SetCurrentClientCertDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Subject != other.Subject) return false;
          if (Cert != other.Cert) return false;
          if (Chain != other.Chain) return false;
          if (Dns != other.Dns) return false;
          if (Uri != other.Uri) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (Cert != false) hash ^= Cert.GetHashCode();
          if (Chain != false) hash ^= Chain.GetHashCode();
          if (Dns != false) hash ^= Dns.GetHashCode();
          if (Uri != false) hash ^= Uri.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (subject_ != null) {
            _single_subject_codec.WriteTagAndValue(output, Subject);
          }
          if (Cert != false) {
            output.WriteRawTag(24);
            output.WriteBool(Cert);
          }
          if (Dns != false) {
            output.WriteRawTag(32);
            output.WriteBool(Dns);
          }
          if (Uri != false) {
            output.WriteRawTag(40);
            output.WriteBool(Uri);
          }
          if (Chain != false) {
            output.WriteRawTag(48);
            output.WriteBool(Chain);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (subject_ != null) {
            _single_subject_codec.WriteTagAndValue(ref output, Subject);
          }
          if (Cert != false) {
            output.WriteRawTag(24);
            output.WriteBool(Cert);
          }
          if (Dns != false) {
            output.WriteRawTag(32);
            output.WriteBool(Dns);
          }
          if (Uri != false) {
            output.WriteRawTag(40);
            output.WriteBool(Uri);
          }
          if (Chain != false) {
            output.WriteRawTag(48);
            output.WriteBool(Chain);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += _single_subject_codec.CalculateSizeWithTag(Subject);
          }
          if (Cert != false) {
            size += 1 + 1;
          }
          if (Chain != false) {
            size += 1 + 1;
          }
          if (Dns != false) {
            size += 1 + 1;
          }
          if (Uri != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SetCurrentClientCertDetails other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null || other.Subject != false) {
              Subject = other.Subject;
            }
          }
          if (other.Cert != false) {
            Cert = other.Cert;
          }
          if (other.Chain != false) {
            Chain = other.Chain;
          }
          if (other.Dns != false) {
            Dns = other.Dns;
          }
          if (other.Uri != false) {
            Uri = other.Uri;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_subject_codec.Read(input);
                if (subject_ == null || value != false) {
                  Subject = value;
                }
                break;
              }
              case 24: {
                Cert = input.ReadBool();
                break;
              }
              case 32: {
                Dns = input.ReadBool();
                break;
              }
              case 40: {
                Uri = input.ReadBool();
                break;
              }
              case 48: {
                Chain = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                bool? value = _single_subject_codec.Read(ref input);
                if (subject_ == null || value != false) {
                  Subject = value;
                }
                break;
              }
              case 24: {
                Cert = input.ReadBool();
                break;
              }
              case 32: {
                Dns = input.ReadBool();
                break;
              }
              case 40: {
                Uri = input.ReadBool();
                break;
              }
              case 48: {
                Chain = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The configuration for HTTP upgrades.
      /// For each upgrade type desired, an UpgradeConfig must be added.
      ///
      /// .. warning::
      ///
      ///    The current implementation of upgrade headers does not handle
      ///    multi-valued upgrade headers. Support for multi-valued headers may be
      ///    added in the future if needed.
      ///
      /// .. warning::
      ///    The current implementation of upgrade headers does not work with HTTP/2
      ///    upstreams.
      /// </summary>
      public sealed partial class UpgradeConfig : pb::IMessage<UpgradeConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<UpgradeConfig> _parser = new pb::MessageParser<UpgradeConfig>(() => new UpgradeConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<UpgradeConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig(UpgradeConfig other) : this() {
          upgradeType_ = other.upgradeType_;
          filters_ = other.filters_.Clone();
          Enabled = other.Enabled;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig Clone() {
          return new UpgradeConfig(this);
        }

        /// <summary>Field number for the "upgrade_type" field.</summary>
        public const int UpgradeTypeFieldNumber = 1;
        private string upgradeType_ = "";
        /// <summary>
        /// The case-insensitive name of this upgrade, e.g. "websocket".
        /// For each upgrade type present in upgrade_configs, requests with
        /// Upgrade: [upgrade_type]
        /// will be proxied upstream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string UpgradeType {
          get { return upgradeType_; }
          set {
            upgradeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "filters" field.</summary>
        public const int FiltersFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> _repeated_filters_codec
            = pb::FieldCodec.ForMessage(18, global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> filters_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter>();
        /// <summary>
        /// If present, this represents the filter chain which will be created for
        /// this type of upgrade. If no filters are present, the filter chain for
        /// HTTP connections will be used for this upgrade type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpFilter> Filters {
          get { return filters_; }
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 3;
        private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(26);
        private bool? enabled_;
        /// <summary>
        /// Determines if upgrades are enabled or disabled by default. Defaults to true.
        /// This can be overridden on a per-route basis with :ref:`cluster
        /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
        /// :ref:`upgrade documentation &lt;arch_overview_upgrades>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as UpgradeConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(UpgradeConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UpgradeType != other.UpgradeType) return false;
          if(!filters_.Equals(other.filters_)) return false;
          if (Enabled != other.Enabled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UpgradeType.Length != 0) hash ^= UpgradeType.GetHashCode();
          hash ^= filters_.GetHashCode();
          if (enabled_ != null) hash ^= Enabled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          filters_.WriteTo(output, _repeated_filters_codec);
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(output, Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          filters_.WriteTo(ref output, _repeated_filters_codec);
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(ref output, Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UpgradeType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(UpgradeType);
          }
          size += filters_.CalculateSize(_repeated_filters_codec);
          if (enabled_ != null) {
            size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(UpgradeConfig other) {
          if (other == null) {
            return;
          }
          if (other.UpgradeType.Length != 0) {
            UpgradeType = other.UpgradeType;
          }
          filters_.Add(other.filters_);
          if (other.enabled_ != null) {
            if (enabled_ == null || other.Enabled != false) {
              Enabled = other.Enabled;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                filters_.AddEntriesFrom(input, _repeated_filters_codec);
                break;
              }
              case 26: {
                bool? value = _single_enabled_codec.Read(input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                filters_.AddEntriesFrom(ref input, _repeated_filters_codec);
                break;
              }
              case 26: {
                bool? value = _single_enabled_codec.Read(ref input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
      /// before any processing of requests by HTTP filters, routing, and matching. Only the normalized
      /// path will be visible internally if a transformation is enabled. Any path rewrites that the
      /// router performs (e.g. :ref:`regex_rewrite
      /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>` or :ref:`prefix_rewrite
      /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`) will apply to the ``:path`` header
      /// destined for the upstream.
      ///
      /// Note: access logging and tracing will show the original ``:path`` header.
      /// </summary>
      public sealed partial class PathNormalizationOptions : pb::IMessage<PathNormalizationOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PathNormalizationOptions> _parser = new pb::MessageParser<PathNormalizationOptions>(() => new PathNormalizationOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PathNormalizationOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PathNormalizationOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PathNormalizationOptions(PathNormalizationOptions other) : this() {
          forwardingTransformation_ = other.forwardingTransformation_ != null ? other.forwardingTransformation_.Clone() : null;
          httpFilterTransformation_ = other.httpFilterTransformation_ != null ? other.httpFilterTransformation_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PathNormalizationOptions Clone() {
          return new PathNormalizationOptions(this);
        }

        /// <summary>Field number for the "forwarding_transformation" field.</summary>
        public const int ForwardingTransformationFieldNumber = 1;
        private global::Envoy.Type.Http.V3.PathTransformation forwardingTransformation_;
        /// <summary>
        /// [#not-implemented-hide:] Normalization applies internally before any processing of requests by
        /// HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
        /// to :ref:`NormalizePathRFC3986
        /// &lt;envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986>`. When not
        /// specified, this value may be overridden by the runtime variable
        /// :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path>`.
        /// Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
        /// normalization due to disallowed characters.)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.Http.V3.PathTransformation ForwardingTransformation {
          get { return forwardingTransformation_; }
          set {
            forwardingTransformation_ = value;
          }
        }

        /// <summary>Field number for the "http_filter_transformation" field.</summary>
        public const int HttpFilterTransformationFieldNumber = 2;
        private global::Envoy.Type.Http.V3.PathTransformation httpFilterTransformation_;
        /// <summary>
        /// [#not-implemented-hide:] Normalization only applies internally before any processing of
        /// requests by HTTP filters, routing, and matching. These will be applied after full
        /// transformation is applied. The ``:path`` header before this transformation will be restored in
        /// the router filter and sent upstream unless it was mutated by a filter. Defaults to no
        /// transformations.
        /// Multiple actions can be applied in the same Transformation, forming a sequential
        /// pipeline. The transformations will be performed in the order that they appear. Envoy will
        /// respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
        /// normalization due to disallowed characters.)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.Http.V3.PathTransformation HttpFilterTransformation {
          get { return httpFilterTransformation_; }
          set {
            httpFilterTransformation_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PathNormalizationOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PathNormalizationOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ForwardingTransformation, other.ForwardingTransformation)) return false;
          if (!object.Equals(HttpFilterTransformation, other.HttpFilterTransformation)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (forwardingTransformation_ != null) hash ^= ForwardingTransformation.GetHashCode();
          if (httpFilterTransformation_ != null) hash ^= HttpFilterTransformation.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (forwardingTransformation_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ForwardingTransformation);
          }
          if (httpFilterTransformation_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(HttpFilterTransformation);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (forwardingTransformation_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ForwardingTransformation);
          }
          if (httpFilterTransformation_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(HttpFilterTransformation);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (forwardingTransformation_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ForwardingTransformation);
          }
          if (httpFilterTransformation_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpFilterTransformation);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PathNormalizationOptions other) {
          if (other == null) {
            return;
          }
          if (other.forwardingTransformation_ != null) {
            if (forwardingTransformation_ == null) {
              ForwardingTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
            }
            ForwardingTransformation.MergeFrom(other.ForwardingTransformation);
          }
          if (other.httpFilterTransformation_ != null) {
            if (httpFilterTransformation_ == null) {
              HttpFilterTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
            }
            HttpFilterTransformation.MergeFrom(other.HttpFilterTransformation);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (forwardingTransformation_ == null) {
                  ForwardingTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
                }
                input.ReadMessage(ForwardingTransformation);
                break;
              }
              case 18: {
                if (httpFilterTransformation_ == null) {
                  HttpFilterTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
                }
                input.ReadMessage(HttpFilterTransformation);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (forwardingTransformation_ == null) {
                  ForwardingTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
                }
                input.ReadMessage(ForwardingTransformation);
                break;
              }
              case 18: {
                if (httpFilterTransformation_ == null) {
                  HttpFilterTransformation = new global::Envoy.Type.Http.V3.PathTransformation();
                }
                input.ReadMessage(HttpFilterTransformation);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Configures the manner in which the Proxy-Status HTTP response header is
      /// populated.
      ///
      /// See the [Proxy-Status
      /// RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
      /// [#comment:TODO: Update this with the non-draft URL when finalized.]
      ///
      /// The Proxy-Status header is a string of the form:
      ///
      ///   "&lt;server_name>; error=&lt;error_type>; details=&lt;details>"
      /// [#next-free-field: 7]
      /// </summary>
      public sealed partial class ProxyStatusConfig : pb::IMessage<ProxyStatusConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ProxyStatusConfig> _parser = new pb::MessageParser<ProxyStatusConfig>(() => new ProxyStatusConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ProxyStatusConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ProxyStatusConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ProxyStatusConfig(ProxyStatusConfig other) : this() {
          removeDetails_ = other.removeDetails_;
          removeConnectionTerminationDetails_ = other.removeConnectionTerminationDetails_;
          removeResponseFlags_ = other.removeResponseFlags_;
          setRecommendedResponseCode_ = other.setRecommendedResponseCode_;
          switch (other.ProxyNameCase) {
            case ProxyNameOneofCase.UseNodeId:
              UseNodeId = other.UseNodeId;
              break;
            case ProxyNameOneofCase.LiteralProxyName:
              LiteralProxyName = other.LiteralProxyName;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ProxyStatusConfig Clone() {
          return new ProxyStatusConfig(this);
        }

        /// <summary>Field number for the "remove_details" field.</summary>
        public const int RemoveDetailsFieldNumber = 1;
        private bool removeDetails_;
        /// <summary>
        /// If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
        /// This value defaults to ``false``, i.e. the ``details`` field is populated by default.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RemoveDetails {
          get { return removeDetails_; }
          set {
            removeDetails_ = value;
          }
        }

        /// <summary>Field number for the "remove_connection_termination_details" field.</summary>
        public const int RemoveConnectionTerminationDetailsFieldNumber = 2;
        private bool removeConnectionTerminationDetails_;
        /// <summary>
        /// If true, the details field of the Proxy-Status header will not contain
        /// connection termination details. This value defaults to ``false``, i.e. the
        /// ``details`` field will contain connection termination details by default.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RemoveConnectionTerminationDetails {
          get { return removeConnectionTerminationDetails_; }
          set {
            removeConnectionTerminationDetails_ = value;
          }
        }

        /// <summary>Field number for the "remove_response_flags" field.</summary>
        public const int RemoveResponseFlagsFieldNumber = 3;
        private bool removeResponseFlags_;
        /// <summary>
        /// If true, the details field of the Proxy-Status header will not contain an
        /// enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
        /// i.e. the ``details`` field will contain a list of ResponseFlags by default.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RemoveResponseFlags {
          get { return removeResponseFlags_; }
          set {
            removeResponseFlags_ = value;
          }
        }

        /// <summary>Field number for the "set_recommended_response_code" field.</summary>
        public const int SetRecommendedResponseCodeFieldNumber = 4;
        private bool setRecommendedResponseCode_;
        /// <summary>
        /// If true, overwrites the existing Status header with the response code
        /// recommended by the Proxy-Status spec.
        /// This value defaults to ``false``, i.e. the HTTP response code is not
        /// overwritten.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SetRecommendedResponseCode {
          get { return setRecommendedResponseCode_; }
          set {
            setRecommendedResponseCode_ = value;
          }
        }

        /// <summary>Field number for the "use_node_id" field.</summary>
        public const int UseNodeIdFieldNumber = 5;
        /// <summary>
        /// If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
        /// ID as the name of the proxy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UseNodeId {
          get { return proxyNameCase_ == ProxyNameOneofCase.UseNodeId ? (bool) proxyName_ : false; }
          set {
            proxyName_ = value;
            proxyNameCase_ = ProxyNameOneofCase.UseNodeId;
          }
        }

        /// <summary>Field number for the "literal_proxy_name" field.</summary>
        public const int LiteralProxyNameFieldNumber = 6;
        /// <summary>
        /// If ``literal_proxy_name`` is set, Proxy-Status headers will use this
        /// value as the name of the proxy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string LiteralProxyName {
          get { return proxyNameCase_ == ProxyNameOneofCase.LiteralProxyName ? (string) proxyName_ : ""; }
          set {
            proxyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            proxyNameCase_ = ProxyNameOneofCase.LiteralProxyName;
          }
        }

        private object proxyName_;
        /// <summary>Enum of possible cases for the "proxy_name" oneof.</summary>
        public enum ProxyNameOneofCase {
          None = 0,
          UseNodeId = 5,
          LiteralProxyName = 6,
        }
        private ProxyNameOneofCase proxyNameCase_ = ProxyNameOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ProxyNameOneofCase ProxyNameCase {
          get { return proxyNameCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearProxyName() {
          proxyNameCase_ = ProxyNameOneofCase.None;
          proxyName_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ProxyStatusConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ProxyStatusConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (RemoveDetails != other.RemoveDetails) return false;
          if (RemoveConnectionTerminationDetails != other.RemoveConnectionTerminationDetails) return false;
          if (RemoveResponseFlags != other.RemoveResponseFlags) return false;
          if (SetRecommendedResponseCode != other.SetRecommendedResponseCode) return false;
          if (UseNodeId != other.UseNodeId) return false;
          if (LiteralProxyName != other.LiteralProxyName) return false;
          if (ProxyNameCase != other.ProxyNameCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (RemoveDetails != false) hash ^= RemoveDetails.GetHashCode();
          if (RemoveConnectionTerminationDetails != false) hash ^= RemoveConnectionTerminationDetails.GetHashCode();
          if (RemoveResponseFlags != false) hash ^= RemoveResponseFlags.GetHashCode();
          if (SetRecommendedResponseCode != false) hash ^= SetRecommendedResponseCode.GetHashCode();
          if (proxyNameCase_ == ProxyNameOneofCase.UseNodeId) hash ^= UseNodeId.GetHashCode();
          if (proxyNameCase_ == ProxyNameOneofCase.LiteralProxyName) hash ^= LiteralProxyName.GetHashCode();
          hash ^= (int) proxyNameCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (RemoveDetails != false) {
            output.WriteRawTag(8);
            output.WriteBool(RemoveDetails);
          }
          if (RemoveConnectionTerminationDetails != false) {
            output.WriteRawTag(16);
            output.WriteBool(RemoveConnectionTerminationDetails);
          }
          if (RemoveResponseFlags != false) {
            output.WriteRawTag(24);
            output.WriteBool(RemoveResponseFlags);
          }
          if (SetRecommendedResponseCode != false) {
            output.WriteRawTag(32);
            output.WriteBool(SetRecommendedResponseCode);
          }
          if (proxyNameCase_ == ProxyNameOneofCase.UseNodeId) {
            output.WriteRawTag(40);
            output.WriteBool(UseNodeId);
          }
          if (proxyNameCase_ == ProxyNameOneofCase.LiteralProxyName) {
            output.WriteRawTag(50);
            output.WriteString(LiteralProxyName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (RemoveDetails != false) {
            output.WriteRawTag(8);
            output.WriteBool(RemoveDetails);
          }
          if (RemoveConnectionTerminationDetails != false) {
            output.WriteRawTag(16);
            output.WriteBool(RemoveConnectionTerminationDetails);
          }
          if (RemoveResponseFlags != false) {
            output.WriteRawTag(24);
            output.WriteBool(RemoveResponseFlags);
          }
          if (SetRecommendedResponseCode != false) {
            output.WriteRawTag(32);
            output.WriteBool(SetRecommendedResponseCode);
          }
          if (proxyNameCase_ == ProxyNameOneofCase.UseNodeId) {
            output.WriteRawTag(40);
            output.WriteBool(UseNodeId);
          }
          if (proxyNameCase_ == ProxyNameOneofCase.LiteralProxyName) {
            output.WriteRawTag(50);
            output.WriteString(LiteralProxyName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (RemoveDetails != false) {
            size += 1 + 1;
          }
          if (RemoveConnectionTerminationDetails != false) {
            size += 1 + 1;
          }
          if (RemoveResponseFlags != false) {
            size += 1 + 1;
          }
          if (SetRecommendedResponseCode != false) {
            size += 1 + 1;
          }
          if (proxyNameCase_ == ProxyNameOneofCase.UseNodeId) {
            size += 1 + 1;
          }
          if (proxyNameCase_ == ProxyNameOneofCase.LiteralProxyName) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(LiteralProxyName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ProxyStatusConfig other) {
          if (other == null) {
            return;
          }
          if (other.RemoveDetails != false) {
            RemoveDetails = other.RemoveDetails;
          }
          if (other.RemoveConnectionTerminationDetails != false) {
            RemoveConnectionTerminationDetails = other.RemoveConnectionTerminationDetails;
          }
          if (other.RemoveResponseFlags != false) {
            RemoveResponseFlags = other.RemoveResponseFlags;
          }
          if (other.SetRecommendedResponseCode != false) {
            SetRecommendedResponseCode = other.SetRecommendedResponseCode;
          }
          switch (other.ProxyNameCase) {
            case ProxyNameOneofCase.UseNodeId:
              UseNodeId = other.UseNodeId;
              break;
            case ProxyNameOneofCase.LiteralProxyName:
              LiteralProxyName = other.LiteralProxyName;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                RemoveDetails = input.ReadBool();
                break;
              }
              case 16: {
                RemoveConnectionTerminationDetails = input.ReadBool();
                break;
              }
              case 24: {
                RemoveResponseFlags = input.ReadBool();
                break;
              }
              case 32: {
                SetRecommendedResponseCode = input.ReadBool();
                break;
              }
              case 40: {
                UseNodeId = input.ReadBool();
                break;
              }
              case 50: {
                LiteralProxyName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                RemoveDetails = input.ReadBool();
                break;
              }
              case 16: {
                RemoveConnectionTerminationDetails = input.ReadBool();
                break;
              }
              case 24: {
                RemoveResponseFlags = input.ReadBool();
                break;
              }
              case 32: {
                SetRecommendedResponseCode = input.ReadBool();
                break;
              }
              case 40: {
                UseNodeId = input.ReadBool();
                break;
              }
              case 50: {
                LiteralProxyName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// The configuration to customize local reply returned by Envoy.
  /// </summary>
  public sealed partial class LocalReplyConfig : pb::IMessage<LocalReplyConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LocalReplyConfig> _parser = new pb::MessageParser<LocalReplyConfig>(() => new LocalReplyConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LocalReplyConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalReplyConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalReplyConfig(LocalReplyConfig other) : this() {
      mappers_ = other.mappers_.Clone();
      bodyFormat_ = other.bodyFormat_ != null ? other.bodyFormat_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalReplyConfig Clone() {
      return new LocalReplyConfig(this);
    }

    /// <summary>Field number for the "mappers" field.</summary>
    public const int MappersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper> _repeated_mappers_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper> mappers_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper>();
    /// <summary>
    /// Configuration of list of mappers which allows to filter and change local response.
    /// The mappers will be checked by the specified order until one is matched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ResponseMapper> Mappers {
      get { return mappers_; }
    }

    /// <summary>Field number for the "body_format" field.</summary>
    public const int BodyFormatFieldNumber = 2;
    private global::Envoy.Config.Core.V3.SubstitutionFormatString bodyFormat_;
    /// <summary>
    /// The configuration to form response body from the :ref:`command operators &lt;config_access_log_command_operators>`
    /// and to specify response content type as one of: plain/text or application/json.
    ///
    /// Example one: "plain/text" ``body_format``.
    ///
    /// .. validated-code-block:: yaml
    ///   :type-name: envoy.config.core.v3.SubstitutionFormatString
    ///
    ///   text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
    ///
    /// The following response body in "plain/text" format will be generated for a request with
    /// local reply body of "upstream connection error", response_code=503 and path=/foo.
    ///
    /// .. code-block:: text
    ///
    ///   upstream connect error:503:path=/foo
    ///
    /// Example two: "application/json" ``body_format``.
    ///
    /// .. validated-code-block:: yaml
    ///   :type-name: envoy.config.core.v3.SubstitutionFormatString
    ///
    ///   json_format:
    ///     status: "%RESPONSE_CODE%"
    ///     message: "%LOCAL_REPLY_BODY%"
    ///     path: "%REQ(:path)%"
    ///
    /// The following response body in "application/json" format would be generated for a request with
    /// local reply body of "upstream connection error", response_code=503 and path=/foo.
    ///
    /// .. code-block:: json
    ///
    ///  {
    ///    "status": 503,
    ///    "message": "upstream connection error",
    ///    "path": "/foo"
    ///  }
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SubstitutionFormatString BodyFormat {
      get { return bodyFormat_; }
      set {
        bodyFormat_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LocalReplyConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LocalReplyConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!mappers_.Equals(other.mappers_)) return false;
      if (!object.Equals(BodyFormat, other.BodyFormat)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= mappers_.GetHashCode();
      if (bodyFormat_ != null) hash ^= BodyFormat.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      mappers_.WriteTo(output, _repeated_mappers_codec);
      if (bodyFormat_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BodyFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      mappers_.WriteTo(ref output, _repeated_mappers_codec);
      if (bodyFormat_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BodyFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += mappers_.CalculateSize(_repeated_mappers_codec);
      if (bodyFormat_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BodyFormat);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LocalReplyConfig other) {
      if (other == null) {
        return;
      }
      mappers_.Add(other.mappers_);
      if (other.bodyFormat_ != null) {
        if (bodyFormat_ == null) {
          BodyFormat = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
        }
        BodyFormat.MergeFrom(other.BodyFormat);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            mappers_.AddEntriesFrom(input, _repeated_mappers_codec);
            break;
          }
          case 18: {
            if (bodyFormat_ == null) {
              BodyFormat = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
            }
            input.ReadMessage(BodyFormat);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            mappers_.AddEntriesFrom(ref input, _repeated_mappers_codec);
            break;
          }
          case 18: {
            if (bodyFormat_ == null) {
              BodyFormat = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
            }
            input.ReadMessage(BodyFormat);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The configuration to filter and change local response.
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class ResponseMapper : pb::IMessage<ResponseMapper>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResponseMapper> _parser = new pb::MessageParser<ResponseMapper>(() => new ResponseMapper());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResponseMapper> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResponseMapper() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResponseMapper(ResponseMapper other) : this() {
      filter_ = other.filter_ != null ? other.filter_.Clone() : null;
      StatusCode = other.StatusCode;
      body_ = other.body_ != null ? other.body_.Clone() : null;
      bodyFormatOverride_ = other.bodyFormatOverride_ != null ? other.bodyFormatOverride_.Clone() : null;
      headersToAdd_ = other.headersToAdd_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResponseMapper Clone() {
      return new ResponseMapper(this);
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 1;
    private global::Envoy.Config.Accesslog.V3.AccessLogFilter filter_;
    /// <summary>
    /// Filter to determine if this mapper should apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Accesslog.V3.AccessLogFilter Filter {
      get { return filter_; }
      set {
        filter_ = value;
      }
    }

    /// <summary>Field number for the "status_code" field.</summary>
    public const int StatusCodeFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_statusCode_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? statusCode_;
    /// <summary>
    /// The new response status code if specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? StatusCode {
      get { return statusCode_; }
      set {
        statusCode_ = value;
      }
    }


    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 3;
    private global::Envoy.Config.Core.V3.DataSource body_;
    /// <summary>
    /// The new local reply body text if specified. It will be used in the ``%LOCAL_REPLY_BODY%``
    /// command operator in the ``body_format``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource Body {
      get { return body_; }
      set {
        body_ = value;
      }
    }

    /// <summary>Field number for the "body_format_override" field.</summary>
    public const int BodyFormatOverrideFieldNumber = 4;
    private global::Envoy.Config.Core.V3.SubstitutionFormatString bodyFormatOverride_;
    /// <summary>
    /// A per mapper ``body_format`` to override the :ref:`body_format &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.body_format>`.
    /// It will be used when this mapper is matched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SubstitutionFormatString BodyFormatOverride {
      get { return bodyFormatOverride_; }
      set {
        bodyFormatOverride_ = value;
      }
    }

    /// <summary>Field number for the "headers_to_add" field.</summary>
    public const int HeadersToAddFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_headersToAdd_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> headersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
    /// <summary>
    /// HTTP headers to add to a local reply. This allows the response mapper to append, to add
    /// or to override headers of any local reply before it is sent to a downstream client.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> HeadersToAdd {
      get { return headersToAdd_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResponseMapper);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResponseMapper other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Filter, other.Filter)) return false;
      if (StatusCode != other.StatusCode) return false;
      if (!object.Equals(Body, other.Body)) return false;
      if (!object.Equals(BodyFormatOverride, other.BodyFormatOverride)) return false;
      if(!headersToAdd_.Equals(other.headersToAdd_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (filter_ != null) hash ^= Filter.GetHashCode();
      if (statusCode_ != null) hash ^= StatusCode.GetHashCode();
      if (body_ != null) hash ^= Body.GetHashCode();
      if (bodyFormatOverride_ != null) hash ^= BodyFormatOverride.GetHashCode();
      hash ^= headersToAdd_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (filter_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Filter);
      }
      if (statusCode_ != null) {
        _single_statusCode_codec.WriteTagAndValue(output, StatusCode);
      }
      if (body_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Body);
      }
      if (bodyFormatOverride_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BodyFormatOverride);
      }
      headersToAdd_.WriteTo(output, _repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (filter_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Filter);
      }
      if (statusCode_ != null) {
        _single_statusCode_codec.WriteTagAndValue(ref output, StatusCode);
      }
      if (body_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Body);
      }
      if (bodyFormatOverride_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BodyFormatOverride);
      }
      headersToAdd_.WriteTo(ref output, _repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (filter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Filter);
      }
      if (statusCode_ != null) {
        size += _single_statusCode_codec.CalculateSizeWithTag(StatusCode);
      }
      if (body_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Body);
      }
      if (bodyFormatOverride_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BodyFormatOverride);
      }
      size += headersToAdd_.CalculateSize(_repeated_headersToAdd_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResponseMapper other) {
      if (other == null) {
        return;
      }
      if (other.filter_ != null) {
        if (filter_ == null) {
          Filter = new global::Envoy.Config.Accesslog.V3.AccessLogFilter();
        }
        Filter.MergeFrom(other.Filter);
      }
      if (other.statusCode_ != null) {
        if (statusCode_ == null || other.StatusCode != 0) {
          StatusCode = other.StatusCode;
        }
      }
      if (other.body_ != null) {
        if (body_ == null) {
          Body = new global::Envoy.Config.Core.V3.DataSource();
        }
        Body.MergeFrom(other.Body);
      }
      if (other.bodyFormatOverride_ != null) {
        if (bodyFormatOverride_ == null) {
          BodyFormatOverride = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
        }
        BodyFormatOverride.MergeFrom(other.BodyFormatOverride);
      }
      headersToAdd_.Add(other.headersToAdd_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (filter_ == null) {
              Filter = new global::Envoy.Config.Accesslog.V3.AccessLogFilter();
            }
            input.ReadMessage(Filter);
            break;
          }
          case 18: {
            uint? value = _single_statusCode_codec.Read(input);
            if (statusCode_ == null || value != 0) {
              StatusCode = value;
            }
            break;
          }
          case 26: {
            if (body_ == null) {
              Body = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Body);
            break;
          }
          case 34: {
            if (bodyFormatOverride_ == null) {
              BodyFormatOverride = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
            }
            input.ReadMessage(BodyFormatOverride);
            break;
          }
          case 42: {
            headersToAdd_.AddEntriesFrom(input, _repeated_headersToAdd_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (filter_ == null) {
              Filter = new global::Envoy.Config.Accesslog.V3.AccessLogFilter();
            }
            input.ReadMessage(Filter);
            break;
          }
          case 18: {
            uint? value = _single_statusCode_codec.Read(ref input);
            if (statusCode_ == null || value != 0) {
              StatusCode = value;
            }
            break;
          }
          case 26: {
            if (body_ == null) {
              Body = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Body);
            break;
          }
          case 34: {
            if (bodyFormatOverride_ == null) {
              BodyFormatOverride = new global::Envoy.Config.Core.V3.SubstitutionFormatString();
            }
            input.ReadMessage(BodyFormatOverride);
            break;
          }
          case 42: {
            headersToAdd_.AddEntriesFrom(ref input, _repeated_headersToAdd_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Rds : pb::IMessage<Rds>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Rds> _parser = new pb::MessageParser<Rds>(() => new Rds());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Rds> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Rds() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Rds(Rds other) : this() {
      configSource_ = other.configSource_ != null ? other.configSource_.Clone() : null;
      routeConfigName_ = other.routeConfigName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Rds Clone() {
      return new Rds(this);
    }

    /// <summary>Field number for the "config_source" field.</summary>
    public const int ConfigSourceFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ConfigSource configSource_;
    /// <summary>
    /// Configuration source specifier for RDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ConfigSource ConfigSource {
      get { return configSource_; }
      set {
        configSource_ = value;
      }
    }

    /// <summary>Field number for the "route_config_name" field.</summary>
    public const int RouteConfigNameFieldNumber = 2;
    private string routeConfigName_ = "";
    /// <summary>
    /// The name of the route configuration. This name will be passed to the RDS
    /// API. This allows an Envoy configuration with multiple HTTP listeners (and
    /// associated HTTP connection manager filters) to use different route
    /// configurations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RouteConfigName {
      get { return routeConfigName_; }
      set {
        routeConfigName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Rds);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Rds other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConfigSource, other.ConfigSource)) return false;
      if (RouteConfigName != other.RouteConfigName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (configSource_ != null) hash ^= ConfigSource.GetHashCode();
      if (RouteConfigName.Length != 0) hash ^= RouteConfigName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RouteConfigName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RouteConfigName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (configSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteConfigName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Rds other) {
      if (other == null) {
        return;
      }
      if (other.configSource_ != null) {
        if (configSource_ == null) {
          ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
        }
        ConfigSource.MergeFrom(other.ConfigSource);
      }
      if (other.RouteConfigName.Length != 0) {
        RouteConfigName = other.RouteConfigName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (configSource_ == null) {
              ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 18: {
            RouteConfigName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (configSource_ == null) {
              ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 18: {
            RouteConfigName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// This message is used to work around the limitations with 'oneof' and repeated fields.
  /// </summary>
  public sealed partial class ScopedRouteConfigurationsList : pb::IMessage<ScopedRouteConfigurationsList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopedRouteConfigurationsList> _parser = new pb::MessageParser<ScopedRouteConfigurationsList>(() => new ScopedRouteConfigurationsList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopedRouteConfigurationsList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRouteConfigurationsList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRouteConfigurationsList(ScopedRouteConfigurationsList other) : this() {
      scopedRouteConfigurations_ = other.scopedRouteConfigurations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRouteConfigurationsList Clone() {
      return new ScopedRouteConfigurationsList(this);
    }

    /// <summary>Field number for the "scoped_route_configurations" field.</summary>
    public const int ScopedRouteConfigurationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.ScopedRouteConfiguration> _repeated_scopedRouteConfigurations_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Route.V3.ScopedRouteConfiguration.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.ScopedRouteConfiguration> scopedRouteConfigurations_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.ScopedRouteConfiguration>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.ScopedRouteConfiguration> ScopedRouteConfigurations {
      get { return scopedRouteConfigurations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopedRouteConfigurationsList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopedRouteConfigurationsList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!scopedRouteConfigurations_.Equals(other.scopedRouteConfigurations_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= scopedRouteConfigurations_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      scopedRouteConfigurations_.WriteTo(output, _repeated_scopedRouteConfigurations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      scopedRouteConfigurations_.WriteTo(ref output, _repeated_scopedRouteConfigurations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += scopedRouteConfigurations_.CalculateSize(_repeated_scopedRouteConfigurations_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopedRouteConfigurationsList other) {
      if (other == null) {
        return;
      }
      scopedRouteConfigurations_.Add(other.scopedRouteConfigurations_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            scopedRouteConfigurations_.AddEntriesFrom(input, _repeated_scopedRouteConfigurations_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            scopedRouteConfigurations_.AddEntriesFrom(ref input, _repeated_scopedRouteConfigurations_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class ScopedRoutes : pb::IMessage<ScopedRoutes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopedRoutes> _parser = new pb::MessageParser<ScopedRoutes>(() => new ScopedRoutes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopedRoutes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRoutes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRoutes(ScopedRoutes other) : this() {
      name_ = other.name_;
      scopeKeyBuilder_ = other.scopeKeyBuilder_ != null ? other.scopeKeyBuilder_.Clone() : null;
      rdsConfigSource_ = other.rdsConfigSource_ != null ? other.rdsConfigSource_.Clone() : null;
      switch (other.ConfigSpecifierCase) {
        case ConfigSpecifierOneofCase.ScopedRouteConfigurationsList:
          ScopedRouteConfigurationsList = other.ScopedRouteConfigurationsList.Clone();
          break;
        case ConfigSpecifierOneofCase.ScopedRds:
          ScopedRds = other.ScopedRds.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRoutes Clone() {
      return new ScopedRoutes(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name assigned to the scoped routing configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "scope_key_builder" field.</summary>
    public const int ScopeKeyBuilderFieldNumber = 2;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder scopeKeyBuilder_;
    /// <summary>
    /// The algorithm to use for constructing a scope key for each request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder ScopeKeyBuilder {
      get { return scopeKeyBuilder_; }
      set {
        scopeKeyBuilder_ = value;
      }
    }

    /// <summary>Field number for the "rds_config_source" field.</summary>
    public const int RdsConfigSourceFieldNumber = 3;
    private global::Envoy.Config.Core.V3.ConfigSource rdsConfigSource_;
    /// <summary>
    /// Configuration source specifier for RDS.
    /// This config source is used to subscribe to RouteConfiguration resources specified in
    /// ScopedRouteConfiguration messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ConfigSource RdsConfigSource {
      get { return rdsConfigSource_; }
      set {
        rdsConfigSource_ = value;
      }
    }

    /// <summary>Field number for the "scoped_route_configurations_list" field.</summary>
    public const int ScopedRouteConfigurationsListFieldNumber = 4;
    /// <summary>
    /// The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
    /// matching a key constructed from the request's attributes according to the algorithm specified
    /// by the
    /// :ref:`ScopeKeyBuilder&lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList ScopedRouteConfigurationsList {
      get { return configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList) configSpecifier_ : null; }
      set {
        configSpecifier_ = value;
        configSpecifierCase_ = value == null ? ConfigSpecifierOneofCase.None : ConfigSpecifierOneofCase.ScopedRouteConfigurationsList;
      }
    }

    /// <summary>Field number for the "scoped_rds" field.</summary>
    public const int ScopedRdsFieldNumber = 5;
    /// <summary>
    /// The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
    /// API. A scope is assigned to a request by matching a key constructed from the request's
    /// attributes according to the algorithm specified by the
    /// :ref:`ScopeKeyBuilder&lt;envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds ScopedRds {
      get { return configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds) configSpecifier_ : null; }
      set {
        configSpecifier_ = value;
        configSpecifierCase_ = value == null ? ConfigSpecifierOneofCase.None : ConfigSpecifierOneofCase.ScopedRds;
      }
    }

    private object configSpecifier_;
    /// <summary>Enum of possible cases for the "config_specifier" oneof.</summary>
    public enum ConfigSpecifierOneofCase {
      None = 0,
      ScopedRouteConfigurationsList = 4,
      ScopedRds = 5,
    }
    private ConfigSpecifierOneofCase configSpecifierCase_ = ConfigSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSpecifierOneofCase ConfigSpecifierCase {
      get { return configSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigSpecifier() {
      configSpecifierCase_ = ConfigSpecifierOneofCase.None;
      configSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopedRoutes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopedRoutes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(ScopeKeyBuilder, other.ScopeKeyBuilder)) return false;
      if (!object.Equals(RdsConfigSource, other.RdsConfigSource)) return false;
      if (!object.Equals(ScopedRouteConfigurationsList, other.ScopedRouteConfigurationsList)) return false;
      if (!object.Equals(ScopedRds, other.ScopedRds)) return false;
      if (ConfigSpecifierCase != other.ConfigSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (scopeKeyBuilder_ != null) hash ^= ScopeKeyBuilder.GetHashCode();
      if (rdsConfigSource_ != null) hash ^= RdsConfigSource.GetHashCode();
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) hash ^= ScopedRouteConfigurationsList.GetHashCode();
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) hash ^= ScopedRds.GetHashCode();
      hash ^= (int) configSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (scopeKeyBuilder_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ScopeKeyBuilder);
      }
      if (rdsConfigSource_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RdsConfigSource);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
        output.WriteRawTag(34);
        output.WriteMessage(ScopedRouteConfigurationsList);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
        output.WriteRawTag(42);
        output.WriteMessage(ScopedRds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (scopeKeyBuilder_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ScopeKeyBuilder);
      }
      if (rdsConfigSource_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RdsConfigSource);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
        output.WriteRawTag(34);
        output.WriteMessage(ScopedRouteConfigurationsList);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
        output.WriteRawTag(42);
        output.WriteMessage(ScopedRds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (scopeKeyBuilder_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopeKeyBuilder);
      }
      if (rdsConfigSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RdsConfigSource);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRouteConfigurationsList);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRds);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopedRoutes other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.scopeKeyBuilder_ != null) {
        if (scopeKeyBuilder_ == null) {
          ScopeKeyBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder();
        }
        ScopeKeyBuilder.MergeFrom(other.ScopeKeyBuilder);
      }
      if (other.rdsConfigSource_ != null) {
        if (rdsConfigSource_ == null) {
          RdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
        }
        RdsConfigSource.MergeFrom(other.RdsConfigSource);
      }
      switch (other.ConfigSpecifierCase) {
        case ConfigSpecifierOneofCase.ScopedRouteConfigurationsList:
          if (ScopedRouteConfigurationsList == null) {
            ScopedRouteConfigurationsList = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList();
          }
          ScopedRouteConfigurationsList.MergeFrom(other.ScopedRouteConfigurationsList);
          break;
        case ConfigSpecifierOneofCase.ScopedRds:
          if (ScopedRds == null) {
            ScopedRds = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds();
          }
          ScopedRds.MergeFrom(other.ScopedRds);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (scopeKeyBuilder_ == null) {
              ScopeKeyBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder();
            }
            input.ReadMessage(ScopeKeyBuilder);
            break;
          }
          case 26: {
            if (rdsConfigSource_ == null) {
              RdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(RdsConfigSource);
            break;
          }
          case 34: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
              subBuilder.MergeFrom(ScopedRouteConfigurationsList);
            }
            input.ReadMessage(subBuilder);
            ScopedRouteConfigurationsList = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
              subBuilder.MergeFrom(ScopedRds);
            }
            input.ReadMessage(subBuilder);
            ScopedRds = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (scopeKeyBuilder_ == null) {
              ScopeKeyBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder();
            }
            input.ReadMessage(ScopeKeyBuilder);
            break;
          }
          case 26: {
            if (rdsConfigSource_ == null) {
              RdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(RdsConfigSource);
            break;
          }
          case 34: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRouteConfigurationsList();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
              subBuilder.MergeFrom(ScopedRouteConfigurationsList);
            }
            input.ReadMessage(subBuilder);
            ScopedRouteConfigurationsList = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRds();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
              subBuilder.MergeFrom(ScopedRds);
            }
            input.ReadMessage(subBuilder);
            ScopedRds = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ScopedRoutes message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
      /// keys are matched against a set of :ref:`Key&lt;envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>`
      /// objects assembled from :ref:`ScopedRouteConfiguration&lt;envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`
      /// messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
      /// :ref:`scoped_route_configurations_list&lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`.
      ///
      /// Upon receiving a request's headers, the Router will build a key using the algorithm specified
      /// by this message. This key will be used to look up the routing table (i.e., the
      /// :ref:`RouteConfiguration&lt;envoy_v3_api_msg_config.route.v3.RouteConfiguration>`) to use for the request.
      /// </summary>
      public sealed partial class ScopeKeyBuilder : pb::IMessage<ScopeKeyBuilder>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ScopeKeyBuilder> _parser = new pb::MessageParser<ScopeKeyBuilder>(() => new ScopeKeyBuilder());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ScopeKeyBuilder> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ScopeKeyBuilder() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ScopeKeyBuilder(ScopeKeyBuilder other) : this() {
          fragments_ = other.fragments_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ScopeKeyBuilder Clone() {
          return new ScopeKeyBuilder(this);
        }

        /// <summary>Field number for the "fragments" field.</summary>
        public const int FragmentsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> _repeated_fragments_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> fragments_ = new pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder>();
        /// <summary>
        /// The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
        /// fragments of a :ref:`ScopedRouteConfiguration&lt;envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`.
        /// A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> Fragments {
          get { return fragments_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ScopeKeyBuilder);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ScopeKeyBuilder other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!fragments_.Equals(other.fragments_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= fragments_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          fragments_.WriteTo(output, _repeated_fragments_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          fragments_.WriteTo(ref output, _repeated_fragments_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += fragments_.CalculateSize(_repeated_fragments_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ScopeKeyBuilder other) {
          if (other == null) {
            return;
          }
          fragments_.Add(other.fragments_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                fragments_.AddEntriesFrom(input, _repeated_fragments_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                fragments_.AddEntriesFrom(ref input, _repeated_fragments_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ScopeKeyBuilder message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Specifies the mechanism for constructing key fragments which are composed into scope keys.
          /// </summary>
          public sealed partial class FragmentBuilder : pb::IMessage<FragmentBuilder>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<FragmentBuilder> _parser = new pb::MessageParser<FragmentBuilder>(() => new FragmentBuilder());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<FragmentBuilder> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FragmentBuilder() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FragmentBuilder(FragmentBuilder other) : this() {
              switch (other.TypeCase) {
                case TypeOneofCase.HeaderValueExtractor:
                  HeaderValueExtractor = other.HeaderValueExtractor.Clone();
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FragmentBuilder Clone() {
              return new FragmentBuilder(this);
            }

            /// <summary>Field number for the "header_value_extractor" field.</summary>
            public const int HeaderValueExtractorFieldNumber = 1;
            /// <summary>
            /// Specifies how a header field's value should be extracted.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor HeaderValueExtractor {
              get { return typeCase_ == TypeOneofCase.HeaderValueExtractor ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor) type_ : null; }
              set {
                type_ = value;
                typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.HeaderValueExtractor;
              }
            }

            private object type_;
            /// <summary>Enum of possible cases for the "type" oneof.</summary>
            public enum TypeOneofCase {
              None = 0,
              HeaderValueExtractor = 1,
            }
            private TypeOneofCase typeCase_ = TypeOneofCase.None;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public TypeOneofCase TypeCase {
              get { return typeCase_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearType() {
              typeCase_ = TypeOneofCase.None;
              type_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as FragmentBuilder);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(FragmentBuilder other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(HeaderValueExtractor, other.HeaderValueExtractor)) return false;
              if (TypeCase != other.TypeCase) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) hash ^= HeaderValueExtractor.GetHashCode();
              hash ^= (int) typeCase_;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                output.WriteRawTag(10);
                output.WriteMessage(HeaderValueExtractor);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                output.WriteRawTag(10);
                output.WriteMessage(HeaderValueExtractor);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderValueExtractor);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(FragmentBuilder other) {
              if (other == null) {
                return;
              }
              switch (other.TypeCase) {
                case TypeOneofCase.HeaderValueExtractor:
                  if (HeaderValueExtractor == null) {
                    HeaderValueExtractor = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor();
                  }
                  HeaderValueExtractor.MergeFrom(other.HeaderValueExtractor);
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor();
                    if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                      subBuilder.MergeFrom(HeaderValueExtractor);
                    }
                    input.ReadMessage(subBuilder);
                    HeaderValueExtractor = subBuilder;
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor();
                    if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                      subBuilder.MergeFrom(HeaderValueExtractor);
                    }
                    input.ReadMessage(subBuilder);
                    HeaderValueExtractor = subBuilder;
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the FragmentBuilder message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Specifies how the value of a header should be extracted.
              /// The following example maps the structure of a header to the fields in this message.
              ///
              /// .. code::
              ///
              ///              &lt;0> &lt;1>   &lt;-- index
              ///    X-Header: a=b;c=d
              ///    |         || |
              ///    |         || \----> &lt;element_separator>
              ///    |         ||
              ///    |         |\----> &lt;element.separator>
              ///    |         |
              ///    |         \----> &lt;element.key>
              ///    |
              ///    \----> &lt;name>
              ///
              ///    Each 'a=b' key-value pair constitutes an 'element' of the header field.
              /// </summary>
              public sealed partial class HeaderValueExtractor : pb::IMessage<HeaderValueExtractor>
              #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  , pb::IBufferMessage
              #endif
              {
                private static readonly pb::MessageParser<HeaderValueExtractor> _parser = new pb::MessageParser<HeaderValueExtractor>(() => new HeaderValueExtractor());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<HeaderValueExtractor> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public HeaderValueExtractor() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public HeaderValueExtractor(HeaderValueExtractor other) : this() {
                  name_ = other.name_;
                  elementSeparator_ = other.elementSeparator_;
                  switch (other.ExtractTypeCase) {
                    case ExtractTypeOneofCase.Index:
                      Index = other.Index;
                      break;
                    case ExtractTypeOneofCase.Element:
                      Element = other.Element.Clone();
                      break;
                  }

                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public HeaderValueExtractor Clone() {
                  return new HeaderValueExtractor(this);
                }

                /// <summary>Field number for the "name" field.</summary>
                public const int NameFieldNumber = 1;
                private string name_ = "";
                /// <summary>
                /// The name of the header field to extract the value from.
                ///
                /// .. note::
                ///
                ///   If the header appears multiple times only the first value is used.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public string Name {
                  get { return name_; }
                  set {
                    name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                  }
                }

                /// <summary>Field number for the "element_separator" field.</summary>
                public const int ElementSeparatorFieldNumber = 2;
                private string elementSeparator_ = "";
                /// <summary>
                /// The element separator (e.g., ';' separates 'a;b;c;d').
                /// Default: empty string. This causes the entirety of the header field to be extracted.
                /// If this field is set to an empty string and 'index' is used in the oneof below, 'index'
                /// must be set to 0.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public string ElementSeparator {
                  get { return elementSeparator_; }
                  set {
                    elementSeparator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                  }
                }

                /// <summary>Field number for the "index" field.</summary>
                public const int IndexFieldNumber = 3;
                /// <summary>
                /// Specifies the zero based index of the element to extract.
                /// Note Envoy concatenates multiple values of the same header key into a comma separated
                /// string, the splitting always happens after the concatenation.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public uint Index {
                  get { return extractTypeCase_ == ExtractTypeOneofCase.Index ? (uint) extractType_ : 0; }
                  set {
                    extractType_ = value;
                    extractTypeCase_ = ExtractTypeOneofCase.Index;
                  }
                }

                /// <summary>Field number for the "element" field.</summary>
                public const int ElementFieldNumber = 4;
                /// <summary>
                /// Specifies the key value pair to extract the value from.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement Element {
                  get { return extractTypeCase_ == ExtractTypeOneofCase.Element ? (global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement) extractType_ : null; }
                  set {
                    extractType_ = value;
                    extractTypeCase_ = value == null ? ExtractTypeOneofCase.None : ExtractTypeOneofCase.Element;
                  }
                }

                private object extractType_;
                /// <summary>Enum of possible cases for the "extract_type" oneof.</summary>
                public enum ExtractTypeOneofCase {
                  None = 0,
                  Index = 3,
                  Element = 4,
                }
                private ExtractTypeOneofCase extractTypeCase_ = ExtractTypeOneofCase.None;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public ExtractTypeOneofCase ExtractTypeCase {
                  get { return extractTypeCase_; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void ClearExtractType() {
                  extractTypeCase_ = ExtractTypeOneofCase.None;
                  extractType_ = null;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other) {
                  return Equals(other as HeaderValueExtractor);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(HeaderValueExtractor other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (Name != other.Name) return false;
                  if (ElementSeparator != other.ElementSeparator) return false;
                  if (Index != other.Index) return false;
                  if (!object.Equals(Element, other.Element)) return false;
                  if (ExtractTypeCase != other.ExtractTypeCase) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode() {
                  int hash = 1;
                  if (Name.Length != 0) hash ^= Name.GetHashCode();
                  if (ElementSeparator.Length != 0) hash ^= ElementSeparator.GetHashCode();
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) hash ^= Index.GetHashCode();
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) hash ^= Element.GetHashCode();
                  hash ^= (int) extractTypeCase_;
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  output.WriteRawMessage(this);
                #else
                  if (Name.Length != 0) {
                    output.WriteRawTag(10);
                    output.WriteString(Name);
                  }
                  if (ElementSeparator.Length != 0) {
                    output.WriteRawTag(18);
                    output.WriteString(ElementSeparator);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) {
                    output.WriteRawTag(24);
                    output.WriteUInt32(Index);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                    output.WriteRawTag(34);
                    output.WriteMessage(Element);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                  if (Name.Length != 0) {
                    output.WriteRawTag(10);
                    output.WriteString(Name);
                  }
                  if (ElementSeparator.Length != 0) {
                    output.WriteRawTag(18);
                    output.WriteString(ElementSeparator);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) {
                    output.WriteRawTag(24);
                    output.WriteUInt32(Index);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                    output.WriteRawTag(34);
                    output.WriteMessage(Element);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(ref output);
                  }
                }
                #endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize() {
                  int size = 0;
                  if (Name.Length != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
                  }
                  if (ElementSeparator.Length != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeStringSize(ElementSeparator);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) {
                    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                    size += 1 + pb::CodedOutputStream.ComputeMessageSize(Element);
                  }
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(HeaderValueExtractor other) {
                  if (other == null) {
                    return;
                  }
                  if (other.Name.Length != 0) {
                    Name = other.Name;
                  }
                  if (other.ElementSeparator.Length != 0) {
                    ElementSeparator = other.ElementSeparator;
                  }
                  switch (other.ExtractTypeCase) {
                    case ExtractTypeOneofCase.Index:
                      Index = other.Index;
                      break;
                    case ExtractTypeOneofCase.Element:
                      if (Element == null) {
                        Element = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement();
                      }
                      Element.MergeFrom(other.Element);
                      break;
                  }

                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  input.ReadRawMessage(this);
                #else
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 10: {
                        Name = input.ReadString();
                        break;
                      }
                      case 18: {
                        ElementSeparator = input.ReadString();
                        break;
                      }
                      case 24: {
                        Index = input.ReadUInt32();
                        break;
                      }
                      case 34: {
                        global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement();
                        if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                          subBuilder.MergeFrom(Element);
                        }
                        input.ReadMessage(subBuilder);
                        Element = subBuilder;
                        break;
                      }
                    }
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                      case 10: {
                        Name = input.ReadString();
                        break;
                      }
                      case 18: {
                        ElementSeparator = input.ReadString();
                        break;
                      }
                      case 24: {
                        Index = input.ReadUInt32();
                        break;
                      }
                      case 34: {
                        global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement subBuilder = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement();
                        if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                          subBuilder.MergeFrom(Element);
                        }
                        input.ReadMessage(subBuilder);
                        Element = subBuilder;
                        break;
                      }
                    }
                  }
                }
                #endif

                #region Nested types
                /// <summary>Container for nested types declared in the HeaderValueExtractor message type.</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static partial class Types {
                  /// <summary>
                  /// Specifies a header field's key value pair to match on.
                  /// </summary>
                  public sealed partial class KvElement : pb::IMessage<KvElement>
                  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                      , pb::IBufferMessage
                  #endif
                  {
                    private static readonly pb::MessageParser<KvElement> _parser = new pb::MessageParser<KvElement>(() => new KvElement());
                    private pb::UnknownFieldSet _unknownFields;
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public static pb::MessageParser<KvElement> Parser { get { return _parser; } }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public static pbr::MessageDescriptor Descriptor {
                      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Descriptor.NestedTypes[0]; }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    pbr::MessageDescriptor pb::IMessage.Descriptor {
                      get { return Descriptor; }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public KvElement() {
                      OnConstruction();
                    }

                    partial void OnConstruction();

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public KvElement(KvElement other) : this() {
                      separator_ = other.separator_;
                      key_ = other.key_;
                      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public KvElement Clone() {
                      return new KvElement(this);
                    }

                    /// <summary>Field number for the "separator" field.</summary>
                    public const int SeparatorFieldNumber = 1;
                    private string separator_ = "";
                    /// <summary>
                    /// The separator between key and value (e.g., '=' separates 'k=v;...').
                    /// If an element is an empty string, the element is ignored.
                    /// If an element contains no separator, the whole element is parsed as key and the
                    /// fragment value is an empty string.
                    /// If there are multiple values for a matched key, the first value is returned.
                    /// </summary>
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public string Separator {
                      get { return separator_; }
                      set {
                        separator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                      }
                    }

                    /// <summary>Field number for the "key" field.</summary>
                    public const int KeyFieldNumber = 2;
                    private string key_ = "";
                    /// <summary>
                    /// The key to match on.
                    /// </summary>
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public string Key {
                      get { return key_; }
                      set {
                        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                      }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public override bool Equals(object other) {
                      return Equals(other as KvElement);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public bool Equals(KvElement other) {
                      if (ReferenceEquals(other, null)) {
                        return false;
                      }
                      if (ReferenceEquals(other, this)) {
                        return true;
                      }
                      if (Separator != other.Separator) return false;
                      if (Key != other.Key) return false;
                      return Equals(_unknownFields, other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public override int GetHashCode() {
                      int hash = 1;
                      if (Separator.Length != 0) hash ^= Separator.GetHashCode();
                      if (Key.Length != 0) hash ^= Key.GetHashCode();
                      if (_unknownFields != null) {
                        hash ^= _unknownFields.GetHashCode();
                      }
                      return hash;
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public override string ToString() {
                      return pb::JsonFormatter.ToDiagnosticString(this);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public void WriteTo(pb::CodedOutputStream output) {
                    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                      output.WriteRawMessage(this);
                    #else
                      if (Separator.Length != 0) {
                        output.WriteRawTag(10);
                        output.WriteString(Separator);
                      }
                      if (Key.Length != 0) {
                        output.WriteRawTag(18);
                        output.WriteString(Key);
                      }
                      if (_unknownFields != null) {
                        _unknownFields.WriteTo(output);
                      }
                    #endif
                    }

                    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                      if (Separator.Length != 0) {
                        output.WriteRawTag(10);
                        output.WriteString(Separator);
                      }
                      if (Key.Length != 0) {
                        output.WriteRawTag(18);
                        output.WriteString(Key);
                      }
                      if (_unknownFields != null) {
                        _unknownFields.WriteTo(ref output);
                      }
                    }
                    #endif

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public int CalculateSize() {
                      int size = 0;
                      if (Separator.Length != 0) {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Separator);
                      }
                      if (Key.Length != 0) {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
                      }
                      if (_unknownFields != null) {
                        size += _unknownFields.CalculateSize();
                      }
                      return size;
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public void MergeFrom(KvElement other) {
                      if (other == null) {
                        return;
                      }
                      if (other.Separator.Length != 0) {
                        Separator = other.Separator;
                      }
                      if (other.Key.Length != 0) {
                        Key = other.Key;
                      }
                      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    public void MergeFrom(pb::CodedInputStream input) {
                    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                      input.ReadRawMessage(this);
                    #else
                      uint tag;
                      while ((tag = input.ReadTag()) != 0) {
                        switch(tag) {
                          default:
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                            break;
                          case 10: {
                            Separator = input.ReadString();
                            break;
                          }
                          case 18: {
                            Key = input.ReadString();
                            break;
                          }
                        }
                      }
                    #endif
                    }

                    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                      uint tag;
                      while ((tag = input.ReadTag()) != 0) {
                        switch(tag) {
                          default:
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                            break;
                          case 10: {
                            Separator = input.ReadString();
                            break;
                          }
                          case 18: {
                            Key = input.ReadString();
                            break;
                          }
                        }
                      }
                    }
                    #endif

                  }

                }
                #endregion

              }

            }
            #endregion

          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class ScopedRds : pb::IMessage<ScopedRds>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopedRds> _parser = new pb::MessageParser<ScopedRds>(() => new ScopedRds());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopedRds> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRds() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRds(ScopedRds other) : this() {
      scopedRdsConfigSource_ = other.scopedRdsConfigSource_ != null ? other.scopedRdsConfigSource_.Clone() : null;
      srdsResourcesLocator_ = other.srdsResourcesLocator_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedRds Clone() {
      return new ScopedRds(this);
    }

    /// <summary>Field number for the "scoped_rds_config_source" field.</summary>
    public const int ScopedRdsConfigSourceFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ConfigSource scopedRdsConfigSource_;
    /// <summary>
    /// Configuration source specifier for scoped RDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ConfigSource ScopedRdsConfigSource {
      get { return scopedRdsConfigSource_; }
      set {
        scopedRdsConfigSource_ = value;
      }
    }

    /// <summary>Field number for the "srds_resources_locator" field.</summary>
    public const int SrdsResourcesLocatorFieldNumber = 2;
    private string srdsResourcesLocator_ = "";
    /// <summary>
    /// xdstp:// resource locator for scoped RDS collection.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SrdsResourcesLocator {
      get { return srdsResourcesLocator_; }
      set {
        srdsResourcesLocator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopedRds);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopedRds other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScopedRdsConfigSource, other.ScopedRdsConfigSource)) return false;
      if (SrdsResourcesLocator != other.SrdsResourcesLocator) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (scopedRdsConfigSource_ != null) hash ^= ScopedRdsConfigSource.GetHashCode();
      if (SrdsResourcesLocator.Length != 0) hash ^= SrdsResourcesLocator.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (scopedRdsConfigSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScopedRdsConfigSource);
      }
      if (SrdsResourcesLocator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(SrdsResourcesLocator);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (scopedRdsConfigSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScopedRdsConfigSource);
      }
      if (SrdsResourcesLocator.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(SrdsResourcesLocator);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (scopedRdsConfigSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRdsConfigSource);
      }
      if (SrdsResourcesLocator.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SrdsResourcesLocator);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopedRds other) {
      if (other == null) {
        return;
      }
      if (other.scopedRdsConfigSource_ != null) {
        if (scopedRdsConfigSource_ == null) {
          ScopedRdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
        }
        ScopedRdsConfigSource.MergeFrom(other.ScopedRdsConfigSource);
      }
      if (other.SrdsResourcesLocator.Length != 0) {
        SrdsResourcesLocator = other.SrdsResourcesLocator;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scopedRdsConfigSource_ == null) {
              ScopedRdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ScopedRdsConfigSource);
            break;
          }
          case 18: {
            SrdsResourcesLocator = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (scopedRdsConfigSource_ == null) {
              ScopedRdsConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ScopedRdsConfigSource);
            break;
          }
          case 18: {
            SrdsResourcesLocator = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class HttpFilter : pb::IMessage<HttpFilter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HttpFilter> _parser = new pb::MessageParser<HttpFilter>(() => new HttpFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HttpFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpFilter(HttpFilter other) : this() {
      name_ = other.name_;
      isOptional_ = other.isOptional_;
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.TypedConfig:
          TypedConfig = other.TypedConfig.Clone();
          break;
        case ConfigTypeOneofCase.ConfigDiscovery:
          ConfigDiscovery = other.ConfigDiscovery.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpFilter Clone() {
      return new HttpFilter(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the filter configuration. It also serves as a resource name in ExtensionConfigDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "typed_config" field.</summary>
    public const int TypedConfigFieldNumber = 4;
    /// <summary>
    /// Filter specific configuration which depends on the filter being instantiated. See the supported
    /// filters for further documentation.
    ///
    /// To support configuring a :ref:`match tree &lt;arch_overview_matching_api>`, use an
    /// :ref:`ExtensionWithMatcher &lt;envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
    /// with the desired HTTP filter.
    /// [#extension-category: envoy.filters.http]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
      get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
      set {
        configType_ = value;
        configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
      }
    }

    /// <summary>Field number for the "config_discovery" field.</summary>
    public const int ConfigDiscoveryFieldNumber = 5;
    /// <summary>
    /// Configuration source specifier for an extension configuration discovery service.
    /// In case of a failure and without the default configuration, the HTTP listener responds with code 500.
    /// Extension configs delivered through this mechanism are not expected to require warming (see https://github.com/envoyproxy/envoy/issues/12061).
    ///
    /// To support configuring a :ref:`match tree &lt;arch_overview_matching_api>`, use an
    /// :ref:`ExtensionWithMatcher &lt;envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
    /// with the desired HTTP filter. This works for both the default filter configuration as well
    /// as for filters provided via the API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ExtensionConfigSource ConfigDiscovery {
      get { return configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery ? (global::Envoy.Config.Core.V3.ExtensionConfigSource) configType_ : null; }
      set {
        configType_ = value;
        configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.ConfigDiscovery;
      }
    }

    /// <summary>Field number for the "is_optional" field.</summary>
    public const int IsOptionalFieldNumber = 6;
    private bool isOptional_;
    /// <summary>
    /// If true, clients that do not support this filter may ignore the
    /// filter but otherwise accept the config.
    /// Otherwise, clients that do not support this filter must reject the config.
    /// This is also same with typed per filter config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsOptional {
      get { return isOptional_; }
      set {
        isOptional_ = value;
      }
    }

    private object configType_;
    /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
    public enum ConfigTypeOneofCase {
      None = 0,
      TypedConfig = 4,
      ConfigDiscovery = 5,
    }
    private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigTypeOneofCase ConfigTypeCase {
      get { return configTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigType() {
      configTypeCase_ = ConfigTypeOneofCase.None;
      configType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HttpFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HttpFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
      if (!object.Equals(ConfigDiscovery, other.ConfigDiscovery)) return false;
      if (IsOptional != other.IsOptional) return false;
      if (ConfigTypeCase != other.ConfigTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
      if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) hash ^= ConfigDiscovery.GetHashCode();
      if (IsOptional != false) hash ^= IsOptional.GetHashCode();
      hash ^= (int) configTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(TypedConfig);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) {
        output.WriteRawTag(42);
        output.WriteMessage(ConfigDiscovery);
      }
      if (IsOptional != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(TypedConfig);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) {
        output.WriteRawTag(42);
        output.WriteMessage(ConfigDiscovery);
      }
      if (IsOptional != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigDiscovery);
      }
      if (IsOptional != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HttpFilter other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.IsOptional != false) {
        IsOptional = other.IsOptional;
      }
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.TypedConfig:
          if (TypedConfig == null) {
            TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
          }
          TypedConfig.MergeFrom(other.TypedConfig);
          break;
        case ConfigTypeOneofCase.ConfigDiscovery:
          if (ConfigDiscovery == null) {
            ConfigDiscovery = new global::Envoy.Config.Core.V3.ExtensionConfigSource();
          }
          ConfigDiscovery.MergeFrom(other.ConfigDiscovery);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
            if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
              subBuilder.MergeFrom(TypedConfig);
            }
            input.ReadMessage(subBuilder);
            TypedConfig = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.ExtensionConfigSource subBuilder = new global::Envoy.Config.Core.V3.ExtensionConfigSource();
            if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) {
              subBuilder.MergeFrom(ConfigDiscovery);
            }
            input.ReadMessage(subBuilder);
            ConfigDiscovery = subBuilder;
            break;
          }
          case 48: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
            if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
              subBuilder.MergeFrom(TypedConfig);
            }
            input.ReadMessage(subBuilder);
            TypedConfig = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.ExtensionConfigSource subBuilder = new global::Envoy.Config.Core.V3.ExtensionConfigSource();
            if (configTypeCase_ == ConfigTypeOneofCase.ConfigDiscovery) {
              subBuilder.MergeFrom(ConfigDiscovery);
            }
            input.ReadMessage(subBuilder);
            ConfigDiscovery = subBuilder;
            break;
          }
          case 48: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class RequestIDExtension : pb::IMessage<RequestIDExtension>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RequestIDExtension> _parser = new pb::MessageParser<RequestIDExtension>(() => new RequestIDExtension());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RequestIDExtension> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RequestIDExtension() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RequestIDExtension(RequestIDExtension other) : this() {
      typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RequestIDExtension Clone() {
      return new RequestIDExtension(this);
    }

    /// <summary>Field number for the "typed_config" field.</summary>
    public const int TypedConfigFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
    /// <summary>
    /// Request ID extension specific configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
      get { return typedConfig_; }
      set {
        typedConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RequestIDExtension);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RequestIDExtension other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (typedConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TypedConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (typedConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TypedConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (typedConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RequestIDExtension other) {
      if (other == null) {
        return;
      }
      if (other.typedConfig_ != null) {
        if (typedConfig_ == null) {
          TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        TypedConfig.MergeFrom(other.TypedConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(TypedConfig);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(TypedConfig);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#protodoc-title: Envoy Mobile HTTP connection manager]
  /// HTTP connection manager for use in Envoy mobile.
  /// [#extension: envoy.filters.network.envoy_mobile_http_connection_manager]
  /// </summary>
  public sealed partial class EnvoyMobileHttpConnectionManager : pb::IMessage<EnvoyMobileHttpConnectionManager>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvoyMobileHttpConnectionManager> _parser = new pb::MessageParser<EnvoyMobileHttpConnectionManager>(() => new EnvoyMobileHttpConnectionManager());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvoyMobileHttpConnectionManager> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManagerReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyMobileHttpConnectionManager() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyMobileHttpConnectionManager(EnvoyMobileHttpConnectionManager other) : this() {
      config_ = other.config_ != null ? other.config_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyMobileHttpConnectionManager Clone() {
      return new EnvoyMobileHttpConnectionManager(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager config_;
    /// <summary>
    /// The configuration for the underlying HttpConnectionManager which will be
    /// instantiated for Envoy mobile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvoyMobileHttpConnectionManager);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvoyMobileHttpConnectionManager other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvoyMobileHttpConnectionManager other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager();
        }
        Config.MergeFrom(other.Config);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager();
            }
            input.ReadMessage(Config);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Envoy.Extensions.Filters.Network.HttpConnectionManager.V3.HttpConnectionManager();
            }
            input.ReadMessage(Config);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
