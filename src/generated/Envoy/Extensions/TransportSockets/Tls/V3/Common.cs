// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/transport_sockets/tls/v3/common.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.TransportSockets.Tls.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/transport_sockets/tls/v3/common.proto</summary>
  public static partial class CommonReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/transport_sockets/tls/v3/common.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CommonReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjZlbnZveS9leHRlbnNpb25zL3RyYW5zcG9ydF9zb2NrZXRzL3Rscy92My9j",
            "b21tb24ucHJvdG8SKWVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tl",
            "dHMudGxzLnYzGh9lbnZveS9jb25maWcvY29yZS92My9iYXNlLnByb3RvGiRl",
            "bnZveS9jb25maWcvY29yZS92My9leHRlbnNpb24ucHJvdG8aImVudm95L3R5",
            "cGUvbWF0Y2hlci92My9zdHJpbmcucHJvdG8aGWdvb2dsZS9wcm90b2J1Zi9h",
            "bnkucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90bxojZW52",
            "b3kvYW5ub3RhdGlvbnMvZGVwcmVjYXRpb24ucHJvdG8aHnVkcGEvYW5ub3Rh",
            "dGlvbnMvbWlncmF0ZS5wcm90bxogdWRwYS9hbm5vdGF0aW9ucy9zZW5zaXRp",
            "dmUucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMvc3RhdHVzLnByb3RvGiF1ZHBh",
            "L2Fubm90YXRpb25zL3ZlcnNpb25pbmcucHJvdG8aF3ZhbGlkYXRlL3ZhbGlk",
            "YXRlLnByb3RvIr4DCg1UbHNQYXJhbWV0ZXJzEnQKHHRsc19taW5pbXVtX3By",
            "b3RvY29sX3ZlcnNpb24YASABKA4yRC5lbnZveS5leHRlbnNpb25zLnRyYW5z",
            "cG9ydF9zb2NrZXRzLnRscy52My5UbHNQYXJhbWV0ZXJzLlRsc1Byb3RvY29s",
            "Qgj6QgWCAQIQARJ0Chx0bHNfbWF4aW11bV9wcm90b2NvbF92ZXJzaW9uGAIg",
            "ASgOMkQuZW52b3kuZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMu",
            "djMuVGxzUGFyYW1ldGVycy5UbHNQcm90b2NvbEII+kIFggECEAESFQoNY2lw",
            "aGVyX3N1aXRlcxgDIAMoCRITCgtlY2RoX2N1cnZlcxgEIAMoCRIcChRzaWdu",
            "YXR1cmVfYWxnb3JpdGhtcxgFIAMoCSJPCgtUbHNQcm90b2NvbBIMCghUTFNf",
            "QVVUTxAAEgsKB1RMU3YxXzAQARILCgdUTFN2MV8xEAISCwoHVExTdjFfMhAD",
            "EgsKB1RMU3YxXzMQBDommsWIHiEKH2Vudm95LmFwaS52Mi5hdXRoLlRsc1Bh",
            "cmFtZXRlcnMitAEKElByaXZhdGVLZXlQcm92aWRlchIeCg1wcm92aWRlcl9u",
            "YW1lGAEgASgJQgf6QgRyAhABEjQKDHR5cGVkX2NvbmZpZxgDIAEoCzIULmdv",
            "b2dsZS5wcm90b2J1Zi5BbnlCBri3i6QCAUgAOiuaxYgeJgokZW52b3kuYXBp",
            "LnYyLmF1dGguUHJpdmF0ZUtleVByb3ZpZGVyQg0KC2NvbmZpZ190eXBlSgQI",
            "AhADUgZjb25maWciygQKDlRsc0NlcnRpZmljYXRlEjsKEWNlcnRpZmljYXRl",
            "X2NoYWluGAEgASgLMiAuZW52b3kuY29uZmlnLmNvcmUudjMuRGF0YVNvdXJj",
            "ZRI9Cgtwcml2YXRlX2tleRgCIAEoCzIgLmVudm95LmNvbmZpZy5jb3JlLnYz",
            "LkRhdGFTb3VyY2VCBri3i6QCARI4CgZwa2NzMTIYCCABKAsyIC5lbnZveS5j",
            "b25maWcuY29yZS52My5EYXRhU291cmNlQga4t4ukAgESQQoRd2F0Y2hlZF9k",
            "aXJlY3RvcnkYByABKAsyJi5lbnZveS5jb25maWcuY29yZS52My5XYXRjaGVk",
            "RGlyZWN0b3J5ElsKFHByaXZhdGVfa2V5X3Byb3ZpZGVyGAYgASgLMj0uZW52",
            "b3kuZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuUHJpdmF0",
            "ZUtleVByb3ZpZGVyEjoKCHBhc3N3b3JkGAMgASgLMiAuZW52b3kuY29uZmln",
            "LmNvcmUudjMuRGF0YVNvdXJjZUIGuLeLpAIBEjUKC29jc3Bfc3RhcGxlGAQg",
            "ASgLMiAuZW52b3kuY29uZmlnLmNvcmUudjMuRGF0YVNvdXJjZRJGChxzaWdu",
            "ZWRfY2VydGlmaWNhdGVfdGltZXN0YW1wGAUgAygLMiAuZW52b3kuY29uZmln",
            "LmNvcmUudjMuRGF0YVNvdXJjZTonmsWIHiIKIGVudm95LmFwaS52Mi5hdXRo",
            "LlRsc0NlcnRpZmljYXRlIoUBChRUbHNTZXNzaW9uVGlja2V0S2V5cxI+CgRr",
            "ZXlzGAEgAygLMiAuZW52b3kuY29uZmlnLmNvcmUudjMuRGF0YVNvdXJjZUIO",
            "+kIFkgECCAG4t4ukAgE6LZrFiB4oCiZlbnZveS5hcGkudjIuYXV0aC5UbHNT",
            "ZXNzaW9uVGlja2V0S2V5cyJUCiFDZXJ0aWZpY2F0ZVByb3ZpZGVyUGx1Z2lu",
            "SW5zdGFuY2USFQoNaW5zdGFuY2VfbmFtZRgBIAEoCRIYChBjZXJ0aWZpY2F0",
            "ZV9uYW1lGAIgASgJIpICChVTdWJqZWN0QWx0TmFtZU1hdGNoZXISZgoIc2Fu",
            "X3R5cGUYASABKA4ySC5lbnZveS5leHRlbnNpb25zLnRyYW5zcG9ydF9zb2Nr",
            "ZXRzLnRscy52My5TdWJqZWN0QWx0TmFtZU1hdGNoZXIuU2FuVHlwZUIK+kIH",
            "ggEEEAEgABI/CgdtYXRjaGVyGAIgASgLMiQuZW52b3kudHlwZS5tYXRjaGVy",
            "LnYzLlN0cmluZ01hdGNoZXJCCPpCBYoBAhABIlAKB1NhblR5cGUSGAoUU0FO",
            "X1RZUEVfVU5TUEVDSUZJRUQQABIJCgVFTUFJTBABEgcKA0ROUxACEgcKA1VS",
            "SRADEg4KCklQX0FERFJFU1MQBCLdCQocQ2VydGlmaWNhdGVWYWxpZGF0aW9u",
            "Q29udGV4dBJMCgp0cnVzdGVkX2NhGAEgASgLMiAuZW52b3kuY29uZmlnLmNv",
            "cmUudjMuRGF0YVNvdXJjZUIW8pj+jwUQEg5jYV9jZXJ0X3NvdXJjZRKOAQog",
            "Y2FfY2VydGlmaWNhdGVfcHJvdmlkZXJfaW5zdGFuY2UYDSABKAsyTC5lbnZv",
            "eS5leHRlbnNpb25zLnRyYW5zcG9ydF9zb2NrZXRzLnRscy52My5DZXJ0aWZp",
            "Y2F0ZVByb3ZpZGVyUGx1Z2luSW5zdGFuY2VCFvKY/o8FEBIOY2FfY2VydF9z",
            "b3VyY2USQQoRd2F0Y2hlZF9kaXJlY3RvcnkYCyABKAsyJi5lbnZveS5jb25m",
            "aWcuY29yZS52My5XYXRjaGVkRGlyZWN0b3J5Ei8KF3ZlcmlmeV9jZXJ0aWZp",
            "Y2F0ZV9zcGtpGAMgAygJQg76QguSAQgiBnIEECwoLBIvChd2ZXJpZnlfY2Vy",
            "dGlmaWNhdGVfaGFzaBgCIAMoCUIO+kILkgEIIgZyBBBAKF8SZwodbWF0Y2hf",
            "dHlwZWRfc3ViamVjdF9hbHRfbmFtZXMYDyADKAsyQC5lbnZveS5leHRlbnNp",
            "b25zLnRyYW5zcG9ydF9zb2NrZXRzLnRscy52My5TdWJqZWN0QWx0TmFtZU1h",
            "dGNoZXISUgoXbWF0Y2hfc3ViamVjdF9hbHRfbmFtZXMYCSADKAsyJC5lbnZv",
            "eS50eXBlLm1hdGNoZXIudjMuU3RyaW5nTWF0Y2hlckILGAGSx4bYBAMzLjAS",
            "SAokcmVxdWlyZV9zaWduZWRfY2VydGlmaWNhdGVfdGltZXN0YW1wGAYgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRItCgNjcmwYByABKAsyIC5l",
            "bnZveS5jb25maWcuY29yZS52My5EYXRhU291cmNlEiEKGWFsbG93X2V4cGly",
            "ZWRfY2VydGlmaWNhdGUYCCABKAgSigEKGHRydXN0X2NoYWluX3ZlcmlmaWNh",
            "dGlvbhgKIAEoDjJeLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tl",
            "dHMudGxzLnYzLkNlcnRpZmljYXRlVmFsaWRhdGlvbkNvbnRleHQuVHJ1c3RD",
            "aGFpblZlcmlmaWNhdGlvbkII+kIFggECEAESSwoXY3VzdG9tX3ZhbGlkYXRv",
            "cl9jb25maWcYDCABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5UeXBlZEV4",
            "dGVuc2lvbkNvbmZpZxIhChlvbmx5X3ZlcmlmeV9sZWFmX2NlcnRfY3JsGA4g",
            "ASgIEj8KEG1heF92ZXJpZnlfZGVwdGgYECABKAsyHC5nb29nbGUucHJvdG9i",
            "dWYuVUludDMyVmFsdWVCB/pCBCoCGGQiRgoWVHJ1c3RDaGFpblZlcmlmaWNh",
            "dGlvbhIWChJWRVJJRllfVFJVU1RfQ0hBSU4QABIUChBBQ0NFUFRfVU5UUlVT",
            "VEVEEAE6NZrFiB4wCi5lbnZveS5hcGkudjIuYXV0aC5DZXJ0aWZpY2F0ZVZh",
            "bGlkYXRpb25Db250ZXh0SgQIBBAFSgQIBRAGUhd2ZXJpZnlfc3ViamVjdF9h",
            "bHRfbmFtZUKoAQo3aW8uZW52b3lwcm94eS5lbnZveS5leHRlbnNpb25zLnRy",
            "YW5zcG9ydF9zb2NrZXRzLnRscy52M0ILQ29tbW9uUHJvdG9QAVpWZ2l0aHVi",
            "LmNvbS9lbnZveXByb3h5L2dvLWNvbnRyb2wtcGxhbmUvZW52b3kvZXh0ZW5z",
            "aW9ucy90cmFuc3BvcnRfc29ja2V0cy90bHMvdjM7dGxzdjO6gMjRBgIQAmIG",
            "cHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Type.Matcher.V3.StringReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.SensitiveReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters), global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Parser, new[]{ "TlsMinimumProtocolVersion", "TlsMaximumProtocolVersion", "CipherSuites", "EcdhCurves", "SignatureAlgorithms" }, null, new[]{ typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider), global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider.Parser, new[]{ "ProviderName", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate), global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate.Parser, new[]{ "CertificateChain", "PrivateKey", "Pkcs12", "WatchedDirectory", "PrivateKeyProvider", "Password", "OcspStaple", "SignedCertificateTimestamp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys), global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys.Parser, new[]{ "Keys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance), global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance.Parser, new[]{ "InstanceName", "CertificateName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher), global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Parser, new[]{ "SanType", "Matcher" }, null, new[]{ typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext), global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Parser, new[]{ "TrustedCa", "CaCertificateProviderInstance", "WatchedDirectory", "VerifyCertificateSpki", "VerifyCertificateHash", "MatchTypedSubjectAltNames", "MatchSubjectAltNames", "RequireSignedCertificateTimestamp", "Crl", "AllowExpiredCertificate", "TrustChainVerification", "CustomValidatorConfig", "OnlyVerifyLeafCertCrl", "MaxVerifyDepth" }, null, new[]{ typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class TlsParameters : pb::IMessage<TlsParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TlsParameters> _parser = new pb::MessageParser<TlsParameters>(() => new TlsParameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TlsParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsParameters(TlsParameters other) : this() {
      tlsMinimumProtocolVersion_ = other.tlsMinimumProtocolVersion_;
      tlsMaximumProtocolVersion_ = other.tlsMaximumProtocolVersion_;
      cipherSuites_ = other.cipherSuites_.Clone();
      ecdhCurves_ = other.ecdhCurves_.Clone();
      signatureAlgorithms_ = other.signatureAlgorithms_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsParameters Clone() {
      return new TlsParameters(this);
    }

    /// <summary>Field number for the "tls_minimum_protocol_version" field.</summary>
    public const int TlsMinimumProtocolVersionFieldNumber = 1;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol tlsMinimumProtocolVersion_ = global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto;
    /// <summary>
    /// Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
    ///
    /// TLS protocol versions below TLSv1_2 require setting compatible ciphers with the
    /// ``cipher_suites`` setting as the default ciphers no longer include compatible ciphers.
    ///
    /// .. attention::
    ///
    ///   Using TLS protocol versions below TLSv1_2 has serious security considerations and risks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol TlsMinimumProtocolVersion {
      get { return tlsMinimumProtocolVersion_; }
      set {
        tlsMinimumProtocolVersion_ = value;
      }
    }

    /// <summary>Field number for the "tls_maximum_protocol_version" field.</summary>
    public const int TlsMaximumProtocolVersionFieldNumber = 2;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol tlsMaximumProtocolVersion_ = global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto;
    /// <summary>
    /// Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
    /// servers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol TlsMaximumProtocolVersion {
      get { return tlsMaximumProtocolVersion_; }
      set {
        tlsMaximumProtocolVersion_ = value;
      }
    }

    /// <summary>Field number for the "cipher_suites" field.</summary>
    public const int CipherSuitesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_cipherSuites_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> cipherSuites_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified, the TLS listener will only support the specified `cipher list
    /// &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
    /// when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3).
    ///
    /// If not specified, a default list will be used. Defaults are different for server (downstream) and
    /// client (upstream) TLS configurations.
    /// Defaults will change over time in response to security considerations; If you care, configure
    /// it instead of using the default.
    ///
    /// In non-FIPS builds, the default server cipher list is:
    ///
    /// .. code-block:: none
    ///
    ///   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
    ///   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
    ///   ECDHE-ECDSA-AES256-GCM-SHA384
    ///   ECDHE-RSA-AES256-GCM-SHA384
    ///
    /// In builds using :ref:`BoringSSL FIPS &lt;arch_overview_ssl_fips>`, the default server cipher list is:
    ///
    /// .. code-block:: none
    ///
    ///   ECDHE-ECDSA-AES128-GCM-SHA256
    ///   ECDHE-RSA-AES128-GCM-SHA256
    ///   ECDHE-ECDSA-AES256-GCM-SHA384
    ///   ECDHE-RSA-AES256-GCM-SHA384
    ///
    /// In non-FIPS builds, the default client cipher list is:
    ///
    /// .. code-block:: none
    ///
    ///   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
    ///   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
    ///   ECDHE-ECDSA-AES256-GCM-SHA384
    ///   ECDHE-RSA-AES256-GCM-SHA384
    ///
    /// In builds using :ref:`BoringSSL FIPS &lt;arch_overview_ssl_fips>`, the default client cipher list is:
    ///
    /// .. code-block:: none
    ///
    ///   ECDHE-ECDSA-AES128-GCM-SHA256
    ///   ECDHE-RSA-AES128-GCM-SHA256
    ///   ECDHE-ECDSA-AES256-GCM-SHA384
    ///   ECDHE-RSA-AES256-GCM-SHA384
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> CipherSuites {
      get { return cipherSuites_; }
    }

    /// <summary>Field number for the "ecdh_curves" field.</summary>
    public const int EcdhCurvesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_ecdhCurves_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> ecdhCurves_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified, the TLS connection will only support the specified ECDH
    /// curves. If not specified, the default curves will be used.
    ///
    /// In non-FIPS builds, the default curves are:
    ///
    /// .. code-block:: none
    ///
    ///   X25519
    ///   P-256
    ///
    /// In builds using :ref:`BoringSSL FIPS &lt;arch_overview_ssl_fips>`, the default curve is:
    ///
    /// .. code-block:: none
    ///
    ///   P-256
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> EcdhCurves {
      get { return ecdhCurves_; }
    }

    /// <summary>Field number for the "signature_algorithms" field.</summary>
    public const int SignatureAlgorithmsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_signatureAlgorithms_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> signatureAlgorithms_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified, the TLS connection will only support the specified signature algorithms.
    /// The list is ordered by preference.
    /// If not specified, the default signature algorithms defined by BoringSSL will be used.
    ///
    /// Default signature algorithms selected by BoringSSL (may be out of date):
    ///
    /// .. code-block:: none
    ///
    ///   ecdsa_secp256r1_sha256
    ///   rsa_pss_rsae_sha256
    ///   rsa_pkcs1_sha256
    ///   ecdsa_secp384r1_sha384
    ///   rsa_pss_rsae_sha384
    ///   rsa_pkcs1_sha384
    ///   rsa_pss_rsae_sha512
    ///   rsa_pkcs1_sha512
    ///   rsa_pkcs1_sha1
    ///
    /// Signature algorithms supported by BoringSSL (may be out of date):
    ///
    /// .. code-block:: none
    ///
    ///   rsa_pkcs1_sha256
    ///   rsa_pkcs1_sha384
    ///   rsa_pkcs1_sha512
    ///   ecdsa_secp256r1_sha256
    ///   ecdsa_secp384r1_sha384
    ///   ecdsa_secp521r1_sha512
    ///   rsa_pss_rsae_sha256
    ///   rsa_pss_rsae_sha384
    ///   rsa_pss_rsae_sha512
    ///   ed25519
    ///   rsa_pkcs1_sha1
    ///   ecdsa_sha1
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> SignatureAlgorithms {
      get { return signatureAlgorithms_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TlsParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TlsParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TlsMinimumProtocolVersion != other.TlsMinimumProtocolVersion) return false;
      if (TlsMaximumProtocolVersion != other.TlsMaximumProtocolVersion) return false;
      if(!cipherSuites_.Equals(other.cipherSuites_)) return false;
      if(!ecdhCurves_.Equals(other.ecdhCurves_)) return false;
      if(!signatureAlgorithms_.Equals(other.signatureAlgorithms_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TlsMinimumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) hash ^= TlsMinimumProtocolVersion.GetHashCode();
      if (TlsMaximumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) hash ^= TlsMaximumProtocolVersion.GetHashCode();
      hash ^= cipherSuites_.GetHashCode();
      hash ^= ecdhCurves_.GetHashCode();
      hash ^= signatureAlgorithms_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TlsMinimumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TlsMinimumProtocolVersion);
      }
      if (TlsMaximumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TlsMaximumProtocolVersion);
      }
      cipherSuites_.WriteTo(output, _repeated_cipherSuites_codec);
      ecdhCurves_.WriteTo(output, _repeated_ecdhCurves_codec);
      signatureAlgorithms_.WriteTo(output, _repeated_signatureAlgorithms_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TlsMinimumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TlsMinimumProtocolVersion);
      }
      if (TlsMaximumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TlsMaximumProtocolVersion);
      }
      cipherSuites_.WriteTo(ref output, _repeated_cipherSuites_codec);
      ecdhCurves_.WriteTo(ref output, _repeated_ecdhCurves_codec);
      signatureAlgorithms_.WriteTo(ref output, _repeated_signatureAlgorithms_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TlsMinimumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TlsMinimumProtocolVersion);
      }
      if (TlsMaximumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TlsMaximumProtocolVersion);
      }
      size += cipherSuites_.CalculateSize(_repeated_cipherSuites_codec);
      size += ecdhCurves_.CalculateSize(_repeated_ecdhCurves_codec);
      size += signatureAlgorithms_.CalculateSize(_repeated_signatureAlgorithms_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TlsParameters other) {
      if (other == null) {
        return;
      }
      if (other.TlsMinimumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        TlsMinimumProtocolVersion = other.TlsMinimumProtocolVersion;
      }
      if (other.TlsMaximumProtocolVersion != global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol.TlsAuto) {
        TlsMaximumProtocolVersion = other.TlsMaximumProtocolVersion;
      }
      cipherSuites_.Add(other.cipherSuites_);
      ecdhCurves_.Add(other.ecdhCurves_);
      signatureAlgorithms_.Add(other.signatureAlgorithms_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TlsMinimumProtocolVersion = (global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 16: {
            TlsMaximumProtocolVersion = (global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 26: {
            cipherSuites_.AddEntriesFrom(input, _repeated_cipherSuites_codec);
            break;
          }
          case 34: {
            ecdhCurves_.AddEntriesFrom(input, _repeated_ecdhCurves_codec);
            break;
          }
          case 42: {
            signatureAlgorithms_.AddEntriesFrom(input, _repeated_signatureAlgorithms_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TlsMinimumProtocolVersion = (global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 16: {
            TlsMaximumProtocolVersion = (global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters.Types.TlsProtocol) input.ReadEnum();
            break;
          }
          case 26: {
            cipherSuites_.AddEntriesFrom(ref input, _repeated_cipherSuites_codec);
            break;
          }
          case 34: {
            ecdhCurves_.AddEntriesFrom(ref input, _repeated_ecdhCurves_codec);
            break;
          }
          case 42: {
            signatureAlgorithms_.AddEntriesFrom(ref input, _repeated_signatureAlgorithms_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TlsParameters message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum TlsProtocol {
        /// <summary>
        /// Envoy will choose the optimal TLS version.
        /// </summary>
        [pbr::OriginalName("TLS_AUTO")] TlsAuto = 0,
        /// <summary>
        /// TLS 1.0
        /// </summary>
        [pbr::OriginalName("TLSv1_0")] Tlsv10 = 1,
        /// <summary>
        /// TLS 1.1
        /// </summary>
        [pbr::OriginalName("TLSv1_1")] Tlsv11 = 2,
        /// <summary>
        /// TLS 1.2
        /// </summary>
        [pbr::OriginalName("TLSv1_2")] Tlsv12 = 3,
        /// <summary>
        /// TLS 1.3
        /// </summary>
        [pbr::OriginalName("TLSv1_3")] Tlsv13 = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// BoringSSL private key method configuration. The private key methods are used for external
  /// (potentially asynchronous) signing and decryption operations. Some use cases for private key
  /// methods would be TPM support and TLS acceleration.
  /// </summary>
  public sealed partial class PrivateKeyProvider : pb::IMessage<PrivateKeyProvider>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PrivateKeyProvider> _parser = new pb::MessageParser<PrivateKeyProvider>(() => new PrivateKeyProvider());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PrivateKeyProvider> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrivateKeyProvider() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrivateKeyProvider(PrivateKeyProvider other) : this() {
      providerName_ = other.providerName_;
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.TypedConfig:
          TypedConfig = other.TypedConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PrivateKeyProvider Clone() {
      return new PrivateKeyProvider(this);
    }

    /// <summary>Field number for the "provider_name" field.</summary>
    public const int ProviderNameFieldNumber = 1;
    private string providerName_ = "";
    /// <summary>
    /// Private key method provider name. The name must match a
    /// supported private key method provider type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProviderName {
      get { return providerName_; }
      set {
        providerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "typed_config" field.</summary>
    public const int TypedConfigFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
      get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
      set {
        configType_ = value;
        configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
      }
    }

    private object configType_;
    /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
    public enum ConfigTypeOneofCase {
      None = 0,
      TypedConfig = 3,
    }
    private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigTypeOneofCase ConfigTypeCase {
      get { return configTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigType() {
      configTypeCase_ = ConfigTypeOneofCase.None;
      configType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PrivateKeyProvider);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PrivateKeyProvider other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProviderName != other.ProviderName) return false;
      if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
      if (ConfigTypeCase != other.ConfigTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ProviderName.Length != 0) hash ^= ProviderName.GetHashCode();
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
      hash ^= (int) configTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ProviderName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProviderName);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        output.WriteRawTag(26);
        output.WriteMessage(TypedConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ProviderName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ProviderName);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        output.WriteRawTag(26);
        output.WriteMessage(TypedConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ProviderName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProviderName);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PrivateKeyProvider other) {
      if (other == null) {
        return;
      }
      if (other.ProviderName.Length != 0) {
        ProviderName = other.ProviderName;
      }
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.TypedConfig:
          if (TypedConfig == null) {
            TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
          }
          TypedConfig.MergeFrom(other.TypedConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ProviderName = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
            if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
              subBuilder.MergeFrom(TypedConfig);
            }
            input.ReadMessage(subBuilder);
            TypedConfig = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ProviderName = input.ReadString();
            break;
          }
          case 26: {
            global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
            if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
              subBuilder.MergeFrom(TypedConfig);
            }
            input.ReadMessage(subBuilder);
            TypedConfig = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 9]
  /// </summary>
  public sealed partial class TlsCertificate : pb::IMessage<TlsCertificate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TlsCertificate> _parser = new pb::MessageParser<TlsCertificate>(() => new TlsCertificate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TlsCertificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsCertificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsCertificate(TlsCertificate other) : this() {
      certificateChain_ = other.certificateChain_ != null ? other.certificateChain_.Clone() : null;
      privateKey_ = other.privateKey_ != null ? other.privateKey_.Clone() : null;
      pkcs12_ = other.pkcs12_ != null ? other.pkcs12_.Clone() : null;
      watchedDirectory_ = other.watchedDirectory_ != null ? other.watchedDirectory_.Clone() : null;
      privateKeyProvider_ = other.privateKeyProvider_ != null ? other.privateKeyProvider_.Clone() : null;
      password_ = other.password_ != null ? other.password_.Clone() : null;
      ocspStaple_ = other.ocspStaple_ != null ? other.ocspStaple_.Clone() : null;
      signedCertificateTimestamp_ = other.signedCertificateTimestamp_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsCertificate Clone() {
      return new TlsCertificate(this);
    }

    /// <summary>Field number for the "certificate_chain" field.</summary>
    public const int CertificateChainFieldNumber = 1;
    private global::Envoy.Config.Core.V3.DataSource certificateChain_;
    /// <summary>
    /// The TLS certificate chain.
    ///
    /// If ``certificate_chain`` is a filesystem path, a watch will be added to the
    /// parent directory for any file moves to support rotation. This currently
    /// only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via
    /// SDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource CertificateChain {
      get { return certificateChain_; }
      set {
        certificateChain_ = value;
      }
    }

    /// <summary>Field number for the "private_key" field.</summary>
    public const int PrivateKeyFieldNumber = 2;
    private global::Envoy.Config.Core.V3.DataSource privateKey_;
    /// <summary>
    /// The TLS private key.
    ///
    /// If ``private_key`` is a filesystem path, a watch will be added to the parent
    /// directory for any file moves to support rotation. This currently only
    /// applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource PrivateKey {
      get { return privateKey_; }
      set {
        privateKey_ = value;
      }
    }

    /// <summary>Field number for the "pkcs12" field.</summary>
    public const int Pkcs12FieldNumber = 8;
    private global::Envoy.Config.Core.V3.DataSource pkcs12_;
    /// <summary>
    /// ``Pkcs12`` data containing TLS certificate, chain, and private key.
    ///
    /// If ``pkcs12`` is a filesystem path, the file will be read, but no watch will
    /// be added to the parent directory, since ``pkcs12`` isn't used by SDS.
    /// This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``.
    /// This can't be marked as ``oneof`` due to API compatibility reasons. Setting
    /// both :ref:`private_key &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>`,
    /// :ref:`certificate_chain &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain>`,
    /// or :ref:`private_key_provider &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
    /// and :ref:`pkcs12 &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`
    /// fields will result in an error. Use :ref:`password
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password>`
    /// to specify the password to unprotect the ``PKCS12`` data, if necessary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource Pkcs12 {
      get { return pkcs12_; }
      set {
        pkcs12_ = value;
      }
    }

    /// <summary>Field number for the "watched_directory" field.</summary>
    public const int WatchedDirectoryFieldNumber = 7;
    private global::Envoy.Config.Core.V3.WatchedDirectory watchedDirectory_;
    /// <summary>
    /// If specified, updates of file-based ``certificate_chain`` and ``private_key``
    /// sources will be triggered by this watch. The certificate/key pair will be
    /// read together and validated for atomic read consistency (i.e. no
    /// intervening modification occurred between cert/key read, verified by file
    /// hash comparisons). This allows explicit control over the path watched, by
    /// default the parent directories of the filesystem paths in
    /// ``certificate_chain`` and ``private_key`` are watched if this field is not
    /// specified. This only applies when a ``TlsCertificate`` is delivered by SDS
    /// with references to filesystem paths. See the :ref:`SDS key rotation
    /// &lt;sds_key_rotation>` documentation for further details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.WatchedDirectory WatchedDirectory {
      get { return watchedDirectory_; }
      set {
        watchedDirectory_ = value;
      }
    }

    /// <summary>Field number for the "private_key_provider" field.</summary>
    public const int PrivateKeyProviderFieldNumber = 6;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider privateKeyProvider_;
    /// <summary>
    /// BoringSSL private key method provider. This is an alternative to :ref:`private_key
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field. This can't be
    /// marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
    /// :ref:`private_key_provider
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields will result in an
    /// error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider PrivateKeyProvider {
      get { return privateKeyProvider_; }
      set {
        privateKeyProvider_ = value;
      }
    }

    /// <summary>Field number for the "password" field.</summary>
    public const int PasswordFieldNumber = 3;
    private global::Envoy.Config.Core.V3.DataSource password_;
    /// <summary>
    /// The password to decrypt the TLS private key. If this field is not set, it is assumed that the
    /// TLS private key is not password encrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource Password {
      get { return password_; }
      set {
        password_ = value;
      }
    }

    /// <summary>Field number for the "ocsp_staple" field.</summary>
    public const int OcspStapleFieldNumber = 4;
    private global::Envoy.Config.Core.V3.DataSource ocspStaple_;
    /// <summary>
    /// The OCSP response to be stapled with this certificate during the handshake.
    /// The response must be DER-encoded and may only be  provided via ``filename`` or
    /// ``inline_bytes``. The response may pertain to only one certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource OcspStaple {
      get { return ocspStaple_; }
      set {
        ocspStaple_ = value;
      }
    }

    /// <summary>Field number for the "signed_certificate_timestamp" field.</summary>
    public const int SignedCertificateTimestampFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.DataSource> _repeated_signedCertificateTimestamp_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Core.V3.DataSource.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource> signedCertificateTimestamp_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource>();
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource> SignedCertificateTimestamp {
      get { return signedCertificateTimestamp_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TlsCertificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TlsCertificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CertificateChain, other.CertificateChain)) return false;
      if (!object.Equals(PrivateKey, other.PrivateKey)) return false;
      if (!object.Equals(Pkcs12, other.Pkcs12)) return false;
      if (!object.Equals(WatchedDirectory, other.WatchedDirectory)) return false;
      if (!object.Equals(PrivateKeyProvider, other.PrivateKeyProvider)) return false;
      if (!object.Equals(Password, other.Password)) return false;
      if (!object.Equals(OcspStaple, other.OcspStaple)) return false;
      if(!signedCertificateTimestamp_.Equals(other.signedCertificateTimestamp_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (certificateChain_ != null) hash ^= CertificateChain.GetHashCode();
      if (privateKey_ != null) hash ^= PrivateKey.GetHashCode();
      if (pkcs12_ != null) hash ^= Pkcs12.GetHashCode();
      if (watchedDirectory_ != null) hash ^= WatchedDirectory.GetHashCode();
      if (privateKeyProvider_ != null) hash ^= PrivateKeyProvider.GetHashCode();
      if (password_ != null) hash ^= Password.GetHashCode();
      if (ocspStaple_ != null) hash ^= OcspStaple.GetHashCode();
      hash ^= signedCertificateTimestamp_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (certificateChain_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CertificateChain);
      }
      if (privateKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrivateKey);
      }
      if (password_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Password);
      }
      if (ocspStaple_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(OcspStaple);
      }
      signedCertificateTimestamp_.WriteTo(output, _repeated_signedCertificateTimestamp_codec);
      if (privateKeyProvider_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PrivateKeyProvider);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(WatchedDirectory);
      }
      if (pkcs12_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Pkcs12);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (certificateChain_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CertificateChain);
      }
      if (privateKey_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PrivateKey);
      }
      if (password_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Password);
      }
      if (ocspStaple_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(OcspStaple);
      }
      signedCertificateTimestamp_.WriteTo(ref output, _repeated_signedCertificateTimestamp_codec);
      if (privateKeyProvider_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(PrivateKeyProvider);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(WatchedDirectory);
      }
      if (pkcs12_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Pkcs12);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (certificateChain_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CertificateChain);
      }
      if (privateKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrivateKey);
      }
      if (pkcs12_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pkcs12);
      }
      if (watchedDirectory_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WatchedDirectory);
      }
      if (privateKeyProvider_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrivateKeyProvider);
      }
      if (password_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Password);
      }
      if (ocspStaple_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OcspStaple);
      }
      size += signedCertificateTimestamp_.CalculateSize(_repeated_signedCertificateTimestamp_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TlsCertificate other) {
      if (other == null) {
        return;
      }
      if (other.certificateChain_ != null) {
        if (certificateChain_ == null) {
          CertificateChain = new global::Envoy.Config.Core.V3.DataSource();
        }
        CertificateChain.MergeFrom(other.CertificateChain);
      }
      if (other.privateKey_ != null) {
        if (privateKey_ == null) {
          PrivateKey = new global::Envoy.Config.Core.V3.DataSource();
        }
        PrivateKey.MergeFrom(other.PrivateKey);
      }
      if (other.pkcs12_ != null) {
        if (pkcs12_ == null) {
          Pkcs12 = new global::Envoy.Config.Core.V3.DataSource();
        }
        Pkcs12.MergeFrom(other.Pkcs12);
      }
      if (other.watchedDirectory_ != null) {
        if (watchedDirectory_ == null) {
          WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
        }
        WatchedDirectory.MergeFrom(other.WatchedDirectory);
      }
      if (other.privateKeyProvider_ != null) {
        if (privateKeyProvider_ == null) {
          PrivateKeyProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider();
        }
        PrivateKeyProvider.MergeFrom(other.PrivateKeyProvider);
      }
      if (other.password_ != null) {
        if (password_ == null) {
          Password = new global::Envoy.Config.Core.V3.DataSource();
        }
        Password.MergeFrom(other.Password);
      }
      if (other.ocspStaple_ != null) {
        if (ocspStaple_ == null) {
          OcspStaple = new global::Envoy.Config.Core.V3.DataSource();
        }
        OcspStaple.MergeFrom(other.OcspStaple);
      }
      signedCertificateTimestamp_.Add(other.signedCertificateTimestamp_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (certificateChain_ == null) {
              CertificateChain = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(CertificateChain);
            break;
          }
          case 18: {
            if (privateKey_ == null) {
              PrivateKey = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(PrivateKey);
            break;
          }
          case 26: {
            if (password_ == null) {
              Password = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Password);
            break;
          }
          case 34: {
            if (ocspStaple_ == null) {
              OcspStaple = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(OcspStaple);
            break;
          }
          case 42: {
            signedCertificateTimestamp_.AddEntriesFrom(input, _repeated_signedCertificateTimestamp_codec);
            break;
          }
          case 50: {
            if (privateKeyProvider_ == null) {
              PrivateKeyProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider();
            }
            input.ReadMessage(PrivateKeyProvider);
            break;
          }
          case 58: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
          case 66: {
            if (pkcs12_ == null) {
              Pkcs12 = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Pkcs12);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (certificateChain_ == null) {
              CertificateChain = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(CertificateChain);
            break;
          }
          case 18: {
            if (privateKey_ == null) {
              PrivateKey = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(PrivateKey);
            break;
          }
          case 26: {
            if (password_ == null) {
              Password = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Password);
            break;
          }
          case 34: {
            if (ocspStaple_ == null) {
              OcspStaple = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(OcspStaple);
            break;
          }
          case 42: {
            signedCertificateTimestamp_.AddEntriesFrom(ref input, _repeated_signedCertificateTimestamp_codec);
            break;
          }
          case 50: {
            if (privateKeyProvider_ == null) {
              PrivateKeyProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.PrivateKeyProvider();
            }
            input.ReadMessage(PrivateKeyProvider);
            break;
          }
          case 58: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
          case 66: {
            if (pkcs12_ == null) {
              Pkcs12 = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Pkcs12);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TlsSessionTicketKeys : pb::IMessage<TlsSessionTicketKeys>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TlsSessionTicketKeys> _parser = new pb::MessageParser<TlsSessionTicketKeys>(() => new TlsSessionTicketKeys());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TlsSessionTicketKeys> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsSessionTicketKeys() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsSessionTicketKeys(TlsSessionTicketKeys other) : this() {
      keys_ = other.keys_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsSessionTicketKeys Clone() {
      return new TlsSessionTicketKeys(this);
    }

    /// <summary>Field number for the "keys" field.</summary>
    public const int KeysFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.DataSource> _repeated_keys_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Core.V3.DataSource.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource> keys_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource>();
    /// <summary>
    /// Keys for encrypting and decrypting TLS session tickets. The
    /// first key in the array contains the key to encrypt all new sessions created by this context.
    /// All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
    /// by, for example, putting the new key first, and the previous key second.
    ///
    /// If :ref:`session_ticket_keys &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    /// is not specified, the TLS library will still support resuming sessions via tickets, but it will
    /// use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
    /// or on different hosts.
    ///
    /// Each key must contain exactly 80 bytes of cryptographically-secure random data. For
    /// example, the output of ``openssl rand 80``.
    ///
    /// .. attention::
    ///
    ///   Using this feature has serious security considerations and risks. Improper handling of keys
    ///   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
    ///   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
    ///   discussion. To minimize the risk, you must:
    ///
    ///   * Keep the session ticket keys at least as secure as your TLS certificate private keys
    ///   * Rotate session ticket keys at least daily, and preferably hourly
    ///   * Always generate keys using a cryptographically-secure random data source
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.DataSource> Keys {
      get { return keys_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TlsSessionTicketKeys);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TlsSessionTicketKeys other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keys_.Equals(other.keys_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keys_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      keys_.WriteTo(output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      keys_.WriteTo(ref output, _repeated_keys_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += keys_.CalculateSize(_repeated_keys_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TlsSessionTicketKeys other) {
      if (other == null) {
        return;
      }
      keys_.Add(other.keys_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            keys_.AddEntriesFrom(input, _repeated_keys_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
  /// The plugin instances are defined in the client's bootstrap file.
  /// The plugin allows certificates to be fetched/refreshed over the network asynchronously with
  /// respect to the TLS handshake.
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class CertificateProviderPluginInstance : pb::IMessage<CertificateProviderPluginInstance>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateProviderPluginInstance> _parser = new pb::MessageParser<CertificateProviderPluginInstance>(() => new CertificateProviderPluginInstance());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CertificateProviderPluginInstance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateProviderPluginInstance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateProviderPluginInstance(CertificateProviderPluginInstance other) : this() {
      instanceName_ = other.instanceName_;
      certificateName_ = other.certificateName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateProviderPluginInstance Clone() {
      return new CertificateProviderPluginInstance(this);
    }

    /// <summary>Field number for the "instance_name" field.</summary>
    public const int InstanceNameFieldNumber = 1;
    private string instanceName_ = "";
    /// <summary>
    /// Provider instance name. If not present, defaults to "default".
    ///
    /// Instance names should generally be defined not in terms of the underlying provider
    /// implementation (e.g., "file_watcher") but rather in terms of the function of the
    /// certificates (e.g., "foo_deployment_identity").
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InstanceName {
      get { return instanceName_; }
      set {
        instanceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "certificate_name" field.</summary>
    public const int CertificateNameFieldNumber = 2;
    private string certificateName_ = "";
    /// <summary>
    /// Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    /// a root-certificate (validation context) or "example.com" to specify a certificate for a
    /// particular domain. Not all provider instances will actually use this field, so the value
    /// defaults to the empty string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CertificateName {
      get { return certificateName_; }
      set {
        certificateName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CertificateProviderPluginInstance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CertificateProviderPluginInstance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InstanceName != other.InstanceName) return false;
      if (CertificateName != other.CertificateName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (InstanceName.Length != 0) hash ^= InstanceName.GetHashCode();
      if (CertificateName.Length != 0) hash ^= CertificateName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (InstanceName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(InstanceName);
      }
      if (CertificateName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CertificateName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (InstanceName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(InstanceName);
      }
      if (CertificateName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CertificateName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (InstanceName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(InstanceName);
      }
      if (CertificateName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CertificateProviderPluginInstance other) {
      if (other == null) {
        return;
      }
      if (other.InstanceName.Length != 0) {
        InstanceName = other.InstanceName;
      }
      if (other.CertificateName.Length != 0) {
        CertificateName = other.CertificateName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            InstanceName = input.ReadString();
            break;
          }
          case 18: {
            CertificateName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            InstanceName = input.ReadString();
            break;
          }
          case 18: {
            CertificateName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Matcher for subject alternative names, to match both type and value of the SAN.
  /// </summary>
  public sealed partial class SubjectAltNameMatcher : pb::IMessage<SubjectAltNameMatcher>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SubjectAltNameMatcher> _parser = new pb::MessageParser<SubjectAltNameMatcher>(() => new SubjectAltNameMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SubjectAltNameMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SubjectAltNameMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SubjectAltNameMatcher(SubjectAltNameMatcher other) : this() {
      sanType_ = other.sanType_;
      matcher_ = other.matcher_ != null ? other.matcher_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SubjectAltNameMatcher Clone() {
      return new SubjectAltNameMatcher(this);
    }

    /// <summary>Field number for the "san_type" field.</summary>
    public const int SanTypeFieldNumber = 1;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType sanType_ = global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified;
    /// <summary>
    /// Specification of type of SAN. Note that the default enum value is an invalid choice.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType SanType {
      get { return sanType_; }
      set {
        sanType_ = value;
      }
    }

    /// <summary>Field number for the "matcher" field.</summary>
    public const int MatcherFieldNumber = 2;
    private global::Envoy.Type.Matcher.V3.StringMatcher matcher_;
    /// <summary>
    /// Matcher for SAN value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.StringMatcher Matcher {
      get { return matcher_; }
      set {
        matcher_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SubjectAltNameMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SubjectAltNameMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SanType != other.SanType) return false;
      if (!object.Equals(Matcher, other.Matcher)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (SanType != global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified) hash ^= SanType.GetHashCode();
      if (matcher_ != null) hash ^= Matcher.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (SanType != global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SanType);
      }
      if (matcher_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Matcher);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (SanType != global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) SanType);
      }
      if (matcher_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Matcher);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (SanType != global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SanType);
      }
      if (matcher_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Matcher);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SubjectAltNameMatcher other) {
      if (other == null) {
        return;
      }
      if (other.SanType != global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType.Unspecified) {
        SanType = other.SanType;
      }
      if (other.matcher_ != null) {
        if (matcher_ == null) {
          Matcher = new global::Envoy.Type.Matcher.V3.StringMatcher();
        }
        Matcher.MergeFrom(other.Matcher);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SanType = (global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType) input.ReadEnum();
            break;
          }
          case 18: {
            if (matcher_ == null) {
              Matcher = new global::Envoy.Type.Matcher.V3.StringMatcher();
            }
            input.ReadMessage(Matcher);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SanType = (global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Types.SanType) input.ReadEnum();
            break;
          }
          case 18: {
            if (matcher_ == null) {
              Matcher = new global::Envoy.Type.Matcher.V3.StringMatcher();
            }
            input.ReadMessage(Matcher);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SubjectAltNameMatcher message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
      /// against.
      /// </summary>
      public enum SanType {
        [pbr::OriginalName("SAN_TYPE_UNSPECIFIED")] Unspecified = 0,
        [pbr::OriginalName("EMAIL")] Email = 1,
        [pbr::OriginalName("DNS")] Dns = 2,
        [pbr::OriginalName("URI")] Uri = 3,
        [pbr::OriginalName("IP_ADDRESS")] IpAddress = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// [#next-free-field: 17]
  /// </summary>
  public sealed partial class CertificateValidationContext : pb::IMessage<CertificateValidationContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CertificateValidationContext> _parser = new pb::MessageParser<CertificateValidationContext>(() => new CertificateValidationContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CertificateValidationContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateValidationContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateValidationContext(CertificateValidationContext other) : this() {
      trustedCa_ = other.trustedCa_ != null ? other.trustedCa_.Clone() : null;
      caCertificateProviderInstance_ = other.caCertificateProviderInstance_ != null ? other.caCertificateProviderInstance_.Clone() : null;
      watchedDirectory_ = other.watchedDirectory_ != null ? other.watchedDirectory_.Clone() : null;
      verifyCertificateSpki_ = other.verifyCertificateSpki_.Clone();
      verifyCertificateHash_ = other.verifyCertificateHash_.Clone();
      matchTypedSubjectAltNames_ = other.matchTypedSubjectAltNames_.Clone();
      matchSubjectAltNames_ = other.matchSubjectAltNames_.Clone();
      RequireSignedCertificateTimestamp = other.RequireSignedCertificateTimestamp;
      crl_ = other.crl_ != null ? other.crl_.Clone() : null;
      allowExpiredCertificate_ = other.allowExpiredCertificate_;
      trustChainVerification_ = other.trustChainVerification_;
      customValidatorConfig_ = other.customValidatorConfig_ != null ? other.customValidatorConfig_.Clone() : null;
      onlyVerifyLeafCertCrl_ = other.onlyVerifyLeafCertCrl_;
      MaxVerifyDepth = other.MaxVerifyDepth;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CertificateValidationContext Clone() {
      return new CertificateValidationContext(this);
    }

    /// <summary>Field number for the "trusted_ca" field.</summary>
    public const int TrustedCaFieldNumber = 1;
    private global::Envoy.Config.Core.V3.DataSource trustedCa_;
    /// <summary>
    /// TLS certificate data containing certificate authority certificates to use in verifying
    /// a presented peer certificate (e.g. server certificate for clusters or client certificate
    /// for listeners). If not specified and a peer certificate is presented it will not be
    /// verified. By default, a client certificate is optional, unless one of the additional
    /// options (:ref:`require_client_certificate
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
    /// :ref:`match_typed_subject_alt_names
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`) is also
    /// specified.
    ///
    /// It can optionally contain certificate revocation lists, in which case Envoy will verify
    /// that the presented peer certificate has not been revoked by one of the included CRLs. Note
    /// that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
    /// provided for all certificate authorities in that chain. Failure to do so will result in
    /// verification failure for both revoked and unrevoked certificates from that chain.
    /// The behavior of requiring all certificates to contain CRLs if any do can be altered by
    /// setting :ref:`only_verify_leaf_cert_crl &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`
    /// true. If set to true, only the final certificate in the chain undergoes CRL verification.
    ///
    /// See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification>` for a list of common
    /// system CA locations.
    ///
    /// If ``trusted_ca`` is a filesystem path, a watch will be added to the parent
    /// directory for any file moves to support rotation. This currently only
    /// applies to dynamic secrets, when the ``CertificateValidationContext`` is
    /// delivered via SDS.
    ///
    /// X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca``
    /// can be treated as trust anchor as well. It allows verification with building valid partial chain instead
    /// of a full chain.
    ///
    /// Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
    ///
    /// [#next-major-version: This field and watched_directory below should ideally be moved into a
    /// separate sub-message, since there's no point in specifying the latter field without this one.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource TrustedCa {
      get { return trustedCa_; }
      set {
        trustedCa_ = value;
      }
    }

    /// <summary>Field number for the "ca_certificate_provider_instance" field.</summary>
    public const int CaCertificateProviderInstanceFieldNumber = 13;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance caCertificateProviderInstance_;
    /// <summary>
    /// Certificate provider instance for fetching TLS certificates.
    ///
    /// Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance CaCertificateProviderInstance {
      get { return caCertificateProviderInstance_; }
      set {
        caCertificateProviderInstance_ = value;
      }
    }

    /// <summary>Field number for the "watched_directory" field.</summary>
    public const int WatchedDirectoryFieldNumber = 11;
    private global::Envoy.Config.Core.V3.WatchedDirectory watchedDirectory_;
    /// <summary>
    /// If specified, updates of a file-based ``trusted_ca`` source will be triggered
    /// by this watch. This allows explicit control over the path watched, by
    /// default the parent directory of the filesystem path in ``trusted_ca`` is
    /// watched if this field is not specified. This only applies when a
    /// ``CertificateValidationContext`` is delivered by SDS with references to
    /// filesystem paths. See the :ref:`SDS key rotation &lt;sds_key_rotation>`
    /// documentation for further details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.WatchedDirectory WatchedDirectory {
      get { return watchedDirectory_; }
      set {
        watchedDirectory_ = value;
      }
    }

    /// <summary>Field number for the "verify_certificate_spki" field.</summary>
    public const int VerifyCertificateSpkiFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_verifyCertificateSpki_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> verifyCertificateSpki_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
    /// SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
    /// matches one of the specified values.
    ///
    /// A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
    /// can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -noout -pubkey
    ///     | openssl pkey -pubin -outform DER
    ///     | openssl dgst -sha256 -binary
    ///     | openssl enc -base64
    ///   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
    ///
    /// This is the format used in HTTP Public Key Pinning.
    ///
    /// When both:
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
    /// a hash matching value from either of the lists will result in the certificate being accepted.
    ///
    /// .. attention::
    ///
    ///   This option is preferred over :ref:`verify_certificate_hash
    ///   &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
    ///   because SPKI is tied to a private key, so it doesn't change when the certificate
    ///   is renewed using the same private key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> VerifyCertificateSpki {
      get { return verifyCertificateSpki_; }
    }

    /// <summary>Field number for the "verify_certificate_hash" field.</summary>
    public const int VerifyCertificateHashFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_verifyCertificateHash_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> verifyCertificateHash_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
    /// the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
    ///
    /// A hex-encoded SHA-256 of the certificate can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
    ///   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
    ///
    /// A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
    /// can be generated with the following command:
    ///
    /// .. code-block:: bash
    ///
    ///   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
    ///   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
    ///
    /// Both of those formats are acceptable.
    ///
    /// When both:
    /// :ref:`verify_certificate_hash
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
    /// :ref:`verify_certificate_spki
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
    /// a hash matching value from either of the lists will result in the certificate being accepted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> VerifyCertificateHash {
      get { return verifyCertificateHash_; }
    }

    /// <summary>Field number for the "match_typed_subject_alt_names" field.</summary>
    public const int MatchTypedSubjectAltNamesFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher> _repeated_matchTypedSubjectAltNames_codec
        = pb::FieldCodec.ForMessage(122, global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher> matchTypedSubjectAltNames_ = new pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher>();
    /// <summary>
    /// An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
    /// Subject Alternative Name of the presented certificate matches one of the specified matchers.
    /// The matching uses "any" semantics, that is to say, the SAN is verified if at least one matcher is
    /// matched.
    ///
    /// When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
    /// configured with exact match type in the :ref:`string matcher &lt;envoy_v3_api_msg_type.matcher.v3.StringMatcher>`.
    /// For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
    /// it should be configured as shown below.
    ///
    /// .. code-block:: yaml
    ///
    ///  match_typed_subject_alt_names:
    ///  - san_type: DNS
    ///    matcher:
    ///      exact: "api.example.com"
    ///
    /// .. attention::
    ///
    ///   Subject Alternative Names are easily spoofable and verifying only them is insecure,
    ///   therefore this option must be used together with :ref:`trusted_ca
    ///   &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SubjectAltNameMatcher> MatchTypedSubjectAltNames {
      get { return matchTypedSubjectAltNames_; }
    }

    /// <summary>Field number for the "match_subject_alt_names" field.</summary>
    public const int MatchSubjectAltNamesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Type.Matcher.V3.StringMatcher> _repeated_matchSubjectAltNames_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Type.Matcher.V3.StringMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher> matchSubjectAltNames_ = new pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher>();
    /// <summary>
    /// This field is deprecated in favor of
    /// :ref:`match_typed_subject_alt_names
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
    /// Note that if both this field and :ref:`match_typed_subject_alt_names
    /// &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
    /// are specified, the former (deprecated field) is ignored.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher> MatchSubjectAltNames {
      get { return matchSubjectAltNames_; }
    }

    /// <summary>Field number for the "require_signed_certificate_timestamp" field.</summary>
    public const int RequireSignedCertificateTimestampFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_requireSignedCertificateTimestamp_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? requireSignedCertificateTimestamp_;
    /// <summary>
    /// [#not-implemented-hide:] Must present signed certificate time-stamp.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? RequireSignedCertificateTimestamp {
      get { return requireSignedCertificateTimestamp_; }
      set {
        requireSignedCertificateTimestamp_ = value;
      }
    }


    /// <summary>Field number for the "crl" field.</summary>
    public const int CrlFieldNumber = 7;
    private global::Envoy.Config.Core.V3.DataSource crl_;
    /// <summary>
    /// An optional `certificate revocation list
    /// &lt;https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
    /// (in PEM format). If specified, Envoy will verify that the presented peer
    /// certificate has not been revoked by this CRL. If this DataSource contains
    /// multiple CRLs, all of them will be used. Note that if a CRL is provided
    /// for any certificate authority in a trust chain, a CRL must be provided
    /// for all certificate authorities in that chain. Failure to do so will
    /// result in verification failure for both revoked and unrevoked certificates
    /// from that chain. This default behavior can be altered by setting
    /// :ref:`only_verify_leaf_cert_crl &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>` to
    /// true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource Crl {
      get { return crl_; }
      set {
        crl_ = value;
      }
    }

    /// <summary>Field number for the "allow_expired_certificate" field.</summary>
    public const int AllowExpiredCertificateFieldNumber = 8;
    private bool allowExpiredCertificate_;
    /// <summary>
    /// If specified, Envoy will not reject expired certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowExpiredCertificate {
      get { return allowExpiredCertificate_; }
      set {
        allowExpiredCertificate_ = value;
      }
    }

    /// <summary>Field number for the "trust_chain_verification" field.</summary>
    public const int TrustChainVerificationFieldNumber = 10;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification trustChainVerification_ = global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain;
    /// <summary>
    /// Certificate trust chain verification mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification TrustChainVerification {
      get { return trustChainVerification_; }
      set {
        trustChainVerification_ = value;
      }
    }

    /// <summary>Field number for the "custom_validator_config" field.</summary>
    public const int CustomValidatorConfigFieldNumber = 12;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig customValidatorConfig_;
    /// <summary>
    /// The configuration of an extension specific certificate validator.
    /// If specified, all validation is done by the specified validator,
    /// and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated).
    /// Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field.
    /// [#extension-category: envoy.tls.cert_validator]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig CustomValidatorConfig {
      get { return customValidatorConfig_; }
      set {
        customValidatorConfig_ = value;
      }
    }

    /// <summary>Field number for the "only_verify_leaf_cert_crl" field.</summary>
    public const int OnlyVerifyLeafCertCrlFieldNumber = 14;
    private bool onlyVerifyLeafCertCrl_;
    /// <summary>
    /// If this option is set to true, only the certificate at the end of the
    /// certificate chain will be subject to validation by :ref:`CRL &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OnlyVerifyLeafCertCrl {
      get { return onlyVerifyLeafCertCrl_; }
      set {
        onlyVerifyLeafCertCrl_ = value;
      }
    }

    /// <summary>Field number for the "max_verify_depth" field.</summary>
    public const int MaxVerifyDepthFieldNumber = 16;
    private static readonly pb::FieldCodec<uint?> _single_maxVerifyDepth_codec = pb::FieldCodec.ForStructWrapper<uint>(130);
    private uint? maxVerifyDepth_;
    /// <summary>
    /// Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent.
    /// This number does not include the leaf, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer appears in the chain,
    /// but in a depth larger than configured, the certificate validation will fail.
    /// See `BoringSSL SSL_CTX_set_verify_depth &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_CTX_set_verify_depth>`
    /// If you use OpenSSL, its behavior is different from BoringSSL, this will define a limit on the number of certificates between the end-entity and trust-anchor certificates.
    /// Neither the end-entity nor the trust-anchor certificates count against depth.
    /// See `OpenSSL SSL set_verify_depth &lt;https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_verify_depth.html>`_.
    /// Trusted issues are specified by setting :ref:`trusted_ca &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxVerifyDepth {
      get { return maxVerifyDepth_; }
      set {
        maxVerifyDepth_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CertificateValidationContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CertificateValidationContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TrustedCa, other.TrustedCa)) return false;
      if (!object.Equals(CaCertificateProviderInstance, other.CaCertificateProviderInstance)) return false;
      if (!object.Equals(WatchedDirectory, other.WatchedDirectory)) return false;
      if(!verifyCertificateSpki_.Equals(other.verifyCertificateSpki_)) return false;
      if(!verifyCertificateHash_.Equals(other.verifyCertificateHash_)) return false;
      if(!matchTypedSubjectAltNames_.Equals(other.matchTypedSubjectAltNames_)) return false;
      if(!matchSubjectAltNames_.Equals(other.matchSubjectAltNames_)) return false;
      if (RequireSignedCertificateTimestamp != other.RequireSignedCertificateTimestamp) return false;
      if (!object.Equals(Crl, other.Crl)) return false;
      if (AllowExpiredCertificate != other.AllowExpiredCertificate) return false;
      if (TrustChainVerification != other.TrustChainVerification) return false;
      if (!object.Equals(CustomValidatorConfig, other.CustomValidatorConfig)) return false;
      if (OnlyVerifyLeafCertCrl != other.OnlyVerifyLeafCertCrl) return false;
      if (MaxVerifyDepth != other.MaxVerifyDepth) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (trustedCa_ != null) hash ^= TrustedCa.GetHashCode();
      if (caCertificateProviderInstance_ != null) hash ^= CaCertificateProviderInstance.GetHashCode();
      if (watchedDirectory_ != null) hash ^= WatchedDirectory.GetHashCode();
      hash ^= verifyCertificateSpki_.GetHashCode();
      hash ^= verifyCertificateHash_.GetHashCode();
      hash ^= matchTypedSubjectAltNames_.GetHashCode();
      hash ^= matchSubjectAltNames_.GetHashCode();
      if (requireSignedCertificateTimestamp_ != null) hash ^= RequireSignedCertificateTimestamp.GetHashCode();
      if (crl_ != null) hash ^= Crl.GetHashCode();
      if (AllowExpiredCertificate != false) hash ^= AllowExpiredCertificate.GetHashCode();
      if (TrustChainVerification != global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain) hash ^= TrustChainVerification.GetHashCode();
      if (customValidatorConfig_ != null) hash ^= CustomValidatorConfig.GetHashCode();
      if (OnlyVerifyLeafCertCrl != false) hash ^= OnlyVerifyLeafCertCrl.GetHashCode();
      if (maxVerifyDepth_ != null) hash ^= MaxVerifyDepth.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (trustedCa_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrustedCa);
      }
      verifyCertificateHash_.WriteTo(output, _repeated_verifyCertificateHash_codec);
      verifyCertificateSpki_.WriteTo(output, _repeated_verifyCertificateSpki_codec);
      if (requireSignedCertificateTimestamp_ != null) {
        _single_requireSignedCertificateTimestamp_codec.WriteTagAndValue(output, RequireSignedCertificateTimestamp);
      }
      if (crl_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Crl);
      }
      if (AllowExpiredCertificate != false) {
        output.WriteRawTag(64);
        output.WriteBool(AllowExpiredCertificate);
      }
      matchSubjectAltNames_.WriteTo(output, _repeated_matchSubjectAltNames_codec);
      if (TrustChainVerification != global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain) {
        output.WriteRawTag(80);
        output.WriteEnum((int) TrustChainVerification);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(WatchedDirectory);
      }
      if (customValidatorConfig_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CustomValidatorConfig);
      }
      if (caCertificateProviderInstance_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CaCertificateProviderInstance);
      }
      if (OnlyVerifyLeafCertCrl != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnlyVerifyLeafCertCrl);
      }
      matchTypedSubjectAltNames_.WriteTo(output, _repeated_matchTypedSubjectAltNames_codec);
      if (maxVerifyDepth_ != null) {
        _single_maxVerifyDepth_codec.WriteTagAndValue(output, MaxVerifyDepth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (trustedCa_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrustedCa);
      }
      verifyCertificateHash_.WriteTo(ref output, _repeated_verifyCertificateHash_codec);
      verifyCertificateSpki_.WriteTo(ref output, _repeated_verifyCertificateSpki_codec);
      if (requireSignedCertificateTimestamp_ != null) {
        _single_requireSignedCertificateTimestamp_codec.WriteTagAndValue(ref output, RequireSignedCertificateTimestamp);
      }
      if (crl_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Crl);
      }
      if (AllowExpiredCertificate != false) {
        output.WriteRawTag(64);
        output.WriteBool(AllowExpiredCertificate);
      }
      matchSubjectAltNames_.WriteTo(ref output, _repeated_matchSubjectAltNames_codec);
      if (TrustChainVerification != global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain) {
        output.WriteRawTag(80);
        output.WriteEnum((int) TrustChainVerification);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(WatchedDirectory);
      }
      if (customValidatorConfig_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(CustomValidatorConfig);
      }
      if (caCertificateProviderInstance_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CaCertificateProviderInstance);
      }
      if (OnlyVerifyLeafCertCrl != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnlyVerifyLeafCertCrl);
      }
      matchTypedSubjectAltNames_.WriteTo(ref output, _repeated_matchTypedSubjectAltNames_codec);
      if (maxVerifyDepth_ != null) {
        _single_maxVerifyDepth_codec.WriteTagAndValue(ref output, MaxVerifyDepth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (trustedCa_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrustedCa);
      }
      if (caCertificateProviderInstance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CaCertificateProviderInstance);
      }
      if (watchedDirectory_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WatchedDirectory);
      }
      size += verifyCertificateSpki_.CalculateSize(_repeated_verifyCertificateSpki_codec);
      size += verifyCertificateHash_.CalculateSize(_repeated_verifyCertificateHash_codec);
      size += matchTypedSubjectAltNames_.CalculateSize(_repeated_matchTypedSubjectAltNames_codec);
      size += matchSubjectAltNames_.CalculateSize(_repeated_matchSubjectAltNames_codec);
      if (requireSignedCertificateTimestamp_ != null) {
        size += _single_requireSignedCertificateTimestamp_codec.CalculateSizeWithTag(RequireSignedCertificateTimestamp);
      }
      if (crl_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Crl);
      }
      if (AllowExpiredCertificate != false) {
        size += 1 + 1;
      }
      if (TrustChainVerification != global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TrustChainVerification);
      }
      if (customValidatorConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CustomValidatorConfig);
      }
      if (OnlyVerifyLeafCertCrl != false) {
        size += 1 + 1;
      }
      if (maxVerifyDepth_ != null) {
        size += _single_maxVerifyDepth_codec.CalculateSizeWithTag(MaxVerifyDepth);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CertificateValidationContext other) {
      if (other == null) {
        return;
      }
      if (other.trustedCa_ != null) {
        if (trustedCa_ == null) {
          TrustedCa = new global::Envoy.Config.Core.V3.DataSource();
        }
        TrustedCa.MergeFrom(other.TrustedCa);
      }
      if (other.caCertificateProviderInstance_ != null) {
        if (caCertificateProviderInstance_ == null) {
          CaCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
        }
        CaCertificateProviderInstance.MergeFrom(other.CaCertificateProviderInstance);
      }
      if (other.watchedDirectory_ != null) {
        if (watchedDirectory_ == null) {
          WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
        }
        WatchedDirectory.MergeFrom(other.WatchedDirectory);
      }
      verifyCertificateSpki_.Add(other.verifyCertificateSpki_);
      verifyCertificateHash_.Add(other.verifyCertificateHash_);
      matchTypedSubjectAltNames_.Add(other.matchTypedSubjectAltNames_);
      matchSubjectAltNames_.Add(other.matchSubjectAltNames_);
      if (other.requireSignedCertificateTimestamp_ != null) {
        if (requireSignedCertificateTimestamp_ == null || other.RequireSignedCertificateTimestamp != false) {
          RequireSignedCertificateTimestamp = other.RequireSignedCertificateTimestamp;
        }
      }
      if (other.crl_ != null) {
        if (crl_ == null) {
          Crl = new global::Envoy.Config.Core.V3.DataSource();
        }
        Crl.MergeFrom(other.Crl);
      }
      if (other.AllowExpiredCertificate != false) {
        AllowExpiredCertificate = other.AllowExpiredCertificate;
      }
      if (other.TrustChainVerification != global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification.VerifyTrustChain) {
        TrustChainVerification = other.TrustChainVerification;
      }
      if (other.customValidatorConfig_ != null) {
        if (customValidatorConfig_ == null) {
          CustomValidatorConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        CustomValidatorConfig.MergeFrom(other.CustomValidatorConfig);
      }
      if (other.OnlyVerifyLeafCertCrl != false) {
        OnlyVerifyLeafCertCrl = other.OnlyVerifyLeafCertCrl;
      }
      if (other.maxVerifyDepth_ != null) {
        if (maxVerifyDepth_ == null || other.MaxVerifyDepth != 0) {
          MaxVerifyDepth = other.MaxVerifyDepth;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (trustedCa_ == null) {
              TrustedCa = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(TrustedCa);
            break;
          }
          case 18: {
            verifyCertificateHash_.AddEntriesFrom(input, _repeated_verifyCertificateHash_codec);
            break;
          }
          case 26: {
            verifyCertificateSpki_.AddEntriesFrom(input, _repeated_verifyCertificateSpki_codec);
            break;
          }
          case 50: {
            bool? value = _single_requireSignedCertificateTimestamp_codec.Read(input);
            if (requireSignedCertificateTimestamp_ == null || value != false) {
              RequireSignedCertificateTimestamp = value;
            }
            break;
          }
          case 58: {
            if (crl_ == null) {
              Crl = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Crl);
            break;
          }
          case 64: {
            AllowExpiredCertificate = input.ReadBool();
            break;
          }
          case 74: {
            matchSubjectAltNames_.AddEntriesFrom(input, _repeated_matchSubjectAltNames_codec);
            break;
          }
          case 80: {
            TrustChainVerification = (global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification) input.ReadEnum();
            break;
          }
          case 90: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
          case 98: {
            if (customValidatorConfig_ == null) {
              CustomValidatorConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(CustomValidatorConfig);
            break;
          }
          case 106: {
            if (caCertificateProviderInstance_ == null) {
              CaCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
            }
            input.ReadMessage(CaCertificateProviderInstance);
            break;
          }
          case 112: {
            OnlyVerifyLeafCertCrl = input.ReadBool();
            break;
          }
          case 122: {
            matchTypedSubjectAltNames_.AddEntriesFrom(input, _repeated_matchTypedSubjectAltNames_codec);
            break;
          }
          case 130: {
            uint? value = _single_maxVerifyDepth_codec.Read(input);
            if (maxVerifyDepth_ == null || value != 0) {
              MaxVerifyDepth = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (trustedCa_ == null) {
              TrustedCa = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(TrustedCa);
            break;
          }
          case 18: {
            verifyCertificateHash_.AddEntriesFrom(ref input, _repeated_verifyCertificateHash_codec);
            break;
          }
          case 26: {
            verifyCertificateSpki_.AddEntriesFrom(ref input, _repeated_verifyCertificateSpki_codec);
            break;
          }
          case 50: {
            bool? value = _single_requireSignedCertificateTimestamp_codec.Read(ref input);
            if (requireSignedCertificateTimestamp_ == null || value != false) {
              RequireSignedCertificateTimestamp = value;
            }
            break;
          }
          case 58: {
            if (crl_ == null) {
              Crl = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Crl);
            break;
          }
          case 64: {
            AllowExpiredCertificate = input.ReadBool();
            break;
          }
          case 74: {
            matchSubjectAltNames_.AddEntriesFrom(ref input, _repeated_matchSubjectAltNames_codec);
            break;
          }
          case 80: {
            TrustChainVerification = (global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext.Types.TrustChainVerification) input.ReadEnum();
            break;
          }
          case 90: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
          case 98: {
            if (customValidatorConfig_ == null) {
              CustomValidatorConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(CustomValidatorConfig);
            break;
          }
          case 106: {
            if (caCertificateProviderInstance_ == null) {
              CaCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
            }
            input.ReadMessage(CaCertificateProviderInstance);
            break;
          }
          case 112: {
            OnlyVerifyLeafCertCrl = input.ReadBool();
            break;
          }
          case 122: {
            matchTypedSubjectAltNames_.AddEntriesFrom(ref input, _repeated_matchTypedSubjectAltNames_codec);
            break;
          }
          case 130: {
            uint? value = _single_maxVerifyDepth_codec.Read(ref input);
            if (maxVerifyDepth_ == null || value != 0) {
              MaxVerifyDepth = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CertificateValidationContext message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Peer certificate verification mode.
      /// </summary>
      public enum TrustChainVerification {
        /// <summary>
        /// Perform default certificate verification (e.g., against CA / verification lists)
        /// </summary>
        [pbr::OriginalName("VERIFY_TRUST_CHAIN")] VerifyTrustChain = 0,
        /// <summary>
        /// Connections where the certificate fails verification will be permitted.
        /// For HTTP connections, the result of certificate verification can be used in route matching. (
        /// see :ref:`validated &lt;envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
        /// </summary>
        [pbr::OriginalName("ACCEPT_UNTRUSTED")] AcceptUntrusted = 1,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
