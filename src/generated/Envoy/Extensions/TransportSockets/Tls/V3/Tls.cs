// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/extensions/transport_sockets/tls/v3/tls.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Extensions.TransportSockets.Tls.V3 {

  /// <summary>Holder for reflection information generated from envoy/extensions/transport_sockets/tls/v3/tls.proto</summary>
  public static partial class TlsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/extensions/transport_sockets/tls/v3/tls.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TlsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjNlbnZveS9leHRlbnNpb25zL3RyYW5zcG9ydF9zb2NrZXRzL3Rscy92My90",
            "bHMucHJvdG8SKWVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMu",
            "dGxzLnYzGiJlbnZveS9jb25maWcvY29yZS92My9hZGRyZXNzLnByb3RvGiRl",
            "bnZveS9jb25maWcvY29yZS92My9leHRlbnNpb24ucHJvdG8aNmVudm95L2V4",
            "dGVuc2lvbnMvdHJhbnNwb3J0X3NvY2tldHMvdGxzL3YzL2NvbW1vbi5wcm90",
            "bxo2ZW52b3kvZXh0ZW5zaW9ucy90cmFuc3BvcnRfc29ja2V0cy90bHMvdjMv",
            "c2VjcmV0LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8a",
            "Hmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90bxojZW52b3kvYW5ub3Rh",
            "dGlvbnMvZGVwcmVjYXRpb24ucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMvc3Rh",
            "dHVzLnByb3RvGiF1ZHBhL2Fubm90YXRpb25zL3ZlcnNpb25pbmcucHJvdG8a",
            "F3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIoYCChJVcHN0cmVhbVRsc0NvbnRl",
            "eHQSVwoSY29tbW9uX3Rsc19jb250ZXh0GAEgASgLMjsuZW52b3kuZXh0ZW5z",
            "aW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuQ29tbW9uVGxzQ29udGV4",
            "dBIVCgNzbmkYAiABKAlCCPpCBXIDKP8BEhsKE2FsbG93X3JlbmVnb3RpYXRp",
            "b24YAyABKAgSNgoQbWF4X3Nlc3Npb25fa2V5cxgEIAEoCzIcLmdvb2dsZS5w",
            "cm90b2J1Zi5VSW50MzJWYWx1ZTormsWIHiYKJGVudm95LmFwaS52Mi5hdXRo",
            "LlVwc3RyZWFtVGxzQ29udGV4dCL7BgoURG93bnN0cmVhbVRsc0NvbnRleHQS",
            "VwoSY29tbW9uX3Rsc19jb250ZXh0GAEgASgLMjsuZW52b3kuZXh0ZW5zaW9u",
            "cy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuQ29tbW9uVGxzQ29udGV4dBI+",
            "ChpyZXF1aXJlX2NsaWVudF9jZXJ0aWZpY2F0ZRgCIAEoCzIaLmdvb2dsZS5w",
            "cm90b2J1Zi5Cb29sVmFsdWUSLwoLcmVxdWlyZV9zbmkYAyABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuQm9vbFZhbHVlEl4KE3Nlc3Npb25fdGlja2V0X2tleXMY",
            "BCABKAsyPy5lbnZveS5leHRlbnNpb25zLnRyYW5zcG9ydF9zb2NrZXRzLnRs",
            "cy52My5UbHNTZXNzaW9uVGlja2V0S2V5c0gAEmsKJXNlc3Npb25fdGlja2V0",
            "X2tleXNfc2RzX3NlY3JldF9jb25maWcYBSABKAsyOi5lbnZveS5leHRlbnNp",
            "b25zLnRyYW5zcG9ydF9zb2NrZXRzLnRscy52My5TZHNTZWNyZXRDb25maWdI",
            "ABIuCiRkaXNhYmxlX3N0YXRlbGVzc19zZXNzaW9uX3Jlc3VtcHRpb24YByAB",
            "KAhIABJECg9zZXNzaW9uX3RpbWVvdXQYBiABKAsyGS5nb29nbGUucHJvdG9i",
            "dWYuRHVyYXRpb25CEPpCDaoBChoGCICAgIAQMgASdgoSb2NzcF9zdGFwbGVf",
            "cG9saWN5GAggASgOMlAuZW52b3kuZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29j",
            "a2V0cy50bHMudjMuRG93bnN0cmVhbVRsc0NvbnRleHQuT2NzcFN0YXBsZVBv",
            "bGljeUII+kIFggECEAESQwofZnVsbF9zY2FuX2NlcnRzX29uX3NuaV9taXNt",
            "YXRjaBgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUiTgoQT2Nz",
            "cFN0YXBsZVBvbGljeRIUChBMRU5JRU5UX1NUQVBMSU5HEAASEwoPU1RSSUNU",
            "X1NUQVBMSU5HEAESDwoLTVVTVF9TVEFQTEUQAjotmsWIHigKJmVudm95LmFw",
            "aS52Mi5hdXRoLkRvd25zdHJlYW1UbHNDb250ZXh0QhoKGHNlc3Npb25fdGlj",
            "a2V0X2tleXNfdHlwZSKfAQoJVGxzS2V5TG9nEhUKBHBhdGgYASABKAlCB/pC",
            "BHICEAESPAoTbG9jYWxfYWRkcmVzc19yYW5nZRgCIAMoCzIfLmVudm95LmNv",
            "bmZpZy5jb3JlLnYzLkNpZHJSYW5nZRI9ChRyZW1vdGVfYWRkcmVzc19yYW5n",
            "ZRgDIAMoCzIfLmVudm95LmNvbmZpZy5jb3JlLnYzLkNpZHJSYW5nZSKrEwoQ",
            "Q29tbW9uVGxzQ29udGV4dBJMCgp0bHNfcGFyYW1zGAEgASgLMjguZW52b3ku",
            "ZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuVGxzUGFyYW1l",
            "dGVycxJTChB0bHNfY2VydGlmaWNhdGVzGAIgAygLMjkuZW52b3kuZXh0ZW5z",
            "aW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuVGxzQ2VydGlmaWNhdGUS",
            "ZgoidGxzX2NlcnRpZmljYXRlX3Nkc19zZWNyZXRfY29uZmlncxgGIAMoCzI6",
            "LmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMudGxzLnYzLlNk",
            "c1NlY3JldENvbmZpZxJ3CiF0bHNfY2VydGlmaWNhdGVfcHJvdmlkZXJfaW5z",
            "dGFuY2UYDiABKAsyTC5lbnZveS5leHRlbnNpb25zLnRyYW5zcG9ydF9zb2Nr",
            "ZXRzLnRscy52My5DZXJ0aWZpY2F0ZVByb3ZpZGVyUGx1Z2luSW5zdGFuY2US",
            "igEKJHRsc19jZXJ0aWZpY2F0ZV9jZXJ0aWZpY2F0ZV9wcm92aWRlchgJIAEo",
            "CzJPLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMudGxzLnYz",
            "LkNvbW1vblRsc0NvbnRleHQuQ2VydGlmaWNhdGVQcm92aWRlckILGAGSx4bY",
            "BAMzLjASmwEKLXRsc19jZXJ0aWZpY2F0ZV9jZXJ0aWZpY2F0ZV9wcm92aWRl",
            "cl9pbnN0YW5jZRgLIAEoCzJXLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0",
            "X3NvY2tldHMudGxzLnYzLkNvbW1vblRsc0NvbnRleHQuQ2VydGlmaWNhdGVQ",
            "cm92aWRlckluc3RhbmNlQgsYAZLHhtgEAzMuMBJlChJ2YWxpZGF0aW9uX2Nv",
            "bnRleHQYAyABKAsyRy5lbnZveS5leHRlbnNpb25zLnRyYW5zcG9ydF9zb2Nr",
            "ZXRzLnRscy52My5DZXJ0aWZpY2F0ZVZhbGlkYXRpb25Db250ZXh0SAASagok",
            "dmFsaWRhdGlvbl9jb250ZXh0X3Nkc19zZWNyZXRfY29uZmlnGAcgASgLMjou",
            "ZW52b3kuZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuU2Rz",
            "U2VjcmV0Q29uZmlnSAAShwEKG2NvbWJpbmVkX3ZhbGlkYXRpb25fY29udGV4",
            "dBgIIAEoCzJgLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMu",
            "dGxzLnYzLkNvbW1vblRsc0NvbnRleHQuQ29tYmluZWRDZXJ0aWZpY2F0ZVZh",
            "bGlkYXRpb25Db250ZXh0SAASjwEKJ3ZhbGlkYXRpb25fY29udGV4dF9jZXJ0",
            "aWZpY2F0ZV9wcm92aWRlchgKIAEoCzJPLmVudm95LmV4dGVuc2lvbnMudHJh",
            "bnNwb3J0X3NvY2tldHMudGxzLnYzLkNvbW1vblRsc0NvbnRleHQuQ2VydGlm",
            "aWNhdGVQcm92aWRlckILGAGSx4bYBAMzLjBIABKgAQowdmFsaWRhdGlvbl9j",
            "b250ZXh0X2NlcnRpZmljYXRlX3Byb3ZpZGVyX2luc3RhbmNlGAwgASgLMlcu",
            "ZW52b3kuZXh0ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuQ29t",
            "bW9uVGxzQ29udGV4dC5DZXJ0aWZpY2F0ZVByb3ZpZGVySW5zdGFuY2VCCxgB",
            "kseG2AQDMy4wSAASFgoOYWxwbl9wcm90b2NvbHMYBCADKAkSRQoRY3VzdG9t",
            "X2hhbmRzaGFrZXIYDSABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5UeXBl",
            "ZEV4dGVuc2lvbkNvbmZpZxJFCgdrZXlfbG9nGA8gASgLMjQuZW52b3kuZXh0",
            "ZW5zaW9ucy50cmFuc3BvcnRfc29ja2V0cy50bHMudjMuVGxzS2V5TG9nGn8K",
            "E0NlcnRpZmljYXRlUHJvdmlkZXISFQoEbmFtZRgBIAEoCUIH+kIEcgIQARJC",
            "Cgx0eXBlZF9jb25maWcYAiABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5U",
            "eXBlZEV4dGVuc2lvbkNvbmZpZ0gAQg0KBmNvbmZpZxID+EIBGk4KG0NlcnRp",
            "ZmljYXRlUHJvdmlkZXJJbnN0YW5jZRIVCg1pbnN0YW5jZV9uYW1lGAEgASgJ",
            "EhgKEGNlcnRpZmljYXRlX25hbWUYAiABKAkakgUKJENvbWJpbmVkQ2VydGlm",
            "aWNhdGVWYWxpZGF0aW9uQ29udGV4dBJ1ChpkZWZhdWx0X3ZhbGlkYXRpb25f",
            "Y29udGV4dBgBIAEoCzJHLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3Nv",
            "Y2tldHMudGxzLnYzLkNlcnRpZmljYXRlVmFsaWRhdGlvbkNvbnRleHRCCPpC",
            "BYoBAhABEnIKJHZhbGlkYXRpb25fY29udGV4dF9zZHNfc2VjcmV0X2NvbmZp",
            "ZxgCIAEoCzI6LmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMu",
            "dGxzLnYzLlNkc1NlY3JldENvbmZpZ0II+kIFigECEAESjQEKJ3ZhbGlkYXRp",
            "b25fY29udGV4dF9jZXJ0aWZpY2F0ZV9wcm92aWRlchgDIAEoCzJPLmVudm95",
            "LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tldHMudGxzLnYzLkNvbW1vblRs",
            "c0NvbnRleHQuQ2VydGlmaWNhdGVQcm92aWRlckILGAGSx4bYBAMzLjASngEK",
            "MHZhbGlkYXRpb25fY29udGV4dF9jZXJ0aWZpY2F0ZV9wcm92aWRlcl9pbnN0",
            "YW5jZRgEIAEoCzJXLmVudm95LmV4dGVuc2lvbnMudHJhbnNwb3J0X3NvY2tl",
            "dHMudGxzLnYzLkNvbW1vblRsc0NvbnRleHQuQ2VydGlmaWNhdGVQcm92aWRl",
            "ckluc3RhbmNlQgsYAZLHhtgEAzMuMDpOmsWIHkkKR2Vudm95LmFwaS52Mi5h",
            "dXRoLkNvbW1vblRsc0NvbnRleHQuQ29tYmluZWRDZXJ0aWZpY2F0ZVZhbGlk",
            "YXRpb25Db250ZXh0OimaxYgeJAoiZW52b3kuYXBpLnYyLmF1dGguQ29tbW9u",
            "VGxzQ29udGV4dEIZChd2YWxpZGF0aW9uX2NvbnRleHRfdHlwZUoECAUQBkKl",
            "AQo3aW8uZW52b3lwcm94eS5lbnZveS5leHRlbnNpb25zLnRyYW5zcG9ydF9z",
            "b2NrZXRzLnRscy52M0IIVGxzUHJvdG9QAVpWZ2l0aHViLmNvbS9lbnZveXBy",
            "b3h5L2dvLWNvbnRyb2wtcGxhbmUvZW52b3kvZXh0ZW5zaW9ucy90cmFuc3Bv",
            "cnRfc29ja2V0cy90bHMvdjM7dGxzdjO6gMjRBgIQAmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Extensions.TransportSockets.Tls.V3.CommonReflection.Descriptor, global::Envoy.Extensions.TransportSockets.Tls.V3.SecretReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.UpstreamTlsContext), global::Envoy.Extensions.TransportSockets.Tls.V3.UpstreamTlsContext.Parser, new[]{ "CommonTlsContext", "Sni", "AllowRenegotiation", "MaxSessionKeys" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext), global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Parser, new[]{ "CommonTlsContext", "RequireClientCertificate", "RequireSni", "SessionTicketKeys", "SessionTicketKeysSdsSecretConfig", "DisableStatelessSessionResumption", "SessionTimeout", "OcspStaplePolicy", "FullScanCertsOnSniMismatch" }, new[]{ "SessionTicketKeysType" }, new[]{ typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog), global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog.Parser, new[]{ "Path", "LocalAddressRange", "RemoteAddressRange" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext), global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Parser, new[]{ "TlsParams", "TlsCertificates", "TlsCertificateSdsSecretConfigs", "TlsCertificateProviderInstance", "TlsCertificateCertificateProvider", "TlsCertificateCertificateProviderInstance", "ValidationContext", "ValidationContextSdsSecretConfig", "CombinedValidationContext", "ValidationContextCertificateProvider", "ValidationContextCertificateProviderInstance", "AlpnProtocols", "CustomHandshaker", "KeyLog" }, new[]{ "ValidationContextType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider), global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider.Parser, new[]{ "Name", "TypedConfig" }, new[]{ "Config" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance), global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance.Parser, new[]{ "InstanceName", "CertificateName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext), global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext.Parser, new[]{ "DefaultValidationContext", "ValidationContextSdsSecretConfig", "ValidationContextCertificateProvider", "ValidationContextCertificateProviderInstance" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class UpstreamTlsContext : pb::IMessage<UpstreamTlsContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamTlsContext> _parser = new pb::MessageParser<UpstreamTlsContext>(() => new UpstreamTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.TlsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamTlsContext(UpstreamTlsContext other) : this() {
      commonTlsContext_ = other.commonTlsContext_ != null ? other.commonTlsContext_.Clone() : null;
      sni_ = other.sni_;
      allowRenegotiation_ = other.allowRenegotiation_;
      MaxSessionKeys = other.MaxSessionKeys;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamTlsContext Clone() {
      return new UpstreamTlsContext(this);
    }

    /// <summary>Field number for the "common_tls_context" field.</summary>
    public const int CommonTlsContextFieldNumber = 1;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext commonTlsContext_;
    /// <summary>
    /// Common TLS context settings.
    ///
    /// .. attention::
    ///
    ///   Server certificate verification is not enabled by default. Configure
    ///   :ref:`trusted_ca&lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
    ///   verification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext CommonTlsContext {
      get { return commonTlsContext_; }
      set {
        commonTlsContext_ = value;
      }
    }

    /// <summary>Field number for the "sni" field.</summary>
    public const int SniFieldNumber = 2;
    private string sni_ = "";
    /// <summary>
    /// SNI string to use when creating TLS backend connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Sni {
      get { return sni_; }
      set {
        sni_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_renegotiation" field.</summary>
    public const int AllowRenegotiationFieldNumber = 3;
    private bool allowRenegotiation_;
    /// <summary>
    /// If true, server-initiated TLS renegotiation will be allowed.
    ///
    /// .. attention::
    ///
    ///   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowRenegotiation {
      get { return allowRenegotiation_; }
      set {
        allowRenegotiation_ = value;
      }
    }

    /// <summary>Field number for the "max_session_keys" field.</summary>
    public const int MaxSessionKeysFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_maxSessionKeys_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? maxSessionKeys_;
    /// <summary>
    /// Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
    /// for TLSv1.2 and older) to store for the purpose of session resumption.
    ///
    /// Defaults to 1, setting this to 0 disables session resumption.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxSessionKeys {
      get { return maxSessionKeys_; }
      set {
        maxSessionKeys_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CommonTlsContext, other.CommonTlsContext)) return false;
      if (Sni != other.Sni) return false;
      if (AllowRenegotiation != other.AllowRenegotiation) return false;
      if (MaxSessionKeys != other.MaxSessionKeys) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (commonTlsContext_ != null) hash ^= CommonTlsContext.GetHashCode();
      if (Sni.Length != 0) hash ^= Sni.GetHashCode();
      if (AllowRenegotiation != false) hash ^= AllowRenegotiation.GetHashCode();
      if (maxSessionKeys_ != null) hash ^= MaxSessionKeys.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (Sni.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Sni);
      }
      if (AllowRenegotiation != false) {
        output.WriteRawTag(24);
        output.WriteBool(AllowRenegotiation);
      }
      if (maxSessionKeys_ != null) {
        _single_maxSessionKeys_codec.WriteTagAndValue(output, MaxSessionKeys);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (Sni.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Sni);
      }
      if (AllowRenegotiation != false) {
        output.WriteRawTag(24);
        output.WriteBool(AllowRenegotiation);
      }
      if (maxSessionKeys_ != null) {
        _single_maxSessionKeys_codec.WriteTagAndValue(ref output, MaxSessionKeys);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (commonTlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CommonTlsContext);
      }
      if (Sni.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Sni);
      }
      if (AllowRenegotiation != false) {
        size += 1 + 1;
      }
      if (maxSessionKeys_ != null) {
        size += _single_maxSessionKeys_codec.CalculateSizeWithTag(MaxSessionKeys);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.commonTlsContext_ != null) {
        if (commonTlsContext_ == null) {
          CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
        }
        CommonTlsContext.MergeFrom(other.CommonTlsContext);
      }
      if (other.Sni.Length != 0) {
        Sni = other.Sni;
      }
      if (other.AllowRenegotiation != false) {
        AllowRenegotiation = other.AllowRenegotiation;
      }
      if (other.maxSessionKeys_ != null) {
        if (maxSessionKeys_ == null || other.MaxSessionKeys != 0) {
          MaxSessionKeys = other.MaxSessionKeys;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
            }
            input.ReadMessage(CommonTlsContext);
            break;
          }
          case 18: {
            Sni = input.ReadString();
            break;
          }
          case 24: {
            AllowRenegotiation = input.ReadBool();
            break;
          }
          case 34: {
            uint? value = _single_maxSessionKeys_codec.Read(input);
            if (maxSessionKeys_ == null || value != 0) {
              MaxSessionKeys = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
            }
            input.ReadMessage(CommonTlsContext);
            break;
          }
          case 18: {
            Sni = input.ReadString();
            break;
          }
          case 24: {
            AllowRenegotiation = input.ReadBool();
            break;
          }
          case 34: {
            uint? value = _single_maxSessionKeys_codec.Read(ref input);
            if (maxSessionKeys_ == null || value != 0) {
              MaxSessionKeys = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 10]
  /// </summary>
  public sealed partial class DownstreamTlsContext : pb::IMessage<DownstreamTlsContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DownstreamTlsContext> _parser = new pb::MessageParser<DownstreamTlsContext>(() => new DownstreamTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DownstreamTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.TlsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownstreamTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownstreamTlsContext(DownstreamTlsContext other) : this() {
      commonTlsContext_ = other.commonTlsContext_ != null ? other.commonTlsContext_.Clone() : null;
      RequireClientCertificate = other.RequireClientCertificate;
      RequireSni = other.RequireSni;
      sessionTimeout_ = other.sessionTimeout_ != null ? other.sessionTimeout_.Clone() : null;
      ocspStaplePolicy_ = other.ocspStaplePolicy_;
      FullScanCertsOnSniMismatch = other.FullScanCertsOnSniMismatch;
      switch (other.SessionTicketKeysTypeCase) {
        case SessionTicketKeysTypeOneofCase.SessionTicketKeys:
          SessionTicketKeys = other.SessionTicketKeys.Clone();
          break;
        case SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig:
          SessionTicketKeysSdsSecretConfig = other.SessionTicketKeysSdsSecretConfig.Clone();
          break;
        case SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption:
          DisableStatelessSessionResumption = other.DisableStatelessSessionResumption;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownstreamTlsContext Clone() {
      return new DownstreamTlsContext(this);
    }

    /// <summary>Field number for the "common_tls_context" field.</summary>
    public const int CommonTlsContextFieldNumber = 1;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext commonTlsContext_;
    /// <summary>
    /// Common TLS context settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext CommonTlsContext {
      get { return commonTlsContext_; }
      set {
        commonTlsContext_ = value;
      }
    }

    /// <summary>Field number for the "require_client_certificate" field.</summary>
    public const int RequireClientCertificateFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_requireClientCertificate_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? requireClientCertificate_;
    /// <summary>
    /// If specified, Envoy will reject connections without a valid client
    /// certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? RequireClientCertificate {
      get { return requireClientCertificate_; }
      set {
        requireClientCertificate_ = value;
      }
    }


    /// <summary>Field number for the "require_sni" field.</summary>
    public const int RequireSniFieldNumber = 3;
    private static readonly pb::FieldCodec<bool?> _single_requireSni_codec = pb::FieldCodec.ForStructWrapper<bool>(26);
    private bool? requireSni_;
    /// <summary>
    /// If specified, Envoy will reject connections without a valid and matching SNI.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? RequireSni {
      get { return requireSni_; }
      set {
        requireSni_ = value;
      }
    }


    /// <summary>Field number for the "session_ticket_keys" field.</summary>
    public const int SessionTicketKeysFieldNumber = 4;
    /// <summary>
    /// TLS session ticket key settings.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys SessionTicketKeys {
      get { return sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys ? (global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys) sessionTicketKeysType_ : null; }
      set {
        sessionTicketKeysType_ = value;
        sessionTicketKeysTypeCase_ = value == null ? SessionTicketKeysTypeOneofCase.None : SessionTicketKeysTypeOneofCase.SessionTicketKeys;
      }
    }

    /// <summary>Field number for the "session_ticket_keys_sds_secret_config" field.</summary>
    public const int SessionTicketKeysSdsSecretConfigFieldNumber = 5;
    /// <summary>
    /// Config for fetching TLS session ticket keys via SDS API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig SessionTicketKeysSdsSecretConfig {
      get { return sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig ? (global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig) sessionTicketKeysType_ : null; }
      set {
        sessionTicketKeysType_ = value;
        sessionTicketKeysTypeCase_ = value == null ? SessionTicketKeysTypeOneofCase.None : SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig;
      }
    }

    /// <summary>Field number for the "disable_stateless_session_resumption" field.</summary>
    public const int DisableStatelessSessionResumptionFieldNumber = 7;
    /// <summary>
    /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    /// the keys specified through either :ref:`session_ticket_keys &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    /// or :ref:`session_ticket_keys_sds_secret_config &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
    /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    /// implication that sessions cannot be resumed across hot restarts or on different hosts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DisableStatelessSessionResumption {
      get { return sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption ? (bool) sessionTicketKeysType_ : false; }
      set {
        sessionTicketKeysType_ = value;
        sessionTicketKeysTypeCase_ = SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption;
      }
    }

    /// <summary>Field number for the "session_timeout" field.</summary>
    public const int SessionTimeoutFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Duration sessionTimeout_;
    /// <summary>
    /// If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
    /// Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) &lt;https://tools.ietf.org/html/rfc5077#section-5.6>`_.
    /// Only seconds can be specified (fractional seconds are ignored).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration SessionTimeout {
      get { return sessionTimeout_; }
      set {
        sessionTimeout_ = value;
      }
    }

    /// <summary>Field number for the "ocsp_staple_policy" field.</summary>
    public const int OcspStaplePolicyFieldNumber = 8;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy ocspStaplePolicy_ = global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling;
    /// <summary>
    /// Config for whether to use certificates if they do not have
    /// an accompanying OCSP response or if the response expires at runtime.
    /// Defaults to LENIENT_STAPLING
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy OcspStaplePolicy {
      get { return ocspStaplePolicy_; }
      set {
        ocspStaplePolicy_ = value;
      }
    }

    /// <summary>Field number for the "full_scan_certs_on_sni_mismatch" field.</summary>
    public const int FullScanCertsOnSniMismatchFieldNumber = 9;
    private static readonly pb::FieldCodec<bool?> _single_fullScanCertsOnSniMismatch_codec = pb::FieldCodec.ForStructWrapper<bool>(74);
    private bool? fullScanCertsOnSniMismatch_;
    /// <summary>
    /// Multiple certificates are allowed in Downstream transport socket to serve different SNI.
    /// If the client provides SNI but no such cert matched, it will decide to full scan certificates or not based on this config.
    /// Defaults to false. See more details in :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? FullScanCertsOnSniMismatch {
      get { return fullScanCertsOnSniMismatch_; }
      set {
        fullScanCertsOnSniMismatch_ = value;
      }
    }


    private object sessionTicketKeysType_;
    /// <summary>Enum of possible cases for the "session_ticket_keys_type" oneof.</summary>
    public enum SessionTicketKeysTypeOneofCase {
      None = 0,
      SessionTicketKeys = 4,
      SessionTicketKeysSdsSecretConfig = 5,
      DisableStatelessSessionResumption = 7,
    }
    private SessionTicketKeysTypeOneofCase sessionTicketKeysTypeCase_ = SessionTicketKeysTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SessionTicketKeysTypeOneofCase SessionTicketKeysTypeCase {
      get { return sessionTicketKeysTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionTicketKeysType() {
      sessionTicketKeysTypeCase_ = SessionTicketKeysTypeOneofCase.None;
      sessionTicketKeysType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DownstreamTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DownstreamTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(CommonTlsContext, other.CommonTlsContext)) return false;
      if (RequireClientCertificate != other.RequireClientCertificate) return false;
      if (RequireSni != other.RequireSni) return false;
      if (!object.Equals(SessionTicketKeys, other.SessionTicketKeys)) return false;
      if (!object.Equals(SessionTicketKeysSdsSecretConfig, other.SessionTicketKeysSdsSecretConfig)) return false;
      if (DisableStatelessSessionResumption != other.DisableStatelessSessionResumption) return false;
      if (!object.Equals(SessionTimeout, other.SessionTimeout)) return false;
      if (OcspStaplePolicy != other.OcspStaplePolicy) return false;
      if (FullScanCertsOnSniMismatch != other.FullScanCertsOnSniMismatch) return false;
      if (SessionTicketKeysTypeCase != other.SessionTicketKeysTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (commonTlsContext_ != null) hash ^= CommonTlsContext.GetHashCode();
      if (requireClientCertificate_ != null) hash ^= RequireClientCertificate.GetHashCode();
      if (requireSni_ != null) hash ^= RequireSni.GetHashCode();
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) hash ^= SessionTicketKeys.GetHashCode();
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) hash ^= SessionTicketKeysSdsSecretConfig.GetHashCode();
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption) hash ^= DisableStatelessSessionResumption.GetHashCode();
      if (sessionTimeout_ != null) hash ^= SessionTimeout.GetHashCode();
      if (OcspStaplePolicy != global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling) hash ^= OcspStaplePolicy.GetHashCode();
      if (fullScanCertsOnSniMismatch_ != null) hash ^= FullScanCertsOnSniMismatch.GetHashCode();
      hash ^= (int) sessionTicketKeysTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (requireClientCertificate_ != null) {
        _single_requireClientCertificate_codec.WriteTagAndValue(output, RequireClientCertificate);
      }
      if (requireSni_ != null) {
        _single_requireSni_codec.WriteTagAndValue(output, RequireSni);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
        output.WriteRawTag(34);
        output.WriteMessage(SessionTicketKeys);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
        output.WriteRawTag(42);
        output.WriteMessage(SessionTicketKeysSdsSecretConfig);
      }
      if (sessionTimeout_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SessionTimeout);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption) {
        output.WriteRawTag(56);
        output.WriteBool(DisableStatelessSessionResumption);
      }
      if (OcspStaplePolicy != global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling) {
        output.WriteRawTag(64);
        output.WriteEnum((int) OcspStaplePolicy);
      }
      if (fullScanCertsOnSniMismatch_ != null) {
        _single_fullScanCertsOnSniMismatch_codec.WriteTagAndValue(output, FullScanCertsOnSniMismatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (commonTlsContext_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(CommonTlsContext);
      }
      if (requireClientCertificate_ != null) {
        _single_requireClientCertificate_codec.WriteTagAndValue(ref output, RequireClientCertificate);
      }
      if (requireSni_ != null) {
        _single_requireSni_codec.WriteTagAndValue(ref output, RequireSni);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
        output.WriteRawTag(34);
        output.WriteMessage(SessionTicketKeys);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
        output.WriteRawTag(42);
        output.WriteMessage(SessionTicketKeysSdsSecretConfig);
      }
      if (sessionTimeout_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SessionTimeout);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption) {
        output.WriteRawTag(56);
        output.WriteBool(DisableStatelessSessionResumption);
      }
      if (OcspStaplePolicy != global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling) {
        output.WriteRawTag(64);
        output.WriteEnum((int) OcspStaplePolicy);
      }
      if (fullScanCertsOnSniMismatch_ != null) {
        _single_fullScanCertsOnSniMismatch_codec.WriteTagAndValue(ref output, FullScanCertsOnSniMismatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (commonTlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CommonTlsContext);
      }
      if (requireClientCertificate_ != null) {
        size += _single_requireClientCertificate_codec.CalculateSizeWithTag(RequireClientCertificate);
      }
      if (requireSni_ != null) {
        size += _single_requireSni_codec.CalculateSizeWithTag(RequireSni);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTicketKeys);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTicketKeysSdsSecretConfig);
      }
      if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption) {
        size += 1 + 1;
      }
      if (sessionTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionTimeout);
      }
      if (OcspStaplePolicy != global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OcspStaplePolicy);
      }
      if (fullScanCertsOnSniMismatch_ != null) {
        size += _single_fullScanCertsOnSniMismatch_codec.CalculateSizeWithTag(FullScanCertsOnSniMismatch);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DownstreamTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.commonTlsContext_ != null) {
        if (commonTlsContext_ == null) {
          CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
        }
        CommonTlsContext.MergeFrom(other.CommonTlsContext);
      }
      if (other.requireClientCertificate_ != null) {
        if (requireClientCertificate_ == null || other.RequireClientCertificate != false) {
          RequireClientCertificate = other.RequireClientCertificate;
        }
      }
      if (other.requireSni_ != null) {
        if (requireSni_ == null || other.RequireSni != false) {
          RequireSni = other.RequireSni;
        }
      }
      if (other.sessionTimeout_ != null) {
        if (sessionTimeout_ == null) {
          SessionTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        SessionTimeout.MergeFrom(other.SessionTimeout);
      }
      if (other.OcspStaplePolicy != global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy.LenientStapling) {
        OcspStaplePolicy = other.OcspStaplePolicy;
      }
      if (other.fullScanCertsOnSniMismatch_ != null) {
        if (fullScanCertsOnSniMismatch_ == null || other.FullScanCertsOnSniMismatch != false) {
          FullScanCertsOnSniMismatch = other.FullScanCertsOnSniMismatch;
        }
      }
      switch (other.SessionTicketKeysTypeCase) {
        case SessionTicketKeysTypeOneofCase.SessionTicketKeys:
          if (SessionTicketKeys == null) {
            SessionTicketKeys = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys();
          }
          SessionTicketKeys.MergeFrom(other.SessionTicketKeys);
          break;
        case SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig:
          if (SessionTicketKeysSdsSecretConfig == null) {
            SessionTicketKeysSdsSecretConfig = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
          }
          SessionTicketKeysSdsSecretConfig.MergeFrom(other.SessionTicketKeysSdsSecretConfig);
          break;
        case SessionTicketKeysTypeOneofCase.DisableStatelessSessionResumption:
          DisableStatelessSessionResumption = other.DisableStatelessSessionResumption;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
            }
            input.ReadMessage(CommonTlsContext);
            break;
          }
          case 18: {
            bool? value = _single_requireClientCertificate_codec.Read(input);
            if (requireClientCertificate_ == null || value != false) {
              RequireClientCertificate = value;
            }
            break;
          }
          case 26: {
            bool? value = _single_requireSni_codec.Read(input);
            if (requireSni_ == null || value != false) {
              RequireSni = value;
            }
            break;
          }
          case 34: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
              subBuilder.MergeFrom(SessionTicketKeys);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeys = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
              subBuilder.MergeFrom(SessionTicketKeysSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeysSdsSecretConfig = subBuilder;
            break;
          }
          case 50: {
            if (sessionTimeout_ == null) {
              SessionTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(SessionTimeout);
            break;
          }
          case 56: {
            DisableStatelessSessionResumption = input.ReadBool();
            break;
          }
          case 64: {
            OcspStaplePolicy = (global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy) input.ReadEnum();
            break;
          }
          case 74: {
            bool? value = _single_fullScanCertsOnSniMismatch_codec.Read(input);
            if (fullScanCertsOnSniMismatch_ == null || value != false) {
              FullScanCertsOnSniMismatch = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (commonTlsContext_ == null) {
              CommonTlsContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext();
            }
            input.ReadMessage(CommonTlsContext);
            break;
          }
          case 18: {
            bool? value = _single_requireClientCertificate_codec.Read(ref input);
            if (requireClientCertificate_ == null || value != false) {
              RequireClientCertificate = value;
            }
            break;
          }
          case 26: {
            bool? value = _single_requireSni_codec.Read(ref input);
            if (requireSni_ == null || value != false) {
              RequireSni = value;
            }
            break;
          }
          case 34: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsSessionTicketKeys();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeys) {
              subBuilder.MergeFrom(SessionTicketKeys);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeys = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
            if (sessionTicketKeysTypeCase_ == SessionTicketKeysTypeOneofCase.SessionTicketKeysSdsSecretConfig) {
              subBuilder.MergeFrom(SessionTicketKeysSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            SessionTicketKeysSdsSecretConfig = subBuilder;
            break;
          }
          case 50: {
            if (sessionTimeout_ == null) {
              SessionTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(SessionTimeout);
            break;
          }
          case 56: {
            DisableStatelessSessionResumption = input.ReadBool();
            break;
          }
          case 64: {
            OcspStaplePolicy = (global::Envoy.Extensions.TransportSockets.Tls.V3.DownstreamTlsContext.Types.OcspStaplePolicy) input.ReadEnum();
            break;
          }
          case 74: {
            bool? value = _single_fullScanCertsOnSniMismatch_codec.Read(ref input);
            if (fullScanCertsOnSniMismatch_ == null || value != false) {
              FullScanCertsOnSniMismatch = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the DownstreamTlsContext message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum OcspStaplePolicy {
        /// <summary>
        /// OCSP responses are optional. If an OCSP response is absent
        /// or expired, the associated certificate will be used for
        /// connections without an OCSP staple.
        /// </summary>
        [pbr::OriginalName("LENIENT_STAPLING")] LenientStapling = 0,
        /// <summary>
        /// OCSP responses are optional. If an OCSP response is absent,
        /// the associated certificate will be used without an
        /// OCSP staple. If a response is provided but is expired,
        /// the associated certificate will not be used for
        /// subsequent connections. If no suitable certificate is found,
        /// the connection is rejected.
        /// </summary>
        [pbr::OriginalName("STRICT_STAPLING")] StrictStapling = 1,
        /// <summary>
        /// OCSP responses are required. Configuration will fail if
        /// a certificate is provided without an OCSP response. If a
        /// response expires, the associated certificate will not be
        /// used connections. If no suitable certificate is found, the
        /// connection is rejected.
        /// </summary>
        [pbr::OriginalName("MUST_STAPLE")] MustStaple = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// TLS key log configuration.
  /// The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
  /// </summary>
  public sealed partial class TlsKeyLog : pb::IMessage<TlsKeyLog>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TlsKeyLog> _parser = new pb::MessageParser<TlsKeyLog>(() => new TlsKeyLog());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TlsKeyLog> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.TlsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsKeyLog() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsKeyLog(TlsKeyLog other) : this() {
      path_ = other.path_;
      localAddressRange_ = other.localAddressRange_.Clone();
      remoteAddressRange_ = other.remoteAddressRange_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TlsKeyLog Clone() {
      return new TlsKeyLog(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private string path_ = "";
    /// <summary>
    /// The path to save the TLS key log.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "local_address_range" field.</summary>
    public const int LocalAddressRangeFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.CidrRange> _repeated_localAddressRange_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Core.V3.CidrRange.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> localAddressRange_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange>();
    /// <summary>
    /// The local IP address that will be used to filter the connection which should save the TLS key log
    /// If it is not set, any local IP address  will be matched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> LocalAddressRange {
      get { return localAddressRange_; }
    }

    /// <summary>Field number for the "remote_address_range" field.</summary>
    public const int RemoteAddressRangeFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.CidrRange> _repeated_remoteAddressRange_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Core.V3.CidrRange.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> remoteAddressRange_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange>();
    /// <summary>
    /// The remote IP address that will be used to filter the connection which should save the TLS key log
    /// If it is not set, any remote IP address will be matched.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.CidrRange> RemoteAddressRange {
      get { return remoteAddressRange_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TlsKeyLog);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TlsKeyLog other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if(!localAddressRange_.Equals(other.localAddressRange_)) return false;
      if(!remoteAddressRange_.Equals(other.remoteAddressRange_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Path.Length != 0) hash ^= Path.GetHashCode();
      hash ^= localAddressRange_.GetHashCode();
      hash ^= remoteAddressRange_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      localAddressRange_.WriteTo(output, _repeated_localAddressRange_codec);
      remoteAddressRange_.WriteTo(output, _repeated_remoteAddressRange_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      localAddressRange_.WriteTo(ref output, _repeated_localAddressRange_codec);
      remoteAddressRange_.WriteTo(ref output, _repeated_remoteAddressRange_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Path.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      size += localAddressRange_.CalculateSize(_repeated_localAddressRange_codec);
      size += remoteAddressRange_.CalculateSize(_repeated_remoteAddressRange_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TlsKeyLog other) {
      if (other == null) {
        return;
      }
      if (other.Path.Length != 0) {
        Path = other.Path;
      }
      localAddressRange_.Add(other.localAddressRange_);
      remoteAddressRange_.Add(other.remoteAddressRange_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            localAddressRange_.AddEntriesFrom(input, _repeated_localAddressRange_codec);
            break;
          }
          case 26: {
            remoteAddressRange_.AddEntriesFrom(input, _repeated_remoteAddressRange_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            localAddressRange_.AddEntriesFrom(ref input, _repeated_localAddressRange_codec);
            break;
          }
          case 26: {
            remoteAddressRange_.AddEntriesFrom(ref input, _repeated_remoteAddressRange_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// TLS context shared by both client and server TLS contexts.
  /// [#next-free-field: 16]
  /// </summary>
  public sealed partial class CommonTlsContext : pb::IMessage<CommonTlsContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CommonTlsContext> _parser = new pb::MessageParser<CommonTlsContext>(() => new CommonTlsContext());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CommonTlsContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Extensions.TransportSockets.Tls.V3.TlsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CommonTlsContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CommonTlsContext(CommonTlsContext other) : this() {
      tlsParams_ = other.tlsParams_ != null ? other.tlsParams_.Clone() : null;
      tlsCertificates_ = other.tlsCertificates_.Clone();
      tlsCertificateSdsSecretConfigs_ = other.tlsCertificateSdsSecretConfigs_.Clone();
      tlsCertificateProviderInstance_ = other.tlsCertificateProviderInstance_ != null ? other.tlsCertificateProviderInstance_.Clone() : null;
      tlsCertificateCertificateProvider_ = other.tlsCertificateCertificateProvider_ != null ? other.tlsCertificateCertificateProvider_.Clone() : null;
      tlsCertificateCertificateProviderInstance_ = other.tlsCertificateCertificateProviderInstance_ != null ? other.tlsCertificateCertificateProviderInstance_.Clone() : null;
      alpnProtocols_ = other.alpnProtocols_.Clone();
      customHandshaker_ = other.customHandshaker_ != null ? other.customHandshaker_.Clone() : null;
      keyLog_ = other.keyLog_ != null ? other.keyLog_.Clone() : null;
      switch (other.ValidationContextTypeCase) {
        case ValidationContextTypeOneofCase.ValidationContext:
          ValidationContext = other.ValidationContext.Clone();
          break;
        case ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig:
          ValidationContextSdsSecretConfig = other.ValidationContextSdsSecretConfig.Clone();
          break;
        case ValidationContextTypeOneofCase.CombinedValidationContext:
          CombinedValidationContext = other.CombinedValidationContext.Clone();
          break;
        case ValidationContextTypeOneofCase.ValidationContextCertificateProvider:
          ValidationContextCertificateProvider = other.ValidationContextCertificateProvider.Clone();
          break;
        case ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance:
          ValidationContextCertificateProviderInstance = other.ValidationContextCertificateProviderInstance.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CommonTlsContext Clone() {
      return new CommonTlsContext(this);
    }

    /// <summary>Field number for the "tls_params" field.</summary>
    public const int TlsParamsFieldNumber = 1;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters tlsParams_;
    /// <summary>
    /// TLS protocol versions, cipher suites etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters TlsParams {
      get { return tlsParams_; }
      set {
        tlsParams_ = value;
      }
    }

    /// <summary>Field number for the "tls_certificates" field.</summary>
    public const int TlsCertificatesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate> _repeated_tlsCertificates_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate> tlsCertificates_ = new pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate>();
    /// <summary>
    /// Only a single TLS certificate is supported in client contexts. In server contexts,
    /// :ref:`Multiple TLS certificates &lt;arch_overview_ssl_cert_select>` can be associated with the
    /// same context to allow both RSA and ECDSA certificates and support SNI-based selection.
    ///
    /// Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
    /// and ``tls_certificate_provider_instance`` may be used.
    /// [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
    /// not legal to put a repeated field in a oneof. In the next major version, we should rework
    /// this to avoid this problem.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.TlsCertificate> TlsCertificates {
      get { return tlsCertificates_; }
    }

    /// <summary>Field number for the "tls_certificate_sds_secret_configs" field.</summary>
    public const int TlsCertificateSdsSecretConfigsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig> _repeated_tlsCertificateSdsSecretConfigs_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig> tlsCertificateSdsSecretConfigs_ = new pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig>();
    /// <summary>
    /// Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    ///
    /// The same number and types of certificates as :ref:`tls_certificates &lt;envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
    /// are valid in the the certificates fetched through this setting.
    ///
    /// Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
    /// and ``tls_certificate_provider_instance`` may be used.
    /// [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
    /// not legal to put a repeated field in a oneof. In the next major version, we should rework
    /// this to avoid this problem.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig> TlsCertificateSdsSecretConfigs {
      get { return tlsCertificateSdsSecretConfigs_; }
    }

    /// <summary>Field number for the "tls_certificate_provider_instance" field.</summary>
    public const int TlsCertificateProviderInstanceFieldNumber = 14;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance tlsCertificateProviderInstance_;
    /// <summary>
    /// Certificate provider instance for fetching TLS certs.
    ///
    /// Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
    /// and ``tls_certificate_provider_instance`` may be used.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance TlsCertificateProviderInstance {
      get { return tlsCertificateProviderInstance_; }
      set {
        tlsCertificateProviderInstance_ = value;
      }
    }

    /// <summary>Field number for the "tls_certificate_certificate_provider" field.</summary>
    public const int TlsCertificateCertificateProviderFieldNumber = 9;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider tlsCertificateCertificateProvider_;
    /// <summary>
    /// Certificate provider for fetching TLS certificates.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider TlsCertificateCertificateProvider {
      get { return tlsCertificateCertificateProvider_; }
      set {
        tlsCertificateCertificateProvider_ = value;
      }
    }

    /// <summary>Field number for the "tls_certificate_certificate_provider_instance" field.</summary>
    public const int TlsCertificateCertificateProviderInstanceFieldNumber = 11;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance tlsCertificateCertificateProviderInstance_;
    /// <summary>
    /// Certificate provider instance for fetching TLS certificates.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance TlsCertificateCertificateProviderInstance {
      get { return tlsCertificateCertificateProviderInstance_; }
      set {
        tlsCertificateCertificateProviderInstance_ = value;
      }
    }

    /// <summary>Field number for the "validation_context" field.</summary>
    public const int ValidationContextFieldNumber = 3;
    /// <summary>
    /// How to validate peer certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext ValidationContext {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext ? (global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContext;
      }
    }

    /// <summary>Field number for the "validation_context_sds_secret_config" field.</summary>
    public const int ValidationContextSdsSecretConfigFieldNumber = 7;
    /// <summary>
    /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig ValidationContextSdsSecretConfig {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig ? (global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig;
      }
    }

    /// <summary>Field number for the "combined_validation_context" field.</summary>
    public const int CombinedValidationContextFieldNumber = 8;
    /// <summary>
    /// Combined certificate validation context holds a default CertificateValidationContext
    /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    /// and default CertificateValidationContext are merged into a new CertificateValidationContext
    /// for validation. This merge is done by Message::MergeFrom(), so dynamic
    /// CertificateValidationContext overwrites singular fields in default
    /// CertificateValidationContext, and concatenates repeated fields to default
    /// CertificateValidationContext, and logical OR is applied to boolean fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext CombinedValidationContext {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext ? (global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.CombinedValidationContext;
      }
    }

    /// <summary>Field number for the "validation_context_certificate_provider" field.</summary>
    public const int ValidationContextCertificateProviderFieldNumber = 10;
    /// <summary>
    /// Certificate provider for fetching validation context.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider ValidationContextCertificateProvider {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider ? (global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContextCertificateProvider;
      }
    }

    /// <summary>Field number for the "validation_context_certificate_provider_instance" field.</summary>
    public const int ValidationContextCertificateProviderInstanceFieldNumber = 12;
    /// <summary>
    /// Certificate provider instance for fetching validation context.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance ValidationContextCertificateProviderInstance {
      get { return validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance ? (global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance) validationContextType_ : null; }
      set {
        validationContextType_ = value;
        validationContextTypeCase_ = value == null ? ValidationContextTypeOneofCase.None : ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance;
      }
    }

    /// <summary>Field number for the "alpn_protocols" field.</summary>
    public const int AlpnProtocolsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_alpnProtocols_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> alpnProtocols_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Supplies the list of ALPN protocols that the listener should expose. In
    /// practice this is likely to be set to one of two values (see the
    /// :ref:`codec_type
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
    /// parameter in the HTTP connection manager for more information):
    ///
    /// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
    /// * "http/1.1" If the listener is only going to support HTTP/1.1.
    ///
    /// There is no default for this parameter. If empty, Envoy will not expose ALPN.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> AlpnProtocols {
      get { return alpnProtocols_; }
    }

    /// <summary>Field number for the "custom_handshaker" field.</summary>
    public const int CustomHandshakerFieldNumber = 13;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig customHandshaker_;
    /// <summary>
    /// Custom TLS handshaker. If empty, defaults to native TLS handshaking
    /// behavior.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig CustomHandshaker {
      get { return customHandshaker_; }
      set {
        customHandshaker_ = value;
      }
    }

    /// <summary>Field number for the "key_log" field.</summary>
    public const int KeyLogFieldNumber = 15;
    private global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog keyLog_;
    /// <summary>
    /// TLS key log configuration
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog KeyLog {
      get { return keyLog_; }
      set {
        keyLog_ = value;
      }
    }

    private object validationContextType_;
    /// <summary>Enum of possible cases for the "validation_context_type" oneof.</summary>
    public enum ValidationContextTypeOneofCase {
      None = 0,
      ValidationContext = 3,
      ValidationContextSdsSecretConfig = 7,
      CombinedValidationContext = 8,
      ValidationContextCertificateProvider = 10,
      ValidationContextCertificateProviderInstance = 12,
    }
    private ValidationContextTypeOneofCase validationContextTypeCase_ = ValidationContextTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ValidationContextTypeOneofCase ValidationContextTypeCase {
      get { return validationContextTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValidationContextType() {
      validationContextTypeCase_ = ValidationContextTypeOneofCase.None;
      validationContextType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CommonTlsContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CommonTlsContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TlsParams, other.TlsParams)) return false;
      if(!tlsCertificates_.Equals(other.tlsCertificates_)) return false;
      if(!tlsCertificateSdsSecretConfigs_.Equals(other.tlsCertificateSdsSecretConfigs_)) return false;
      if (!object.Equals(TlsCertificateProviderInstance, other.TlsCertificateProviderInstance)) return false;
      if (!object.Equals(TlsCertificateCertificateProvider, other.TlsCertificateCertificateProvider)) return false;
      if (!object.Equals(TlsCertificateCertificateProviderInstance, other.TlsCertificateCertificateProviderInstance)) return false;
      if (!object.Equals(ValidationContext, other.ValidationContext)) return false;
      if (!object.Equals(ValidationContextSdsSecretConfig, other.ValidationContextSdsSecretConfig)) return false;
      if (!object.Equals(CombinedValidationContext, other.CombinedValidationContext)) return false;
      if (!object.Equals(ValidationContextCertificateProvider, other.ValidationContextCertificateProvider)) return false;
      if (!object.Equals(ValidationContextCertificateProviderInstance, other.ValidationContextCertificateProviderInstance)) return false;
      if(!alpnProtocols_.Equals(other.alpnProtocols_)) return false;
      if (!object.Equals(CustomHandshaker, other.CustomHandshaker)) return false;
      if (!object.Equals(KeyLog, other.KeyLog)) return false;
      if (ValidationContextTypeCase != other.ValidationContextTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tlsParams_ != null) hash ^= TlsParams.GetHashCode();
      hash ^= tlsCertificates_.GetHashCode();
      hash ^= tlsCertificateSdsSecretConfigs_.GetHashCode();
      if (tlsCertificateProviderInstance_ != null) hash ^= TlsCertificateProviderInstance.GetHashCode();
      if (tlsCertificateCertificateProvider_ != null) hash ^= TlsCertificateCertificateProvider.GetHashCode();
      if (tlsCertificateCertificateProviderInstance_ != null) hash ^= TlsCertificateCertificateProviderInstance.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) hash ^= ValidationContext.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) hash ^= ValidationContextSdsSecretConfig.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) hash ^= CombinedValidationContext.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) hash ^= ValidationContextCertificateProvider.GetHashCode();
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) hash ^= ValidationContextCertificateProviderInstance.GetHashCode();
      hash ^= alpnProtocols_.GetHashCode();
      if (customHandshaker_ != null) hash ^= CustomHandshaker.GetHashCode();
      if (keyLog_ != null) hash ^= KeyLog.GetHashCode();
      hash ^= (int) validationContextTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tlsParams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TlsParams);
      }
      tlsCertificates_.WriteTo(output, _repeated_tlsCertificates_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
        output.WriteRawTag(26);
        output.WriteMessage(ValidationContext);
      }
      alpnProtocols_.WriteTo(output, _repeated_alpnProtocols_codec);
      tlsCertificateSdsSecretConfigs_.WriteTo(output, _repeated_tlsCertificateSdsSecretConfigs_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
        output.WriteRawTag(58);
        output.WriteMessage(ValidationContextSdsSecretConfig);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) {
        output.WriteRawTag(66);
        output.WriteMessage(CombinedValidationContext);
      }
      if (tlsCertificateCertificateProvider_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(TlsCertificateCertificateProvider);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) {
        output.WriteRawTag(82);
        output.WriteMessage(ValidationContextCertificateProvider);
      }
      if (tlsCertificateCertificateProviderInstance_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsCertificateCertificateProviderInstance);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) {
        output.WriteRawTag(98);
        output.WriteMessage(ValidationContextCertificateProviderInstance);
      }
      if (customHandshaker_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CustomHandshaker);
      }
      if (tlsCertificateProviderInstance_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(TlsCertificateProviderInstance);
      }
      if (keyLog_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(KeyLog);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tlsParams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TlsParams);
      }
      tlsCertificates_.WriteTo(ref output, _repeated_tlsCertificates_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
        output.WriteRawTag(26);
        output.WriteMessage(ValidationContext);
      }
      alpnProtocols_.WriteTo(ref output, _repeated_alpnProtocols_codec);
      tlsCertificateSdsSecretConfigs_.WriteTo(ref output, _repeated_tlsCertificateSdsSecretConfigs_codec);
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
        output.WriteRawTag(58);
        output.WriteMessage(ValidationContextSdsSecretConfig);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) {
        output.WriteRawTag(66);
        output.WriteMessage(CombinedValidationContext);
      }
      if (tlsCertificateCertificateProvider_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(TlsCertificateCertificateProvider);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) {
        output.WriteRawTag(82);
        output.WriteMessage(ValidationContextCertificateProvider);
      }
      if (tlsCertificateCertificateProviderInstance_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsCertificateCertificateProviderInstance);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) {
        output.WriteRawTag(98);
        output.WriteMessage(ValidationContextCertificateProviderInstance);
      }
      if (customHandshaker_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(CustomHandshaker);
      }
      if (tlsCertificateProviderInstance_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(TlsCertificateProviderInstance);
      }
      if (keyLog_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(KeyLog);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tlsParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsParams);
      }
      size += tlsCertificates_.CalculateSize(_repeated_tlsCertificates_codec);
      size += tlsCertificateSdsSecretConfigs_.CalculateSize(_repeated_tlsCertificateSdsSecretConfigs_codec);
      if (tlsCertificateProviderInstance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsCertificateProviderInstance);
      }
      if (tlsCertificateCertificateProvider_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsCertificateCertificateProvider);
      }
      if (tlsCertificateCertificateProviderInstance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsCertificateCertificateProviderInstance);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContext);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextSdsSecretConfig);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CombinedValidationContext);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextCertificateProvider);
      }
      if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextCertificateProviderInstance);
      }
      size += alpnProtocols_.CalculateSize(_repeated_alpnProtocols_codec);
      if (customHandshaker_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CustomHandshaker);
      }
      if (keyLog_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyLog);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CommonTlsContext other) {
      if (other == null) {
        return;
      }
      if (other.tlsParams_ != null) {
        if (tlsParams_ == null) {
          TlsParams = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters();
        }
        TlsParams.MergeFrom(other.TlsParams);
      }
      tlsCertificates_.Add(other.tlsCertificates_);
      tlsCertificateSdsSecretConfigs_.Add(other.tlsCertificateSdsSecretConfigs_);
      if (other.tlsCertificateProviderInstance_ != null) {
        if (tlsCertificateProviderInstance_ == null) {
          TlsCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
        }
        TlsCertificateProviderInstance.MergeFrom(other.TlsCertificateProviderInstance);
      }
      if (other.tlsCertificateCertificateProvider_ != null) {
        if (tlsCertificateCertificateProvider_ == null) {
          TlsCertificateCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
        }
        TlsCertificateCertificateProvider.MergeFrom(other.TlsCertificateCertificateProvider);
      }
      if (other.tlsCertificateCertificateProviderInstance_ != null) {
        if (tlsCertificateCertificateProviderInstance_ == null) {
          TlsCertificateCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
        }
        TlsCertificateCertificateProviderInstance.MergeFrom(other.TlsCertificateCertificateProviderInstance);
      }
      alpnProtocols_.Add(other.alpnProtocols_);
      if (other.customHandshaker_ != null) {
        if (customHandshaker_ == null) {
          CustomHandshaker = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        CustomHandshaker.MergeFrom(other.CustomHandshaker);
      }
      if (other.keyLog_ != null) {
        if (keyLog_ == null) {
          KeyLog = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog();
        }
        KeyLog.MergeFrom(other.KeyLog);
      }
      switch (other.ValidationContextTypeCase) {
        case ValidationContextTypeOneofCase.ValidationContext:
          if (ValidationContext == null) {
            ValidationContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
          }
          ValidationContext.MergeFrom(other.ValidationContext);
          break;
        case ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig:
          if (ValidationContextSdsSecretConfig == null) {
            ValidationContextSdsSecretConfig = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
          }
          ValidationContextSdsSecretConfig.MergeFrom(other.ValidationContextSdsSecretConfig);
          break;
        case ValidationContextTypeOneofCase.CombinedValidationContext:
          if (CombinedValidationContext == null) {
            CombinedValidationContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext();
          }
          CombinedValidationContext.MergeFrom(other.CombinedValidationContext);
          break;
        case ValidationContextTypeOneofCase.ValidationContextCertificateProvider:
          if (ValidationContextCertificateProvider == null) {
            ValidationContextCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
          }
          ValidationContextCertificateProvider.MergeFrom(other.ValidationContextCertificateProvider);
          break;
        case ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance:
          if (ValidationContextCertificateProviderInstance == null) {
            ValidationContextCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
          }
          ValidationContextCertificateProviderInstance.MergeFrom(other.ValidationContextCertificateProviderInstance);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tlsParams_ == null) {
              TlsParams = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters();
            }
            input.ReadMessage(TlsParams);
            break;
          }
          case 18: {
            tlsCertificates_.AddEntriesFrom(input, _repeated_tlsCertificates_codec);
            break;
          }
          case 26: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
              subBuilder.MergeFrom(ValidationContext);
            }
            input.ReadMessage(subBuilder);
            ValidationContext = subBuilder;
            break;
          }
          case 34: {
            alpnProtocols_.AddEntriesFrom(input, _repeated_alpnProtocols_codec);
            break;
          }
          case 50: {
            tlsCertificateSdsSecretConfigs_.AddEntriesFrom(input, _repeated_tlsCertificateSdsSecretConfigs_codec);
            break;
          }
          case 58: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
              subBuilder.MergeFrom(ValidationContextSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            ValidationContextSdsSecretConfig = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) {
              subBuilder.MergeFrom(CombinedValidationContext);
            }
            input.ReadMessage(subBuilder);
            CombinedValidationContext = subBuilder;
            break;
          }
          case 74: {
            if (tlsCertificateCertificateProvider_ == null) {
              TlsCertificateCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
            }
            input.ReadMessage(TlsCertificateCertificateProvider);
            break;
          }
          case 82: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) {
              subBuilder.MergeFrom(ValidationContextCertificateProvider);
            }
            input.ReadMessage(subBuilder);
            ValidationContextCertificateProvider = subBuilder;
            break;
          }
          case 90: {
            if (tlsCertificateCertificateProviderInstance_ == null) {
              TlsCertificateCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
            }
            input.ReadMessage(TlsCertificateCertificateProviderInstance);
            break;
          }
          case 98: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) {
              subBuilder.MergeFrom(ValidationContextCertificateProviderInstance);
            }
            input.ReadMessage(subBuilder);
            ValidationContextCertificateProviderInstance = subBuilder;
            break;
          }
          case 106: {
            if (customHandshaker_ == null) {
              CustomHandshaker = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(CustomHandshaker);
            break;
          }
          case 114: {
            if (tlsCertificateProviderInstance_ == null) {
              TlsCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
            }
            input.ReadMessage(TlsCertificateProviderInstance);
            break;
          }
          case 122: {
            if (keyLog_ == null) {
              KeyLog = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog();
            }
            input.ReadMessage(KeyLog);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tlsParams_ == null) {
              TlsParams = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsParameters();
            }
            input.ReadMessage(TlsParams);
            break;
          }
          case 18: {
            tlsCertificates_.AddEntriesFrom(ref input, _repeated_tlsCertificates_codec);
            break;
          }
          case 26: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContext) {
              subBuilder.MergeFrom(ValidationContext);
            }
            input.ReadMessage(subBuilder);
            ValidationContext = subBuilder;
            break;
          }
          case 34: {
            alpnProtocols_.AddEntriesFrom(ref input, _repeated_alpnProtocols_codec);
            break;
          }
          case 50: {
            tlsCertificateSdsSecretConfigs_.AddEntriesFrom(ref input, _repeated_tlsCertificateSdsSecretConfigs_codec);
            break;
          }
          case 58: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextSdsSecretConfig) {
              subBuilder.MergeFrom(ValidationContextSdsSecretConfig);
            }
            input.ReadMessage(subBuilder);
            ValidationContextSdsSecretConfig = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CombinedCertificateValidationContext();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.CombinedValidationContext) {
              subBuilder.MergeFrom(CombinedValidationContext);
            }
            input.ReadMessage(subBuilder);
            CombinedValidationContext = subBuilder;
            break;
          }
          case 74: {
            if (tlsCertificateCertificateProvider_ == null) {
              TlsCertificateCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
            }
            input.ReadMessage(TlsCertificateCertificateProvider);
            break;
          }
          case 82: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProvider) {
              subBuilder.MergeFrom(ValidationContextCertificateProvider);
            }
            input.ReadMessage(subBuilder);
            ValidationContextCertificateProvider = subBuilder;
            break;
          }
          case 90: {
            if (tlsCertificateCertificateProviderInstance_ == null) {
              TlsCertificateCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
            }
            input.ReadMessage(TlsCertificateCertificateProviderInstance);
            break;
          }
          case 98: {
            global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance subBuilder = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
            if (validationContextTypeCase_ == ValidationContextTypeOneofCase.ValidationContextCertificateProviderInstance) {
              subBuilder.MergeFrom(ValidationContextCertificateProviderInstance);
            }
            input.ReadMessage(subBuilder);
            ValidationContextCertificateProviderInstance = subBuilder;
            break;
          }
          case 106: {
            if (customHandshaker_ == null) {
              CustomHandshaker = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(CustomHandshaker);
            break;
          }
          case 114: {
            if (tlsCertificateProviderInstance_ == null) {
              TlsCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateProviderPluginInstance();
            }
            input.ReadMessage(TlsCertificateProviderInstance);
            break;
          }
          case 122: {
            if (keyLog_ == null) {
              KeyLog = new global::Envoy.Extensions.TransportSockets.Tls.V3.TlsKeyLog();
            }
            input.ReadMessage(KeyLog);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the CommonTlsContext message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Config for Certificate provider to get certificates. This provider should allow certificates to be
      /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
      ///
      /// DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
      /// move it out of CommonTlsContext and into common.proto, similar to the existing
      /// CertificateProviderPluginInstance message.
      ///
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class CertificateProvider : pb::IMessage<CertificateProvider>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CertificateProvider> _parser = new pb::MessageParser<CertificateProvider>(() => new CertificateProvider());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CertificateProvider> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProvider() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProvider(CertificateProvider other) : this() {
          name_ = other.name_;
          switch (other.ConfigCase) {
            case ConfigOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProvider Clone() {
          return new CertificateProvider(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
        /// a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.TypedExtensionConfig TypedConfig {
          get { return configCase_ == ConfigOneofCase.TypedConfig ? (global::Envoy.Config.Core.V3.TypedExtensionConfig) config_ : null; }
          set {
            config_ = value;
            configCase_ = value == null ? ConfigOneofCase.None : ConfigOneofCase.TypedConfig;
          }
        }

        private object config_;
        /// <summary>Enum of possible cases for the "config" oneof.</summary>
        public enum ConfigOneofCase {
          None = 0,
          TypedConfig = 2,
        }
        private ConfigOneofCase configCase_ = ConfigOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConfigOneofCase ConfigCase {
          get { return configCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearConfig() {
          configCase_ = ConfigOneofCase.None;
          config_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CertificateProvider);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CertificateProvider other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigCase != other.ConfigCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configCase_ == ConfigOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configCase_ == ConfigOneofCase.TypedConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configCase_ == ConfigOneofCase.TypedConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configCase_ == ConfigOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CertificateProvider other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigCase) {
            case ConfigOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (configCase_ == ConfigOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (configCase_ == ConfigOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Similar to CertificateProvider above, but allows the provider instances to be configured on
      /// the client side instead of being sent from the control plane.
      ///
      /// DEPRECATED: This message was moved outside of CommonTlsContext
      /// and now lives in common.proto.
      ///
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class CertificateProviderInstance : pb::IMessage<CertificateProviderInstance>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CertificateProviderInstance> _parser = new pb::MessageParser<CertificateProviderInstance>(() => new CertificateProviderInstance());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CertificateProviderInstance> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProviderInstance() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProviderInstance(CertificateProviderInstance other) : this() {
          instanceName_ = other.instanceName_;
          certificateName_ = other.certificateName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CertificateProviderInstance Clone() {
          return new CertificateProviderInstance(this);
        }

        /// <summary>Field number for the "instance_name" field.</summary>
        public const int InstanceNameFieldNumber = 1;
        private string instanceName_ = "";
        /// <summary>
        /// Provider instance name. This name must be defined in the client's configuration (e.g., a
        /// bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
        /// field that would be sent in the CertificateProvider message if the config was sent by the
        /// control plane). If not present, defaults to "default".
        ///
        /// Instance names should generally be defined not in terms of the underlying provider
        /// implementation (e.g., "file_watcher") but rather in terms of the function of the
        /// certificates (e.g., "foo_deployment_identity").
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string InstanceName {
          get { return instanceName_; }
          set {
            instanceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "certificate_name" field.</summary>
        public const int CertificateNameFieldNumber = 2;
        private string certificateName_ = "";
        /// <summary>
        /// Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
        /// a root-certificate (validation context) or "example.com" to specify a certificate for a
        /// particular domain. Not all provider instances will actually use this field, so the value
        /// defaults to the empty string.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string CertificateName {
          get { return certificateName_; }
          set {
            certificateName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CertificateProviderInstance);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CertificateProviderInstance other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (InstanceName != other.InstanceName) return false;
          if (CertificateName != other.CertificateName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (InstanceName.Length != 0) hash ^= InstanceName.GetHashCode();
          if (CertificateName.Length != 0) hash ^= CertificateName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (InstanceName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(InstanceName);
          }
          if (CertificateName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CertificateName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (InstanceName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(InstanceName);
          }
          if (CertificateName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(CertificateName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (InstanceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(InstanceName);
          }
          if (CertificateName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CertificateProviderInstance other) {
          if (other == null) {
            return;
          }
          if (other.InstanceName.Length != 0) {
            InstanceName = other.InstanceName;
          }
          if (other.CertificateName.Length != 0) {
            CertificateName = other.CertificateName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                InstanceName = input.ReadString();
                break;
              }
              case 18: {
                CertificateName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                InstanceName = input.ReadString();
                break;
              }
              case 18: {
                CertificateName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class CombinedCertificateValidationContext : pb::IMessage<CombinedCertificateValidationContext>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CombinedCertificateValidationContext> _parser = new pb::MessageParser<CombinedCertificateValidationContext>(() => new CombinedCertificateValidationContext());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CombinedCertificateValidationContext> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CombinedCertificateValidationContext() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CombinedCertificateValidationContext(CombinedCertificateValidationContext other) : this() {
          defaultValidationContext_ = other.defaultValidationContext_ != null ? other.defaultValidationContext_.Clone() : null;
          validationContextSdsSecretConfig_ = other.validationContextSdsSecretConfig_ != null ? other.validationContextSdsSecretConfig_.Clone() : null;
          validationContextCertificateProvider_ = other.validationContextCertificateProvider_ != null ? other.validationContextCertificateProvider_.Clone() : null;
          validationContextCertificateProviderInstance_ = other.validationContextCertificateProviderInstance_ != null ? other.validationContextCertificateProviderInstance_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CombinedCertificateValidationContext Clone() {
          return new CombinedCertificateValidationContext(this);
        }

        /// <summary>Field number for the "default_validation_context" field.</summary>
        public const int DefaultValidationContextFieldNumber = 1;
        private global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext defaultValidationContext_;
        /// <summary>
        /// How to validate peer certificates.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext DefaultValidationContext {
          get { return defaultValidationContext_; }
          set {
            defaultValidationContext_ = value;
          }
        }

        /// <summary>Field number for the "validation_context_sds_secret_config" field.</summary>
        public const int ValidationContextSdsSecretConfigFieldNumber = 2;
        private global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig validationContextSdsSecretConfig_;
        /// <summary>
        /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
        /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig ValidationContextSdsSecretConfig {
          get { return validationContextSdsSecretConfig_; }
          set {
            validationContextSdsSecretConfig_ = value;
          }
        }

        /// <summary>Field number for the "validation_context_certificate_provider" field.</summary>
        public const int ValidationContextCertificateProviderFieldNumber = 3;
        private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider validationContextCertificateProvider_;
        /// <summary>
        /// Certificate provider for fetching CA certs. This will populate the
        /// ``default_validation_context.trusted_ca`` field.
        /// [#not-implemented-hide:]
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider ValidationContextCertificateProvider {
          get { return validationContextCertificateProvider_; }
          set {
            validationContextCertificateProvider_ = value;
          }
        }

        /// <summary>Field number for the "validation_context_certificate_provider_instance" field.</summary>
        public const int ValidationContextCertificateProviderInstanceFieldNumber = 4;
        private global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance validationContextCertificateProviderInstance_;
        /// <summary>
        /// Certificate provider instance for fetching CA certs. This will populate the
        /// ``default_validation_context.trusted_ca`` field.
        /// [#not-implemented-hide:]
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance ValidationContextCertificateProviderInstance {
          get { return validationContextCertificateProviderInstance_; }
          set {
            validationContextCertificateProviderInstance_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CombinedCertificateValidationContext);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CombinedCertificateValidationContext other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(DefaultValidationContext, other.DefaultValidationContext)) return false;
          if (!object.Equals(ValidationContextSdsSecretConfig, other.ValidationContextSdsSecretConfig)) return false;
          if (!object.Equals(ValidationContextCertificateProvider, other.ValidationContextCertificateProvider)) return false;
          if (!object.Equals(ValidationContextCertificateProviderInstance, other.ValidationContextCertificateProviderInstance)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (defaultValidationContext_ != null) hash ^= DefaultValidationContext.GetHashCode();
          if (validationContextSdsSecretConfig_ != null) hash ^= ValidationContextSdsSecretConfig.GetHashCode();
          if (validationContextCertificateProvider_ != null) hash ^= ValidationContextCertificateProvider.GetHashCode();
          if (validationContextCertificateProviderInstance_ != null) hash ^= ValidationContextCertificateProviderInstance.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (defaultValidationContext_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(DefaultValidationContext);
          }
          if (validationContextSdsSecretConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ValidationContextSdsSecretConfig);
          }
          if (validationContextCertificateProvider_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ValidationContextCertificateProvider);
          }
          if (validationContextCertificateProviderInstance_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(ValidationContextCertificateProviderInstance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (defaultValidationContext_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(DefaultValidationContext);
          }
          if (validationContextSdsSecretConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ValidationContextSdsSecretConfig);
          }
          if (validationContextCertificateProvider_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ValidationContextCertificateProvider);
          }
          if (validationContextCertificateProviderInstance_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(ValidationContextCertificateProviderInstance);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (defaultValidationContext_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultValidationContext);
          }
          if (validationContextSdsSecretConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextSdsSecretConfig);
          }
          if (validationContextCertificateProvider_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextCertificateProvider);
          }
          if (validationContextCertificateProviderInstance_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidationContextCertificateProviderInstance);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CombinedCertificateValidationContext other) {
          if (other == null) {
            return;
          }
          if (other.defaultValidationContext_ != null) {
            if (defaultValidationContext_ == null) {
              DefaultValidationContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
            }
            DefaultValidationContext.MergeFrom(other.DefaultValidationContext);
          }
          if (other.validationContextSdsSecretConfig_ != null) {
            if (validationContextSdsSecretConfig_ == null) {
              ValidationContextSdsSecretConfig = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
            }
            ValidationContextSdsSecretConfig.MergeFrom(other.ValidationContextSdsSecretConfig);
          }
          if (other.validationContextCertificateProvider_ != null) {
            if (validationContextCertificateProvider_ == null) {
              ValidationContextCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
            }
            ValidationContextCertificateProvider.MergeFrom(other.ValidationContextCertificateProvider);
          }
          if (other.validationContextCertificateProviderInstance_ != null) {
            if (validationContextCertificateProviderInstance_ == null) {
              ValidationContextCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
            }
            ValidationContextCertificateProviderInstance.MergeFrom(other.ValidationContextCertificateProviderInstance);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (defaultValidationContext_ == null) {
                  DefaultValidationContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
                }
                input.ReadMessage(DefaultValidationContext);
                break;
              }
              case 18: {
                if (validationContextSdsSecretConfig_ == null) {
                  ValidationContextSdsSecretConfig = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
                }
                input.ReadMessage(ValidationContextSdsSecretConfig);
                break;
              }
              case 26: {
                if (validationContextCertificateProvider_ == null) {
                  ValidationContextCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
                }
                input.ReadMessage(ValidationContextCertificateProvider);
                break;
              }
              case 34: {
                if (validationContextCertificateProviderInstance_ == null) {
                  ValidationContextCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
                }
                input.ReadMessage(ValidationContextCertificateProviderInstance);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (defaultValidationContext_ == null) {
                  DefaultValidationContext = new global::Envoy.Extensions.TransportSockets.Tls.V3.CertificateValidationContext();
                }
                input.ReadMessage(DefaultValidationContext);
                break;
              }
              case 18: {
                if (validationContextSdsSecretConfig_ == null) {
                  ValidationContextSdsSecretConfig = new global::Envoy.Extensions.TransportSockets.Tls.V3.SdsSecretConfig();
                }
                input.ReadMessage(ValidationContextSdsSecretConfig);
                break;
              }
              case 26: {
                if (validationContextCertificateProvider_ == null) {
                  ValidationContextCertificateProvider = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProvider();
                }
                input.ReadMessage(ValidationContextCertificateProvider);
                break;
              }
              case 34: {
                if (validationContextCertificateProviderInstance_ == null) {
                  ValidationContextCertificateProviderInstance = new global::Envoy.Extensions.TransportSockets.Tls.V3.CommonTlsContext.Types.CertificateProviderInstance();
                }
                input.ReadMessage(ValidationContextCertificateProviderInstance);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
