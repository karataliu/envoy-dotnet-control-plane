// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/core/v3/address.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Core.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/core/v3/address.proto</summary>
  public static partial class AddressReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/core/v3/address.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AddressReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJlbnZveS9jb25maWcvY29yZS92My9hZGRyZXNzLnByb3RvEhRlbnZveS5j",
            "b25maWcuY29yZS52MxooZW52b3kvY29uZmlnL2NvcmUvdjMvc29ja2V0X29w",
            "dGlvbi5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGiNl",
            "bnZveS9hbm5vdGF0aW9ucy9kZXByZWNhdGlvbi5wcm90bxoddWRwYS9hbm5v",
            "dGF0aW9ucy9zdGF0dXMucHJvdG8aIXVkcGEvYW5ub3RhdGlvbnMvdmVyc2lv",
            "bmluZy5wcm90bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8iVAoEUGlwZRIV",
            "CgRwYXRoGAEgASgJQgf6QgRyAhABEhYKBG1vZGUYAiABKA1CCPpCBSoDGP8D",
            "Oh2axYgeGAoWZW52b3kuYXBpLnYyLmNvcmUuUGlwZSJqChRFbnZveUludGVy",
            "bmFsQWRkcmVzcxIeChRzZXJ2ZXJfbGlzdGVuZXJfbmFtZRgBIAEoCUgAEhMK",
            "C2VuZHBvaW50X2lkGAIgASgJQh0KFmFkZHJlc3NfbmFtZV9zcGVjaWZpZXIS",
            "A/hCASKzAgoNU29ja2V0QWRkcmVzcxJICghwcm90b2NvbBgBIAEoDjIsLmVu",
            "dm95LmNvbmZpZy5jb3JlLnYzLlNvY2tldEFkZHJlc3MuUHJvdG9jb2xCCPpC",
            "BYIBAhABEhgKB2FkZHJlc3MYAiABKAlCB/pCBHICEAESHwoKcG9ydF92YWx1",
            "ZRgDIAEoDUIJ+kIGKgQY//8DSAASFAoKbmFtZWRfcG9ydBgEIAEoCUgAEhUK",
            "DXJlc29sdmVyX25hbWUYBSABKAkSEwoLaXB2NF9jb21wYXQYBiABKAgiHAoI",
            "UHJvdG9jb2wSBwoDVENQEAASBwoDVURQEAE6JprFiB4hCh9lbnZveS5hcGku",
            "djIuY29yZS5Tb2NrZXRBZGRyZXNzQhUKDnBvcnRfc3BlY2lmaWVyEgP4QgEi",
            "3QEKDFRjcEtlZXBhbGl2ZRI2ChBrZWVwYWxpdmVfcHJvYmVzGAEgASgLMhwu",
            "Z29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEjQKDmtlZXBhbGl2ZV90aW1l",
            "GAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEjgKEmtlZXBh",
            "bGl2ZV9pbnRlcnZhbBgDIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZTolmsWIHiAKHmVudm95LmFwaS52Mi5jb3JlLlRjcEtlZXBhbGl2ZSKZ",
            "AQoSRXh0cmFTb3VyY2VBZGRyZXNzEj4KB2FkZHJlc3MYASABKAsyIy5lbnZv",
            "eS5jb25maWcuY29yZS52My5Tb2NrZXRBZGRyZXNzQgj6QgWKAQIQARJDCg5z",
            "b2NrZXRfb3B0aW9ucxgCIAEoCzIrLmVudm95LmNvbmZpZy5jb3JlLnYzLlNv",
            "Y2tldE9wdGlvbnNPdmVycmlkZSL5AgoKQmluZENvbmZpZxI7Cg5zb3VyY2Vf",
            "YWRkcmVzcxgBIAEoCzIjLmVudm95LmNvbmZpZy5jb3JlLnYzLlNvY2tldEFk",
            "ZHJlc3MSLAoIZnJlZWJpbmQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9v",
            "bFZhbHVlEjoKDnNvY2tldF9vcHRpb25zGAMgAygLMiIuZW52b3kuY29uZmln",
            "LmNvcmUudjMuU29ja2V0T3B0aW9uEkgKFmV4dHJhX3NvdXJjZV9hZGRyZXNz",
            "ZXMYBSADKAsyKC5lbnZveS5jb25maWcuY29yZS52My5FeHRyYVNvdXJjZUFk",
            "ZHJlc3MSVQobYWRkaXRpb25hbF9zb3VyY2VfYWRkcmVzc2VzGAQgAygLMiMu",
            "ZW52b3kuY29uZmlnLmNvcmUudjMuU29ja2V0QWRkcmVzc0ILGAGSx4bYBAMz",
            "LjA6I5rFiB4eChxlbnZveS5hcGkudjIuY29yZS5CaW5kQ29uZmlnIvQBCgdB",
            "ZGRyZXNzEj0KDnNvY2tldF9hZGRyZXNzGAEgASgLMiMuZW52b3kuY29uZmln",
            "LmNvcmUudjMuU29ja2V0QWRkcmVzc0gAEioKBHBpcGUYAiABKAsyGi5lbnZv",
            "eS5jb25maWcuY29yZS52My5QaXBlSAASTAoWZW52b3lfaW50ZXJuYWxfYWRk",
            "cmVzcxgDIAEoCzIqLmVudm95LmNvbmZpZy5jb3JlLnYzLkVudm95SW50ZXJu",
            "YWxBZGRyZXNzSAA6IJrFiB4bChllbnZveS5hcGkudjIuY29yZS5BZGRyZXNz",
            "Qg4KB2FkZHJlc3MSA/hCASKMAQoJQ2lkclJhbmdlEh8KDmFkZHJlc3NfcHJl",
            "Zml4GAEgASgJQgf6QgRyAhABEjoKCnByZWZpeF9sZW4YAiABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWVCCPpCBSoDGIABOiKaxYgeHQobZW52",
            "b3kuYXBpLnYyLmNvcmUuQ2lkclJhbmdlQoABCiJpby5lbnZveXByb3h5LmVu",
            "dm95LmNvbmZpZy5jb3JlLnYzQgxBZGRyZXNzUHJvdG9QAVpCZ2l0aHViLmNv",
            "bS9lbnZveXByb3h5L2dvLWNvbnRyb2wtcGxhbmUvZW52b3kvY29uZmlnL2Nv",
            "cmUvdjM7Y29yZXYzuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.SocketOptionReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Pipe), global::Envoy.Config.Core.V3.Pipe.Parser, new[]{ "Path", "Mode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.EnvoyInternalAddress), global::Envoy.Config.Core.V3.EnvoyInternalAddress.Parser, new[]{ "ServerListenerName", "EndpointId" }, new[]{ "AddressNameSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.SocketAddress), global::Envoy.Config.Core.V3.SocketAddress.Parser, new[]{ "Protocol", "Address", "PortValue", "NamedPort", "ResolverName", "Ipv4Compat" }, new[]{ "PortSpecifier" }, new[]{ typeof(global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.TcpKeepalive), global::Envoy.Config.Core.V3.TcpKeepalive.Parser, new[]{ "KeepaliveProbes", "KeepaliveTime", "KeepaliveInterval" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ExtraSourceAddress), global::Envoy.Config.Core.V3.ExtraSourceAddress.Parser, new[]{ "Address", "SocketOptions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.BindConfig), global::Envoy.Config.Core.V3.BindConfig.Parser, new[]{ "SourceAddress", "Freebind", "SocketOptions", "ExtraSourceAddresses", "AdditionalSourceAddresses" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Address), global::Envoy.Config.Core.V3.Address.Parser, new[]{ "SocketAddress", "Pipe", "EnvoyInternalAddress" }, new[]{ "Address" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.CidrRange), global::Envoy.Config.Core.V3.CidrRange.Parser, new[]{ "AddressPrefix", "PrefixLen" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Pipe : pb::IMessage<Pipe>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Pipe> _parser = new pb::MessageParser<Pipe>(() => new Pipe());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Pipe> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pipe() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pipe(Pipe other) : this() {
      path_ = other.path_;
      mode_ = other.mode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pipe Clone() {
      return new Pipe(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private string path_ = "";
    /// <summary>
    /// Unix Domain Socket path. On Linux, paths starting with '@' will use the
    /// abstract namespace. The starting '@' is replaced by a null byte by Envoy.
    /// Paths starting with '@' will result in an error in environments other than
    /// Linux.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 2;
    private uint mode_;
    /// <summary>
    /// The mode for the Pipe. Not applicable for abstract sockets.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Mode {
      get { return mode_; }
      set {
        mode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Pipe);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Pipe other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (Mode != other.Mode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Path.Length != 0) hash ^= Path.GetHashCode();
      if (Mode != 0) hash ^= Mode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (Mode != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (Mode != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Path.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (Mode != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Mode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Pipe other) {
      if (other == null) {
        return;
      }
      if (other.Path.Length != 0) {
        Path = other.Path;
      }
      if (other.Mode != 0) {
        Mode = other.Mode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 16: {
            Mode = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 16: {
            Mode = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The address represents an envoy internal listener.
  /// [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
  /// </summary>
  public sealed partial class EnvoyInternalAddress : pb::IMessage<EnvoyInternalAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvoyInternalAddress> _parser = new pb::MessageParser<EnvoyInternalAddress>(() => new EnvoyInternalAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvoyInternalAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyInternalAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyInternalAddress(EnvoyInternalAddress other) : this() {
      endpointId_ = other.endpointId_;
      switch (other.AddressNameSpecifierCase) {
        case AddressNameSpecifierOneofCase.ServerListenerName:
          ServerListenerName = other.ServerListenerName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvoyInternalAddress Clone() {
      return new EnvoyInternalAddress(this);
    }

    /// <summary>Field number for the "server_listener_name" field.</summary>
    public const int ServerListenerNameFieldNumber = 1;
    /// <summary>
    /// Specifies the :ref:`name &lt;envoy_v3_api_field_config.listener.v3.Listener.name>` of the
    /// internal listener.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServerListenerName {
      get { return addressNameSpecifierCase_ == AddressNameSpecifierOneofCase.ServerListenerName ? (string) addressNameSpecifier_ : ""; }
      set {
        addressNameSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        addressNameSpecifierCase_ = AddressNameSpecifierOneofCase.ServerListenerName;
      }
    }

    /// <summary>Field number for the "endpoint_id" field.</summary>
    public const int EndpointIdFieldNumber = 2;
    private string endpointId_ = "";
    /// <summary>
    /// Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
    /// single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
    /// example, may be set to the final destination IP for the target internal listener.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string EndpointId {
      get { return endpointId_; }
      set {
        endpointId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object addressNameSpecifier_;
    /// <summary>Enum of possible cases for the "address_name_specifier" oneof.</summary>
    public enum AddressNameSpecifierOneofCase {
      None = 0,
      ServerListenerName = 1,
    }
    private AddressNameSpecifierOneofCase addressNameSpecifierCase_ = AddressNameSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AddressNameSpecifierOneofCase AddressNameSpecifierCase {
      get { return addressNameSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAddressNameSpecifier() {
      addressNameSpecifierCase_ = AddressNameSpecifierOneofCase.None;
      addressNameSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvoyInternalAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvoyInternalAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServerListenerName != other.ServerListenerName) return false;
      if (EndpointId != other.EndpointId) return false;
      if (AddressNameSpecifierCase != other.AddressNameSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (addressNameSpecifierCase_ == AddressNameSpecifierOneofCase.ServerListenerName) hash ^= ServerListenerName.GetHashCode();
      if (EndpointId.Length != 0) hash ^= EndpointId.GetHashCode();
      hash ^= (int) addressNameSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (addressNameSpecifierCase_ == AddressNameSpecifierOneofCase.ServerListenerName) {
        output.WriteRawTag(10);
        output.WriteString(ServerListenerName);
      }
      if (EndpointId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(EndpointId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (addressNameSpecifierCase_ == AddressNameSpecifierOneofCase.ServerListenerName) {
        output.WriteRawTag(10);
        output.WriteString(ServerListenerName);
      }
      if (EndpointId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(EndpointId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (addressNameSpecifierCase_ == AddressNameSpecifierOneofCase.ServerListenerName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServerListenerName);
      }
      if (EndpointId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EndpointId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvoyInternalAddress other) {
      if (other == null) {
        return;
      }
      if (other.EndpointId.Length != 0) {
        EndpointId = other.EndpointId;
      }
      switch (other.AddressNameSpecifierCase) {
        case AddressNameSpecifierOneofCase.ServerListenerName:
          ServerListenerName = other.ServerListenerName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ServerListenerName = input.ReadString();
            break;
          }
          case 18: {
            EndpointId = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServerListenerName = input.ReadString();
            break;
          }
          case 18: {
            EndpointId = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class SocketAddress : pb::IMessage<SocketAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SocketAddress> _parser = new pb::MessageParser<SocketAddress>(() => new SocketAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SocketAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SocketAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SocketAddress(SocketAddress other) : this() {
      protocol_ = other.protocol_;
      address_ = other.address_;
      resolverName_ = other.resolverName_;
      ipv4Compat_ = other.ipv4Compat_;
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SocketAddress Clone() {
      return new SocketAddress(this);
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 1;
    private global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol protocol_ = global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol Protocol {
      get { return protocol_; }
      set {
        protocol_ = value;
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private string address_ = "";
    /// <summary>
    /// The address for this socket. :ref:`Listeners &lt;config_listeners>` will bind
    /// to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
    /// to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
    /// It is possible to distinguish a Listener address via the prefix/suffix matching
    /// in :ref:`FilterChainMatch &lt;envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
    /// within an upstream :ref:`BindConfig &lt;envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
    /// controls the source address of outbound connections. For :ref:`clusters
    /// &lt;envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
    /// address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
    /// (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
    /// via :ref:`resolver_name &lt;envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port_value" field.</summary>
    public const int PortValueFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PortValue {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.PortValue ? (uint) portSpecifier_ : 0; }
      set {
        portSpecifier_ = value;
        portSpecifierCase_ = PortSpecifierOneofCase.PortValue;
      }
    }

    /// <summary>Field number for the "named_port" field.</summary>
    public const int NamedPortFieldNumber = 4;
    /// <summary>
    /// This is only valid if :ref:`resolver_name
    /// &lt;envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
    /// named resolver is capable of named port resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NamedPort {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.NamedPort ? (string) portSpecifier_ : ""; }
      set {
        portSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        portSpecifierCase_ = PortSpecifierOneofCase.NamedPort;
      }
    }

    /// <summary>Field number for the "resolver_name" field.</summary>
    public const int ResolverNameFieldNumber = 5;
    private string resolverName_ = "";
    /// <summary>
    /// The name of the custom resolver. This must have been registered with Envoy. If
    /// this is empty, a context dependent default applies. If the address is a concrete
    /// IP address, no resolution will occur. If address is a hostname this
    /// should be set for resolution other than DNS. Specifying a custom resolver with
    /// ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ResolverName {
      get { return resolverName_; }
      set {
        resolverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ipv4_compat" field.</summary>
    public const int Ipv4CompatFieldNumber = 6;
    private bool ipv4Compat_;
    /// <summary>
    /// When binding to an IPv6 address above, this enables `IPv4 compatibility
    /// &lt;https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
    /// allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
    /// IPv6 space as ``::FFFF:&lt;IPv4-address>``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ipv4Compat {
      get { return ipv4Compat_; }
      set {
        ipv4Compat_ = value;
      }
    }

    private object portSpecifier_;
    /// <summary>Enum of possible cases for the "port_specifier" oneof.</summary>
    public enum PortSpecifierOneofCase {
      None = 0,
      PortValue = 3,
      NamedPort = 4,
    }
    private PortSpecifierOneofCase portSpecifierCase_ = PortSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortSpecifierOneofCase PortSpecifierCase {
      get { return portSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPortSpecifier() {
      portSpecifierCase_ = PortSpecifierOneofCase.None;
      portSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SocketAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SocketAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Protocol != other.Protocol) return false;
      if (Address != other.Address) return false;
      if (PortValue != other.PortValue) return false;
      if (NamedPort != other.NamedPort) return false;
      if (ResolverName != other.ResolverName) return false;
      if (Ipv4Compat != other.Ipv4Compat) return false;
      if (PortSpecifierCase != other.PortSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Protocol != global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp) hash ^= Protocol.GetHashCode();
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) hash ^= PortValue.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) hash ^= NamedPort.GetHashCode();
      if (ResolverName.Length != 0) hash ^= ResolverName.GetHashCode();
      if (Ipv4Compat != false) hash ^= Ipv4Compat.GetHashCode();
      hash ^= (int) portSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Protocol != global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Protocol);
      }
      if (Address.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        output.WriteRawTag(24);
        output.WriteUInt32(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        output.WriteRawTag(34);
        output.WriteString(NamedPort);
      }
      if (ResolverName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ResolverName);
      }
      if (Ipv4Compat != false) {
        output.WriteRawTag(48);
        output.WriteBool(Ipv4Compat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Protocol != global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Protocol);
      }
      if (Address.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        output.WriteRawTag(24);
        output.WriteUInt32(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        output.WriteRawTag(34);
        output.WriteString(NamedPort);
      }
      if (ResolverName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ResolverName);
      }
      if (Ipv4Compat != false) {
        output.WriteRawTag(48);
        output.WriteBool(Ipv4Compat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Protocol != global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Protocol);
      }
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NamedPort);
      }
      if (ResolverName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResolverName);
      }
      if (Ipv4Compat != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SocketAddress other) {
      if (other == null) {
        return;
      }
      if (other.Protocol != global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol.Tcp) {
        Protocol = other.Protocol;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      if (other.ResolverName.Length != 0) {
        ResolverName = other.ResolverName;
      }
      if (other.Ipv4Compat != false) {
        Ipv4Compat = other.Ipv4Compat;
      }
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Protocol = (global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol) input.ReadEnum();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
          case 24: {
            PortValue = input.ReadUInt32();
            break;
          }
          case 34: {
            NamedPort = input.ReadString();
            break;
          }
          case 42: {
            ResolverName = input.ReadString();
            break;
          }
          case 48: {
            Ipv4Compat = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Protocol = (global::Envoy.Config.Core.V3.SocketAddress.Types.Protocol) input.ReadEnum();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
          case 24: {
            PortValue = input.ReadUInt32();
            break;
          }
          case 34: {
            NamedPort = input.ReadString();
            break;
          }
          case 42: {
            ResolverName = input.ReadString();
            break;
          }
          case 48: {
            Ipv4Compat = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SocketAddress message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Protocol {
        [pbr::OriginalName("TCP")] Tcp = 0,
        [pbr::OriginalName("UDP")] Udp = 1,
      }

    }
    #endregion

  }

  public sealed partial class TcpKeepalive : pb::IMessage<TcpKeepalive>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TcpKeepalive> _parser = new pb::MessageParser<TcpKeepalive>(() => new TcpKeepalive());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TcpKeepalive> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpKeepalive() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpKeepalive(TcpKeepalive other) : this() {
      KeepaliveProbes = other.KeepaliveProbes;
      KeepaliveTime = other.KeepaliveTime;
      KeepaliveInterval = other.KeepaliveInterval;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpKeepalive Clone() {
      return new TcpKeepalive(this);
    }

    /// <summary>Field number for the "keepalive_probes" field.</summary>
    public const int KeepaliveProbesFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveProbes_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? keepaliveProbes_;
    /// <summary>
    /// Maximum number of keepalive probes to send without response before deciding
    /// the connection is dead. Default is to use the OS level configuration (unless
    /// overridden, Linux defaults to 9.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? KeepaliveProbes {
      get { return keepaliveProbes_; }
      set {
        keepaliveProbes_ = value;
      }
    }


    /// <summary>Field number for the "keepalive_time" field.</summary>
    public const int KeepaliveTimeFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveTime_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? keepaliveTime_;
    /// <summary>
    /// The number of seconds a connection needs to be idle before keep-alive probes
    /// start being sent. Default is to use the OS level configuration (unless
    /// overridden, Linux defaults to 7200s (i.e., 2 hours.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? KeepaliveTime {
      get { return keepaliveTime_; }
      set {
        keepaliveTime_ = value;
      }
    }


    /// <summary>Field number for the "keepalive_interval" field.</summary>
    public const int KeepaliveIntervalFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_keepaliveInterval_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? keepaliveInterval_;
    /// <summary>
    /// The number of seconds between keep-alive probes. Default is to use the OS
    /// level configuration (unless overridden, Linux defaults to 75s.)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? KeepaliveInterval {
      get { return keepaliveInterval_; }
      set {
        keepaliveInterval_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TcpKeepalive);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TcpKeepalive other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (KeepaliveProbes != other.KeepaliveProbes) return false;
      if (KeepaliveTime != other.KeepaliveTime) return false;
      if (KeepaliveInterval != other.KeepaliveInterval) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (keepaliveProbes_ != null) hash ^= KeepaliveProbes.GetHashCode();
      if (keepaliveTime_ != null) hash ^= KeepaliveTime.GetHashCode();
      if (keepaliveInterval_ != null) hash ^= KeepaliveInterval.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (keepaliveProbes_ != null) {
        _single_keepaliveProbes_codec.WriteTagAndValue(output, KeepaliveProbes);
      }
      if (keepaliveTime_ != null) {
        _single_keepaliveTime_codec.WriteTagAndValue(output, KeepaliveTime);
      }
      if (keepaliveInterval_ != null) {
        _single_keepaliveInterval_codec.WriteTagAndValue(output, KeepaliveInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (keepaliveProbes_ != null) {
        _single_keepaliveProbes_codec.WriteTagAndValue(ref output, KeepaliveProbes);
      }
      if (keepaliveTime_ != null) {
        _single_keepaliveTime_codec.WriteTagAndValue(ref output, KeepaliveTime);
      }
      if (keepaliveInterval_ != null) {
        _single_keepaliveInterval_codec.WriteTagAndValue(ref output, KeepaliveInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (keepaliveProbes_ != null) {
        size += _single_keepaliveProbes_codec.CalculateSizeWithTag(KeepaliveProbes);
      }
      if (keepaliveTime_ != null) {
        size += _single_keepaliveTime_codec.CalculateSizeWithTag(KeepaliveTime);
      }
      if (keepaliveInterval_ != null) {
        size += _single_keepaliveInterval_codec.CalculateSizeWithTag(KeepaliveInterval);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TcpKeepalive other) {
      if (other == null) {
        return;
      }
      if (other.keepaliveProbes_ != null) {
        if (keepaliveProbes_ == null || other.KeepaliveProbes != 0) {
          KeepaliveProbes = other.KeepaliveProbes;
        }
      }
      if (other.keepaliveTime_ != null) {
        if (keepaliveTime_ == null || other.KeepaliveTime != 0) {
          KeepaliveTime = other.KeepaliveTime;
        }
      }
      if (other.keepaliveInterval_ != null) {
        if (keepaliveInterval_ == null || other.KeepaliveInterval != 0) {
          KeepaliveInterval = other.KeepaliveInterval;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_keepaliveProbes_codec.Read(input);
            if (keepaliveProbes_ == null || value != 0) {
              KeepaliveProbes = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_keepaliveTime_codec.Read(input);
            if (keepaliveTime_ == null || value != 0) {
              KeepaliveTime = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_keepaliveInterval_codec.Read(input);
            if (keepaliveInterval_ == null || value != 0) {
              KeepaliveInterval = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_keepaliveProbes_codec.Read(ref input);
            if (keepaliveProbes_ == null || value != 0) {
              KeepaliveProbes = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_keepaliveTime_codec.Read(ref input);
            if (keepaliveTime_ == null || value != 0) {
              KeepaliveTime = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_keepaliveInterval_codec.Read(ref input);
            if (keepaliveInterval_ == null || value != 0) {
              KeepaliveInterval = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ExtraSourceAddress : pb::IMessage<ExtraSourceAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExtraSourceAddress> _parser = new pb::MessageParser<ExtraSourceAddress>(() => new ExtraSourceAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExtraSourceAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtraSourceAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtraSourceAddress(ExtraSourceAddress other) : this() {
      address_ = other.address_ != null ? other.address_.Clone() : null;
      socketOptions_ = other.socketOptions_ != null ? other.socketOptions_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtraSourceAddress Clone() {
      return new ExtraSourceAddress(this);
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 1;
    private global::Envoy.Config.Core.V3.SocketAddress address_;
    /// <summary>
    /// The additional address to bind.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SocketAddress Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "socket_options" field.</summary>
    public const int SocketOptionsFieldNumber = 2;
    private global::Envoy.Config.Core.V3.SocketOptionsOverride socketOptions_;
    /// <summary>
    /// Additional socket options that may not be present in Envoy source code or
    /// precompiled binaries. If specified, this will override the
    /// :ref:`socket_options &lt;envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
    /// in the BindConfig. If specified with no
    /// :ref:`socket_options &lt;envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
    /// or an empty list of :ref:`socket_options &lt;envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
    /// it means no socket option will apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SocketOptionsOverride SocketOptions {
      get { return socketOptions_; }
      set {
        socketOptions_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExtraSourceAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExtraSourceAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Address, other.Address)) return false;
      if (!object.Equals(SocketOptions, other.SocketOptions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (address_ != null) hash ^= Address.GetHashCode();
      if (socketOptions_ != null) hash ^= SocketOptions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (address_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Address);
      }
      if (socketOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SocketOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (address_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Address);
      }
      if (socketOptions_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SocketOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      if (socketOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SocketOptions);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExtraSourceAddress other) {
      if (other == null) {
        return;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          Address = new global::Envoy.Config.Core.V3.SocketAddress();
        }
        Address.MergeFrom(other.Address);
      }
      if (other.socketOptions_ != null) {
        if (socketOptions_ == null) {
          SocketOptions = new global::Envoy.Config.Core.V3.SocketOptionsOverride();
        }
        SocketOptions.MergeFrom(other.SocketOptions);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (address_ == null) {
              Address = new global::Envoy.Config.Core.V3.SocketAddress();
            }
            input.ReadMessage(Address);
            break;
          }
          case 18: {
            if (socketOptions_ == null) {
              SocketOptions = new global::Envoy.Config.Core.V3.SocketOptionsOverride();
            }
            input.ReadMessage(SocketOptions);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (address_ == null) {
              Address = new global::Envoy.Config.Core.V3.SocketAddress();
            }
            input.ReadMessage(Address);
            break;
          }
          case 18: {
            if (socketOptions_ == null) {
              SocketOptions = new global::Envoy.Config.Core.V3.SocketOptionsOverride();
            }
            input.ReadMessage(SocketOptions);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class BindConfig : pb::IMessage<BindConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BindConfig> _parser = new pb::MessageParser<BindConfig>(() => new BindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BindConfig(BindConfig other) : this() {
      sourceAddress_ = other.sourceAddress_ != null ? other.sourceAddress_.Clone() : null;
      Freebind = other.Freebind;
      socketOptions_ = other.socketOptions_.Clone();
      extraSourceAddresses_ = other.extraSourceAddresses_.Clone();
      additionalSourceAddresses_ = other.additionalSourceAddresses_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BindConfig Clone() {
      return new BindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Config.Core.V3.SocketAddress sourceAddress_;
    /// <summary>
    /// The address to bind to when creating a socket.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SocketAddress SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? freebind_;
    /// <summary>
    /// Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
    /// flag is set to true, allows the :ref:`source_address
    /// &lt;envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
    /// that is not configured on the system running Envoy. When this flag is set
    /// to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
    /// flag is not set (default), the socket is not modified, i.e. the option is
    /// neither enabled nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }


    /// <summary>Field number for the "socket_options" field.</summary>
    public const int SocketOptionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.SocketOption> _repeated_socketOptions_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Core.V3.SocketOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption> socketOptions_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption>();
    /// <summary>
    /// Additional socket options that may not be present in Envoy source code or
    /// precompiled binaries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketOption> SocketOptions {
      get { return socketOptions_; }
    }

    /// <summary>Field number for the "extra_source_addresses" field.</summary>
    public const int ExtraSourceAddressesFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.ExtraSourceAddress> _repeated_extraSourceAddresses_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Core.V3.ExtraSourceAddress.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.ExtraSourceAddress> extraSourceAddresses_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.ExtraSourceAddress>();
    /// <summary>
    /// Extra source addresses appended to the address specified in the `source_address`
    /// field. This enables to specify multiple source addresses. Currently, only one extra
    /// address can be supported, and the extra address should have a different IP version
    /// with the address in the `source_address` field. The address which has the same IP
    /// version with the target host's address IP version will be used as bind address. If more
    /// than one extra address specified, only the first address matched IP version will be
    /// returned. If there is no same IP version address found, the address in the `source_address`
    /// will be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.ExtraSourceAddress> ExtraSourceAddresses {
      get { return extraSourceAddresses_; }
    }

    /// <summary>Field number for the "additional_source_addresses" field.</summary>
    public const int AdditionalSourceAddressesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.SocketAddress> _repeated_additionalSourceAddresses_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Core.V3.SocketAddress.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress> additionalSourceAddresses_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress>();
    /// <summary>
    /// Deprecated by
    /// :ref:`extra_source_addresses &lt;envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.SocketAddress> AdditionalSourceAddresses {
      get { return additionalSourceAddresses_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      if (Freebind != other.Freebind) return false;
      if(!socketOptions_.Equals(other.socketOptions_)) return false;
      if(!extraSourceAddresses_.Equals(other.extraSourceAddresses_)) return false;
      if(!additionalSourceAddresses_.Equals(other.additionalSourceAddresses_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      hash ^= socketOptions_.GetHashCode();
      hash ^= extraSourceAddresses_.GetHashCode();
      hash ^= additionalSourceAddresses_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      socketOptions_.WriteTo(output, _repeated_socketOptions_codec);
      additionalSourceAddresses_.WriteTo(output, _repeated_additionalSourceAddresses_codec);
      extraSourceAddresses_.WriteTo(output, _repeated_extraSourceAddresses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(ref output, Freebind);
      }
      socketOptions_.WriteTo(ref output, _repeated_socketOptions_codec);
      additionalSourceAddresses_.WriteTo(ref output, _repeated_additionalSourceAddresses_codec);
      extraSourceAddresses_.WriteTo(ref output, _repeated_extraSourceAddresses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      size += socketOptions_.CalculateSize(_repeated_socketOptions_codec);
      size += extraSourceAddresses_.CalculateSize(_repeated_extraSourceAddresses_codec);
      size += additionalSourceAddresses_.CalculateSize(_repeated_additionalSourceAddresses_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          SourceAddress = new global::Envoy.Config.Core.V3.SocketAddress();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      socketOptions_.Add(other.socketOptions_);
      extraSourceAddresses_.Add(other.extraSourceAddresses_);
      additionalSourceAddresses_.Add(other.additionalSourceAddresses_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Config.Core.V3.SocketAddress();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
          case 18: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 26: {
            socketOptions_.AddEntriesFrom(input, _repeated_socketOptions_codec);
            break;
          }
          case 34: {
            additionalSourceAddresses_.AddEntriesFrom(input, _repeated_additionalSourceAddresses_codec);
            break;
          }
          case 42: {
            extraSourceAddresses_.AddEntriesFrom(input, _repeated_extraSourceAddresses_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Config.Core.V3.SocketAddress();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
          case 18: {
            bool? value = _single_freebind_codec.Read(ref input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 26: {
            socketOptions_.AddEntriesFrom(ref input, _repeated_socketOptions_codec);
            break;
          }
          case 34: {
            additionalSourceAddresses_.AddEntriesFrom(ref input, _repeated_additionalSourceAddresses_codec);
            break;
          }
          case 42: {
            extraSourceAddresses_.AddEntriesFrom(ref input, _repeated_extraSourceAddresses_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Addresses specify either a logical or physical address and port, which are
  /// used to tell Envoy where to bind/listen, connect to upstream and find
  /// management servers.
  /// </summary>
  public sealed partial class Address : pb::IMessage<Address>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Address> _parser = new pb::MessageParser<Address>(() => new Address());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Address> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Address() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Address(Address other) : this() {
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          SocketAddress = other.SocketAddress.Clone();
          break;
        case AddressOneofCase.Pipe:
          Pipe = other.Pipe.Clone();
          break;
        case AddressOneofCase.EnvoyInternalAddress:
          EnvoyInternalAddress = other.EnvoyInternalAddress.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Address Clone() {
      return new Address(this);
    }

    /// <summary>Field number for the "socket_address" field.</summary>
    public const int SocketAddressFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SocketAddress SocketAddress {
      get { return addressCase_ == AddressOneofCase.SocketAddress ? (global::Envoy.Config.Core.V3.SocketAddress) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.SocketAddress;
      }
    }

    /// <summary>Field number for the "pipe" field.</summary>
    public const int PipeFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Pipe Pipe {
      get { return addressCase_ == AddressOneofCase.Pipe ? (global::Envoy.Config.Core.V3.Pipe) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.Pipe;
      }
    }

    /// <summary>Field number for the "envoy_internal_address" field.</summary>
    public const int EnvoyInternalAddressFieldNumber = 3;
    /// <summary>
    /// Specifies a user-space address handled by :ref:`internal listeners
    /// &lt;envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.EnvoyInternalAddress EnvoyInternalAddress {
      get { return addressCase_ == AddressOneofCase.EnvoyInternalAddress ? (global::Envoy.Config.Core.V3.EnvoyInternalAddress) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.EnvoyInternalAddress;
      }
    }

    private object address_;
    /// <summary>Enum of possible cases for the "address" oneof.</summary>
    public enum AddressOneofCase {
      None = 0,
      SocketAddress = 1,
      Pipe = 2,
      EnvoyInternalAddress = 3,
    }
    private AddressOneofCase addressCase_ = AddressOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AddressOneofCase AddressCase {
      get { return addressCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAddress() {
      addressCase_ = AddressOneofCase.None;
      address_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Address);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Address other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SocketAddress, other.SocketAddress)) return false;
      if (!object.Equals(Pipe, other.Pipe)) return false;
      if (!object.Equals(EnvoyInternalAddress, other.EnvoyInternalAddress)) return false;
      if (AddressCase != other.AddressCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (addressCase_ == AddressOneofCase.SocketAddress) hash ^= SocketAddress.GetHashCode();
      if (addressCase_ == AddressOneofCase.Pipe) hash ^= Pipe.GetHashCode();
      if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) hash ^= EnvoyInternalAddress.GetHashCode();
      hash ^= (int) addressCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        output.WriteRawTag(10);
        output.WriteMessage(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        output.WriteRawTag(18);
        output.WriteMessage(Pipe);
      }
      if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) {
        output.WriteRawTag(26);
        output.WriteMessage(EnvoyInternalAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        output.WriteRawTag(10);
        output.WriteMessage(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        output.WriteRawTag(18);
        output.WriteMessage(Pipe);
      }
      if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) {
        output.WriteRawTag(26);
        output.WriteMessage(EnvoyInternalAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pipe);
      }
      if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EnvoyInternalAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Address other) {
      if (other == null) {
        return;
      }
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          if (SocketAddress == null) {
            SocketAddress = new global::Envoy.Config.Core.V3.SocketAddress();
          }
          SocketAddress.MergeFrom(other.SocketAddress);
          break;
        case AddressOneofCase.Pipe:
          if (Pipe == null) {
            Pipe = new global::Envoy.Config.Core.V3.Pipe();
          }
          Pipe.MergeFrom(other.Pipe);
          break;
        case AddressOneofCase.EnvoyInternalAddress:
          if (EnvoyInternalAddress == null) {
            EnvoyInternalAddress = new global::Envoy.Config.Core.V3.EnvoyInternalAddress();
          }
          EnvoyInternalAddress.MergeFrom(other.EnvoyInternalAddress);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Core.V3.SocketAddress subBuilder = new global::Envoy.Config.Core.V3.SocketAddress();
            if (addressCase_ == AddressOneofCase.SocketAddress) {
              subBuilder.MergeFrom(SocketAddress);
            }
            input.ReadMessage(subBuilder);
            SocketAddress = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.Pipe subBuilder = new global::Envoy.Config.Core.V3.Pipe();
            if (addressCase_ == AddressOneofCase.Pipe) {
              subBuilder.MergeFrom(Pipe);
            }
            input.ReadMessage(subBuilder);
            Pipe = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.EnvoyInternalAddress subBuilder = new global::Envoy.Config.Core.V3.EnvoyInternalAddress();
            if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) {
              subBuilder.MergeFrom(EnvoyInternalAddress);
            }
            input.ReadMessage(subBuilder);
            EnvoyInternalAddress = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Envoy.Config.Core.V3.SocketAddress subBuilder = new global::Envoy.Config.Core.V3.SocketAddress();
            if (addressCase_ == AddressOneofCase.SocketAddress) {
              subBuilder.MergeFrom(SocketAddress);
            }
            input.ReadMessage(subBuilder);
            SocketAddress = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.Pipe subBuilder = new global::Envoy.Config.Core.V3.Pipe();
            if (addressCase_ == AddressOneofCase.Pipe) {
              subBuilder.MergeFrom(Pipe);
            }
            input.ReadMessage(subBuilder);
            Pipe = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.EnvoyInternalAddress subBuilder = new global::Envoy.Config.Core.V3.EnvoyInternalAddress();
            if (addressCase_ == AddressOneofCase.EnvoyInternalAddress) {
              subBuilder.MergeFrom(EnvoyInternalAddress);
            }
            input.ReadMessage(subBuilder);
            EnvoyInternalAddress = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// CidrRange specifies an IP Address and a prefix length to construct
  /// the subnet mask for a `CIDR &lt;https://tools.ietf.org/html/rfc4632>`_ range.
  /// </summary>
  public sealed partial class CidrRange : pb::IMessage<CidrRange>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CidrRange> _parser = new pb::MessageParser<CidrRange>(() => new CidrRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CidrRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.AddressReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CidrRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CidrRange(CidrRange other) : this() {
      addressPrefix_ = other.addressPrefix_;
      PrefixLen = other.PrefixLen;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CidrRange Clone() {
      return new CidrRange(this);
    }

    /// <summary>Field number for the "address_prefix" field.</summary>
    public const int AddressPrefixFieldNumber = 1;
    private string addressPrefix_ = "";
    /// <summary>
    /// IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AddressPrefix {
      get { return addressPrefix_; }
      set {
        addressPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "prefix_len" field.</summary>
    public const int PrefixLenFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_prefixLen_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? prefixLen_;
    /// <summary>
    /// Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PrefixLen {
      get { return prefixLen_; }
      set {
        prefixLen_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CidrRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CidrRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AddressPrefix != other.AddressPrefix) return false;
      if (PrefixLen != other.PrefixLen) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (AddressPrefix.Length != 0) hash ^= AddressPrefix.GetHashCode();
      if (prefixLen_ != null) hash ^= PrefixLen.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AddressPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AddressPrefix);
      }
      if (prefixLen_ != null) {
        _single_prefixLen_codec.WriteTagAndValue(output, PrefixLen);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AddressPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AddressPrefix);
      }
      if (prefixLen_ != null) {
        _single_prefixLen_codec.WriteTagAndValue(ref output, PrefixLen);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (AddressPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AddressPrefix);
      }
      if (prefixLen_ != null) {
        size += _single_prefixLen_codec.CalculateSizeWithTag(PrefixLen);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CidrRange other) {
      if (other == null) {
        return;
      }
      if (other.AddressPrefix.Length != 0) {
        AddressPrefix = other.AddressPrefix;
      }
      if (other.prefixLen_ != null) {
        if (prefixLen_ == null || other.PrefixLen != 0) {
          PrefixLen = other.PrefixLen;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            AddressPrefix = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_prefixLen_codec.Read(input);
            if (prefixLen_ == null || value != 0) {
              PrefixLen = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            AddressPrefix = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_prefixLen_codec.Read(ref input);
            if (prefixLen_ == null || value != 0) {
              PrefixLen = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
