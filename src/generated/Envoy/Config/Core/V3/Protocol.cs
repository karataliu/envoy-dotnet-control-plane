// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/core/v3/protocol.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Core.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/core/v3/protocol.proto</summary>
  public static partial class ProtocolReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/core/v3/protocol.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProtocolReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiNlbnZveS9jb25maWcvY29yZS92My9wcm90b2NvbC5wcm90bxIUZW52b3ku",
            "Y29uZmlnLmNvcmUudjMaJGVudm95L2NvbmZpZy9jb3JlL3YzL2V4dGVuc2lv",
            "bi5wcm90bxobZW52b3kvdHlwZS92My9wZXJjZW50LnByb3RvGh5nb29nbGUv",
            "cHJvdG9idWYvZHVyYXRpb24ucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFw",
            "cGVycy5wcm90bxofeGRzL2Fubm90YXRpb25zL3YzL3N0YXR1cy5wcm90bxoj",
            "ZW52b3kvYW5ub3RhdGlvbnMvZGVwcmVjYXRpb24ucHJvdG8aHXVkcGEvYW5u",
            "b3RhdGlvbnMvc3RhdHVzLnByb3RvGiF1ZHBhL2Fubm90YXRpb25zL3ZlcnNp",
            "b25pbmcucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIkEKElRjcFBy",
            "b3RvY29sT3B0aW9uczormsWIHiYKJGVudm95LmFwaS52Mi5jb3JlLlRjcFBy",
            "b3RvY29sT3B0aW9ucyKZAQoVUXVpY0tlZXBBbGl2ZVNldHRpbmdzEj0KDG1h",
            "eF9pbnRlcnZhbBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIM",
            "+kIJqgEGIgAyAggBEkEKEGluaXRpYWxfaW50ZXJ2YWwYAiABKAsyGS5nb29n",
            "bGUucHJvdG9idWYuRHVyYXRpb25CDPpCCaoBBiIAMgIIASKkAwoTUXVpY1By",
            "b3RvY29sT3B0aW9ucxJFChZtYXhfY29uY3VycmVudF9zdHJlYW1zGAEgASgL",
            "MhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgf6QgQqAigBEk4KGmlu",
            "aXRpYWxfc3RyZWFtX3dpbmRvd19zaXplGAIgASgLMhwuZ29vZ2xlLnByb3Rv",
            "YnVmLlVJbnQzMlZhbHVlQgz6QgkqBxiAgIAIKAESUgoeaW5pdGlhbF9jb25u",
            "ZWN0aW9uX3dpbmRvd19zaXplGAMgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlQgz6QgkqBxiAgIAMKAESVwombnVtX3RpbWVvdXRzX3RvX3Ry",
            "aWdnZXJfcG9ydF9taWdyYXRpb24YBCABKAsyHC5nb29nbGUucHJvdG9idWYu",
            "VUludDMyVmFsdWVCCfpCBioEGAUoABJJChRjb25uZWN0aW9uX2tlZXBhbGl2",
            "ZRgFIAEoCzIrLmVudm95LmNvbmZpZy5jb3JlLnYzLlF1aWNLZWVwQWxpdmVT",
            "ZXR0aW5ncyKxAQobVXBzdHJlYW1IdHRwUHJvdG9jb2xPcHRpb25zEhAKCGF1",
            "dG9fc25pGAEgASgIEhsKE2F1dG9fc2FuX3ZhbGlkYXRpb24YAiABKAgSLQoY",
            "b3ZlcnJpZGVfYXV0b19zbmlfaGVhZGVyGAMgASgJQgv6QghyBsABAdABATo0",
            "msWIHi8KLWVudm95LmFwaS52Mi5jb3JlLlVwc3RyZWFtSHR0cFByb3RvY29s",
            "T3B0aW9ucyKKAwoeQWx0ZXJuYXRlUHJvdG9jb2xzQ2FjaGVPcHRpb25zEhUK",
            "BG5hbWUYASABKAlCB/pCBHICEAESOgoLbWF4X2VudHJpZXMYAiABKAsyHC5n",
            "b29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCB/pCBCoCIAASSgoWa2V5X3Zh",
            "bHVlX3N0b3JlX2NvbmZpZxgDIAEoCzIqLmVudm95LmNvbmZpZy5jb3JlLnYz",
            "LlR5cGVkRXh0ZW5zaW9uQ29uZmlnEm8KFHByZXBvcHVsYXRlZF9lbnRyaWVz",
            "GAQgAygLMlEuZW52b3kuY29uZmlnLmNvcmUudjMuQWx0ZXJuYXRlUHJvdG9j",
            "b2xzQ2FjaGVPcHRpb25zLkFsdGVybmF0ZVByb3RvY29sc0NhY2hlRW50cnka",
            "WAocQWx0ZXJuYXRlUHJvdG9jb2xzQ2FjaGVFbnRyeRIdCghob3N0bmFtZRgB",
            "IAEoCUIL+kIIcgbAAQHQAQESGQoEcG9ydBgCIAEoDUIL+kIIKgYQ//8DIAAi",
            "rgQKE0h0dHBQcm90b2NvbE9wdGlvbnMSLwoMaWRsZV90aW1lb3V0GAEgASgL",
            "MhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjoKF21heF9jb25uZWN0aW9u",
            "X2R1cmF0aW9uGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkAK",
            "EW1heF9oZWFkZXJzX2NvdW50GAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlQgf6QgQqAigBEjYKE21heF9zdHJlYW1fZHVyYXRpb24YBCAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SbwofaGVhZGVyc193aXRo",
            "X3VuZGVyc2NvcmVzX2FjdGlvbhgFIAEoDjJGLmVudm95LmNvbmZpZy5jb3Jl",
            "LnYzLkh0dHBQcm90b2NvbE9wdGlvbnMuSGVhZGVyc1dpdGhVbmRlcnNjb3Jl",
            "c0FjdGlvbhJBChttYXhfcmVxdWVzdHNfcGVyX2Nvbm5lY3Rpb24YBiABKAsy",
            "HC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUiTgocSGVhZGVyc1dpdGhV",
            "bmRlcnNjb3Jlc0FjdGlvbhIJCgVBTExPVxAAEhIKDlJFSkVDVF9SRVFVRVNU",
            "EAESDwoLRFJPUF9IRUFERVIQAjosmsWIHicKJWVudm95LmFwaS52Mi5jb3Jl",
            "Lkh0dHBQcm90b2NvbE9wdGlvbnMilgYKFEh0dHAxUHJvdG9jb2xPcHRpb25z",
            "EjYKEmFsbG93X2Fic29sdXRlX3VybBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1",
            "Zi5Cb29sVmFsdWUSFgoOYWNjZXB0X2h0dHBfMTAYAiABKAgSIAoYZGVmYXVs",
            "dF9ob3N0X2Zvcl9odHRwXzEwGAMgASgJElUKEWhlYWRlcl9rZXlfZm9ybWF0",
            "GAQgASgLMjouZW52b3kuY29uZmlnLmNvcmUudjMuSHR0cDFQcm90b2NvbE9w",
            "dGlvbnMuSGVhZGVyS2V5Rm9ybWF0EhcKD2VuYWJsZV90cmFpbGVycxgFIAEo",
            "CBIcChRhbGxvd19jaHVua2VkX2xlbmd0aBgGIAEoCBJRCi1vdmVycmlkZV9z",
            "dHJlYW1fZXJyb3Jfb25faW52YWxpZF9odHRwX21lc3NhZ2UYByABKAsyGi5n",
            "b29nbGUucHJvdG9idWYuQm9vbFZhbHVlGvsCCg9IZWFkZXJLZXlGb3JtYXQS",
            "ZwoRcHJvcGVyX2Nhc2Vfd29yZHMYASABKAsySi5lbnZveS5jb25maWcuY29y",
            "ZS52My5IdHRwMVByb3RvY29sT3B0aW9ucy5IZWFkZXJLZXlGb3JtYXQuUHJv",
            "cGVyQ2FzZVdvcmRzSAASSAoSc3RhdGVmdWxfZm9ybWF0dGVyGAggASgLMiou",
            "ZW52b3kuY29uZmlnLmNvcmUudjMuVHlwZWRFeHRlbnNpb25Db25maWdIABpg",
            "Cg9Qcm9wZXJDYXNlV29yZHM6TZrFiB5ICkZlbnZveS5hcGkudjIuY29yZS5I",
            "dHRwMVByb3RvY29sT3B0aW9ucy5IZWFkZXJLZXlGb3JtYXQuUHJvcGVyQ2Fz",
            "ZVdvcmRzOj2axYgeOAo2ZW52b3kuYXBpLnYyLmNvcmUuSHR0cDFQcm90b2Nv",
            "bE9wdGlvbnMuSGVhZGVyS2V5Rm9ybWF0QhQKDWhlYWRlcl9mb3JtYXQSA/hC",
            "ATotmsWIHigKJmVudm95LmFwaS52Mi5jb3JlLkh0dHAxUHJvdG9jb2xPcHRp",
            "b25zIoYCChFLZWVwYWxpdmVTZXR0aW5ncxI5CghpbnRlcnZhbBgBIAEoCzIZ",
            "Lmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIM+kIJqgEGMgQQwIQ9EjoKB3Rp",
            "bWVvdXQYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CDvpCC6oB",
            "CAgBMgQQwIQ9Ei8KD2ludGVydmFsX2ppdHRlchgDIAEoCzIWLmVudm95LnR5",
            "cGUudjMuUGVyY2VudBJJChhjb25uZWN0aW9uX2lkbGVfaW50ZXJ2YWwYBCAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CDPpCCaoBBjIEEMCEPSLN",
            "CgoUSHR0cDJQcm90b2NvbE9wdGlvbnMSNgoQaHBhY2tfdGFibGVfc2l6ZRgB",
            "IAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZRJLChZtYXhfY29u",
            "Y3VycmVudF9zdHJlYW1zGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQz",
            "MlZhbHVlQg36QgoqCBj/////BygBElEKGmluaXRpYWxfc3RyZWFtX3dpbmRv",
            "d19zaXplGAMgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQg/6",
            "QgwqChj/////Byj//wMSVQoeaW5pdGlhbF9jb25uZWN0aW9uX3dpbmRvd19z",
            "aXplGAQgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQg/6Qgwq",
            "Chj/////Byj//wMSFQoNYWxsb3dfY29ubmVjdBgFIAEoCBIWCg5hbGxvd19t",
            "ZXRhZGF0YRgGIAEoCBJCChNtYXhfb3V0Ym91bmRfZnJhbWVzGAcgASgLMhwu",
            "Z29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgf6QgQqAigBEkoKG21heF9v",
            "dXRib3VuZF9jb250cm9sX2ZyYW1lcxgIIAEoCzIcLmdvb2dsZS5wcm90b2J1",
            "Zi5VSW50MzJWYWx1ZUIH+kIEKgIoARJXCjFtYXhfY29uc2VjdXRpdmVfaW5i",
            "b3VuZF9mcmFtZXNfd2l0aF9lbXB0eV9wYXlsb2FkGAkgASgLMhwuZ29vZ2xl",
            "LnByb3RvYnVmLlVJbnQzMlZhbHVlEkwKJm1heF9pbmJvdW5kX3ByaW9yaXR5",
            "X2ZyYW1lc19wZXJfc3RyZWFtGAogASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlEmMKNG1heF9pbmJvdW5kX3dpbmRvd191cGRhdGVfZnJhbWVz",
            "X3Blcl9kYXRhX2ZyYW1lX3NlbnQYCyABKAsyHC5nb29nbGUucHJvdG9idWYu",
            "VUludDMyVmFsdWVCB/pCBCoCKAESOwomc3RyZWFtX2Vycm9yX29uX2ludmFs",
            "aWRfaHR0cF9tZXNzYWdpbmcYDCABKAhCCxgBkseG2AQDMy4wElEKLW92ZXJy",
            "aWRlX3N0cmVhbV9lcnJvcl9vbl9pbnZhbGlkX2h0dHBfbWVzc2FnZRgOIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSYAoaY3VzdG9tX3NldHRp",
            "bmdzX3BhcmFtZXRlcnMYDSADKAsyPC5lbnZveS5jb25maWcuY29yZS52My5I",
            "dHRwMlByb3RvY29sT3B0aW9ucy5TZXR0aW5nc1BhcmFtZXRlchJFChRjb25u",
            "ZWN0aW9uX2tlZXBhbGl2ZRgPIAEoCzInLmVudm95LmNvbmZpZy5jb3JlLnYz",
            "LktlZXBhbGl2ZVNldHRpbmdzGtIBChFTZXR0aW5nc1BhcmFtZXRlchJFCgpp",
            "ZGVudGlmaWVyGAEgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVl",
            "QhP6QggqBhj//wMoAPpCBYoBAhABEjUKBXZhbHVlGAIgASgLMhwuZ29vZ2xl",
            "LnByb3RvYnVmLlVJbnQzMlZhbHVlQgj6QgWKAQIQATo/msWIHjoKOGVudm95",
            "LmFwaS52Mi5jb3JlLkh0dHAyUHJvdG9jb2xPcHRpb25zLlNldHRpbmdzUGFy",
            "YW1ldGVyOi2axYgeKAomZW52b3kuYXBpLnYyLmNvcmUuSHR0cDJQcm90b2Nv",
            "bE9wdGlvbnMijwEKE0dycGNQcm90b2NvbE9wdGlvbnMSSgoWaHR0cDJfcHJv",
            "dG9jb2xfb3B0aW9ucxgBIAEoCzIqLmVudm95LmNvbmZpZy5jb3JlLnYzLkh0",
            "dHAyUHJvdG9jb2xPcHRpb25zOiyaxYgeJwolZW52b3kuYXBpLnYyLmNvcmUu",
            "R3JwY1Byb3RvY29sT3B0aW9ucyLdAQoUSHR0cDNQcm90b2NvbE9wdGlvbnMS",
            "SAoVcXVpY19wcm90b2NvbF9vcHRpb25zGAEgASgLMikuZW52b3kuY29uZmln",
            "LmNvcmUudjMuUXVpY1Byb3RvY29sT3B0aW9ucxJRCi1vdmVycmlkZV9zdHJl",
            "YW1fZXJyb3Jfb25faW52YWxpZF9odHRwX21lc3NhZ2UYAiABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuQm9vbFZhbHVlEigKFmFsbG93X2V4dGVuZGVkX2Nvbm5l",
            "Y3QYBSABKAhCCNLGpOEGAggBImEKGlNjaGVtZUhlYWRlclRyYW5zZm9ybWF0",
            "aW9uEjEKE3NjaGVtZV90b19vdmVyd3JpdGUYASABKAlCEvpCD3INUgRodHRw",
            "UgVodHRwc0gAQhAKDnRyYW5zZm9ybWF0aW9uQoEBCiJpby5lbnZveXByb3h5",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzQg1Qcm90b2NvbFByb3RvUAFaQmdpdGh1",
            "Yi5jb20vZW52b3lwcm94eS9nby1jb250cm9sLXBsYW5lL2Vudm95L2NvbmZp",
            "Zy9jb3JlL3YzO2NvcmV2M7qAyNEGAhACYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Type.V3.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Annotations.V3.StatusReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.TcpProtocolOptions), global::Envoy.Config.Core.V3.TcpProtocolOptions.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.QuicKeepAliveSettings), global::Envoy.Config.Core.V3.QuicKeepAliveSettings.Parser, new[]{ "MaxInterval", "InitialInterval" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.QuicProtocolOptions), global::Envoy.Config.Core.V3.QuicProtocolOptions.Parser, new[]{ "MaxConcurrentStreams", "InitialStreamWindowSize", "InitialConnectionWindowSize", "NumTimeoutsToTriggerPortMigration", "ConnectionKeepalive" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions), global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions.Parser, new[]{ "AutoSni", "AutoSanValidation", "OverrideAutoSniHeader" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions), global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Parser, new[]{ "Name", "MaxEntries", "KeyValueStoreConfig", "PrepopulatedEntries" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry), global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry.Parser, new[]{ "Hostname", "Port" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.HttpProtocolOptions), global::Envoy.Config.Core.V3.HttpProtocolOptions.Parser, new[]{ "IdleTimeout", "MaxConnectionDuration", "MaxHeadersCount", "MaxStreamDuration", "HeadersWithUnderscoresAction", "MaxRequestsPerConnection" }, null, new[]{ typeof(global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http1ProtocolOptions), global::Envoy.Config.Core.V3.Http1ProtocolOptions.Parser, new[]{ "AllowAbsoluteUrl", "AcceptHttp10", "DefaultHostForHttp10", "HeaderKeyFormat", "EnableTrailers", "AllowChunkedLength", "OverrideStreamErrorOnInvalidHttpMessage" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat), global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Parser, new[]{ "ProperCaseWords", "StatefulFormatter" }, new[]{ "HeaderFormat" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords), global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords.Parser, null, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.KeepaliveSettings), global::Envoy.Config.Core.V3.KeepaliveSettings.Parser, new[]{ "Interval", "Timeout", "IntervalJitter", "ConnectionIdleInterval" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http2ProtocolOptions), global::Envoy.Config.Core.V3.Http2ProtocolOptions.Parser, new[]{ "HpackTableSize", "MaxConcurrentStreams", "InitialStreamWindowSize", "InitialConnectionWindowSize", "AllowConnect", "AllowMetadata", "MaxOutboundFrames", "MaxOutboundControlFrames", "MaxConsecutiveInboundFramesWithEmptyPayload", "MaxInboundPriorityFramesPerStream", "MaxInboundWindowUpdateFramesPerDataFrameSent", "StreamErrorOnInvalidHttpMessaging", "OverrideStreamErrorOnInvalidHttpMessage", "CustomSettingsParameters", "ConnectionKeepalive" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter), global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter.Parser, new[]{ "Identifier", "Value" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.GrpcProtocolOptions), global::Envoy.Config.Core.V3.GrpcProtocolOptions.Parser, new[]{ "Http2ProtocolOptions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.Http3ProtocolOptions), global::Envoy.Config.Core.V3.Http3ProtocolOptions.Parser, new[]{ "QuicProtocolOptions", "OverrideStreamErrorOnInvalidHttpMessage", "AllowExtendedConnect" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.SchemeHeaderTransformation), global::Envoy.Config.Core.V3.SchemeHeaderTransformation.Parser, new[]{ "SchemeToOverwrite" }, new[]{ "Transformation" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class TcpProtocolOptions : pb::IMessage<TcpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TcpProtocolOptions> _parser = new pb::MessageParser<TcpProtocolOptions>(() => new TcpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TcpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions(TcpProtocolOptions other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TcpProtocolOptions Clone() {
      return new TcpProtocolOptions(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TcpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TcpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TcpProtocolOptions other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Config for keepalive probes in a QUIC connection.
  /// Note that QUIC keep-alive probing packets work differently from HTTP/2 keep-alive PINGs in a sense that the probing packet
  /// itself doesn't timeout waiting for a probing response. Quic has a shorter idle timeout than TCP, so it doesn't rely on such probing to discover dead connections. If the peer fails to respond, the connection will idle timeout eventually. Thus, they are configured differently from :ref:`connection_keepalive &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.connection_keepalive>`.
  /// </summary>
  public sealed partial class QuicKeepAliveSettings : pb::IMessage<QuicKeepAliveSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<QuicKeepAliveSettings> _parser = new pb::MessageParser<QuicKeepAliveSettings>(() => new QuicKeepAliveSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<QuicKeepAliveSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicKeepAliveSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicKeepAliveSettings(QuicKeepAliveSettings other) : this() {
      maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
      initialInterval_ = other.initialInterval_ != null ? other.initialInterval_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicKeepAliveSettings Clone() {
      return new QuicKeepAliveSettings(this);
    }

    /// <summary>Field number for the "max_interval" field.</summary>
    public const int MaxIntervalFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
    /// <summary>
    /// The max interval for a connection to send keep-alive probing packets (with PING or PATH_RESPONSE). The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout while not less than 1s to avoid throttling the connection or flooding the peer with probes.
    ///
    /// If :ref:`initial_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.initial_interval>` is absent or zero, a client connection will use this value to start probing.
    ///
    /// If zero, disable keepalive probing.
    /// If absent, use the QUICHE default interval to probe.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
      get { return maxInterval_; }
      set {
        maxInterval_ = value;
      }
    }

    /// <summary>Field number for the "initial_interval" field.</summary>
    public const int InitialIntervalFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration initialInterval_;
    /// <summary>
    /// The interval to send the first few keep-alive probing packets to prevent connection from hitting the idle timeout. Subsequent probes will be sent, each one with an interval exponentially longer than previous one, till it reaches :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`. And the probes afterwards will always use :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`.
    ///
    /// The value should be smaller than :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` to prevent idle timeout and smaller than max_interval to take effect.
    ///
    /// If absent or zero, disable keepalive probing for a server connection. For a client connection, if :ref:`max_interval &lt;envoy_v3_api_field_config.core.v3.QuicKeepAliveSettings.max_interval>`  is also zero, do not keepalive, otherwise use max_interval or QUICHE default to probe all the time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration InitialInterval {
      get { return initialInterval_; }
      set {
        initialInterval_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as QuicKeepAliveSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(QuicKeepAliveSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
      if (!object.Equals(InitialInterval, other.InitialInterval)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
      if (initialInterval_ != null) hash ^= InitialInterval.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxInterval_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MaxInterval);
      }
      if (initialInterval_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(InitialInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxInterval_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MaxInterval);
      }
      if (initialInterval_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(InitialInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxInterval_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
      }
      if (initialInterval_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialInterval);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(QuicKeepAliveSettings other) {
      if (other == null) {
        return;
      }
      if (other.maxInterval_ != null) {
        if (maxInterval_ == null) {
          MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxInterval.MergeFrom(other.MaxInterval);
      }
      if (other.initialInterval_ != null) {
        if (initialInterval_ == null) {
          InitialInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        InitialInterval.MergeFrom(other.InitialInterval);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxInterval);
            break;
          }
          case 18: {
            if (initialInterval_ == null) {
              InitialInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialInterval);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxInterval);
            break;
          }
          case 18: {
            if (initialInterval_ == null) {
              InitialInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialInterval);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// QUIC protocol options which apply to both downstream and upstream connections.
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class QuicProtocolOptions : pb::IMessage<QuicProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<QuicProtocolOptions> _parser = new pb::MessageParser<QuicProtocolOptions>(() => new QuicProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<QuicProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicProtocolOptions(QuicProtocolOptions other) : this() {
      MaxConcurrentStreams = other.MaxConcurrentStreams;
      InitialStreamWindowSize = other.InitialStreamWindowSize;
      InitialConnectionWindowSize = other.InitialConnectionWindowSize;
      NumTimeoutsToTriggerPortMigration = other.NumTimeoutsToTriggerPortMigration;
      connectionKeepalive_ = other.connectionKeepalive_ != null ? other.connectionKeepalive_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuicProtocolOptions Clone() {
      return new QuicProtocolOptions(this);
    }

    /// <summary>Field number for the "max_concurrent_streams" field.</summary>
    public const int MaxConcurrentStreamsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxConcurrentStreams_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxConcurrentStreams_;
    /// <summary>
    /// Maximum number of streams that the client can negotiate per connection. 100
    /// if not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxConcurrentStreams {
      get { return maxConcurrentStreams_; }
      set {
        maxConcurrentStreams_ = value;
      }
    }


    /// <summary>Field number for the "initial_stream_window_size" field.</summary>
    public const int InitialStreamWindowSizeFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_initialStreamWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? initialStreamWindowSize_;
    /// <summary>
    /// `Initial stream-level flow-control receive window
    /// &lt;https://tools.ietf.org/html/draft-ietf-quic-transport-34#section-4.1>`_ size. Valid values range from
    /// 1 to 16777216 (2^24, maximum supported by QUICHE) and defaults to 65536 (2^16).
    ///
    /// NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. If configured smaller than it, we will use 16384 instead.
    /// QUICHE IETF Quic implementation supports 1 bytes window. We only support increasing the default window size now, so it's also the minimum.
    ///
    /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    /// QUIC stream send and receive buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    /// stop the flow of data to the stream buffers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialStreamWindowSize {
      get { return initialStreamWindowSize_; }
      set {
        initialStreamWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "initial_connection_window_size" field.</summary>
    public const int InitialConnectionWindowSizeFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_initialConnectionWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? initialConnectionWindowSize_;
    /// <summary>
    /// Similar to *initial_stream_window_size*, but for connection-level
    /// flow-control. Valid values rage from 1 to 25165824 (24MB, maximum supported by QUICHE) and defaults to 65536 (2^16).
    /// window. Currently, this has the same minimum/default as *initial_stream_window_size*.
    ///
    /// NOTE: 16384 (2^14) is the minimum window size supported in Google QUIC. We only support increasing the default
    /// window size now, so it's also the minimum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialConnectionWindowSize {
      get { return initialConnectionWindowSize_; }
      set {
        initialConnectionWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "num_timeouts_to_trigger_port_migration" field.</summary>
    public const int NumTimeoutsToTriggerPortMigrationFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_numTimeoutsToTriggerPortMigration_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? numTimeoutsToTriggerPortMigration_;
    /// <summary>
    /// The number of timeouts that can occur before port migration is triggered for QUIC clients.
    /// This defaults to 1. If set to 0, port migration will not occur on path degrading.
    /// Timeout here refers to QUIC internal path degrading timeout mechanism, such as PTO.
    /// This has no effect on server sessions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? NumTimeoutsToTriggerPortMigration {
      get { return numTimeoutsToTriggerPortMigration_; }
      set {
        numTimeoutsToTriggerPortMigration_ = value;
      }
    }


    /// <summary>Field number for the "connection_keepalive" field.</summary>
    public const int ConnectionKeepaliveFieldNumber = 5;
    private global::Envoy.Config.Core.V3.QuicKeepAliveSettings connectionKeepalive_;
    /// <summary>
    /// Probes the peer at the configured interval to solicit traffic, i.e. ACK or PATH_RESPONSE, from the peer to push back connection idle timeout.
    /// If absent, use the default keepalive behavior of which a client connection sends PINGs every 15s, and a server connection doesn't do anything.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.QuicKeepAliveSettings ConnectionKeepalive {
      get { return connectionKeepalive_; }
      set {
        connectionKeepalive_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as QuicProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(QuicProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxConcurrentStreams != other.MaxConcurrentStreams) return false;
      if (InitialStreamWindowSize != other.InitialStreamWindowSize) return false;
      if (InitialConnectionWindowSize != other.InitialConnectionWindowSize) return false;
      if (NumTimeoutsToTriggerPortMigration != other.NumTimeoutsToTriggerPortMigration) return false;
      if (!object.Equals(ConnectionKeepalive, other.ConnectionKeepalive)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxConcurrentStreams_ != null) hash ^= MaxConcurrentStreams.GetHashCode();
      if (initialStreamWindowSize_ != null) hash ^= InitialStreamWindowSize.GetHashCode();
      if (initialConnectionWindowSize_ != null) hash ^= InitialConnectionWindowSize.GetHashCode();
      if (numTimeoutsToTriggerPortMigration_ != null) hash ^= NumTimeoutsToTriggerPortMigration.GetHashCode();
      if (connectionKeepalive_ != null) hash ^= ConnectionKeepalive.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(output, InitialConnectionWindowSize);
      }
      if (numTimeoutsToTriggerPortMigration_ != null) {
        _single_numTimeoutsToTriggerPortMigration_codec.WriteTagAndValue(output, NumTimeoutsToTriggerPortMigration);
      }
      if (connectionKeepalive_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(ref output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(ref output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(ref output, InitialConnectionWindowSize);
      }
      if (numTimeoutsToTriggerPortMigration_ != null) {
        _single_numTimeoutsToTriggerPortMigration_codec.WriteTagAndValue(ref output, NumTimeoutsToTriggerPortMigration);
      }
      if (connectionKeepalive_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxConcurrentStreams_ != null) {
        size += _single_maxConcurrentStreams_codec.CalculateSizeWithTag(MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        size += _single_initialStreamWindowSize_codec.CalculateSizeWithTag(InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        size += _single_initialConnectionWindowSize_codec.CalculateSizeWithTag(InitialConnectionWindowSize);
      }
      if (numTimeoutsToTriggerPortMigration_ != null) {
        size += _single_numTimeoutsToTriggerPortMigration_codec.CalculateSizeWithTag(NumTimeoutsToTriggerPortMigration);
      }
      if (connectionKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(QuicProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.maxConcurrentStreams_ != null) {
        if (maxConcurrentStreams_ == null || other.MaxConcurrentStreams != 0) {
          MaxConcurrentStreams = other.MaxConcurrentStreams;
        }
      }
      if (other.initialStreamWindowSize_ != null) {
        if (initialStreamWindowSize_ == null || other.InitialStreamWindowSize != 0) {
          InitialStreamWindowSize = other.InitialStreamWindowSize;
        }
      }
      if (other.initialConnectionWindowSize_ != null) {
        if (initialConnectionWindowSize_ == null || other.InitialConnectionWindowSize != 0) {
          InitialConnectionWindowSize = other.InitialConnectionWindowSize;
        }
      }
      if (other.numTimeoutsToTriggerPortMigration_ != null) {
        if (numTimeoutsToTriggerPortMigration_ == null || other.NumTimeoutsToTriggerPortMigration != 0) {
          NumTimeoutsToTriggerPortMigration = other.NumTimeoutsToTriggerPortMigration;
        }
      }
      if (other.connectionKeepalive_ != null) {
        if (connectionKeepalive_ == null) {
          ConnectionKeepalive = new global::Envoy.Config.Core.V3.QuicKeepAliveSettings();
        }
        ConnectionKeepalive.MergeFrom(other.ConnectionKeepalive);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxConcurrentStreams_codec.Read(input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_initialStreamWindowSize_codec.Read(input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_numTimeoutsToTriggerPortMigration_codec.Read(input);
            if (numTimeoutsToTriggerPortMigration_ == null || value != 0) {
              NumTimeoutsToTriggerPortMigration = value;
            }
            break;
          }
          case 42: {
            if (connectionKeepalive_ == null) {
              ConnectionKeepalive = new global::Envoy.Config.Core.V3.QuicKeepAliveSettings();
            }
            input.ReadMessage(ConnectionKeepalive);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_maxConcurrentStreams_codec.Read(ref input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_initialStreamWindowSize_codec.Read(ref input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(ref input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_numTimeoutsToTriggerPortMigration_codec.Read(ref input);
            if (numTimeoutsToTriggerPortMigration_ == null || value != 0) {
              NumTimeoutsToTriggerPortMigration = value;
            }
            break;
          }
          case 42: {
            if (connectionKeepalive_ == null) {
              ConnectionKeepalive = new global::Envoy.Config.Core.V3.QuicKeepAliveSettings();
            }
            input.ReadMessage(ConnectionKeepalive);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UpstreamHttpProtocolOptions : pb::IMessage<UpstreamHttpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamHttpProtocolOptions> _parser = new pb::MessageParser<UpstreamHttpProtocolOptions>(() => new UpstreamHttpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamHttpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions(UpstreamHttpProtocolOptions other) : this() {
      autoSni_ = other.autoSni_;
      autoSanValidation_ = other.autoSanValidation_;
      overrideAutoSniHeader_ = other.overrideAutoSniHeader_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamHttpProtocolOptions Clone() {
      return new UpstreamHttpProtocolOptions(this);
    }

    /// <summary>Field number for the "auto_sni" field.</summary>
    public const int AutoSniFieldNumber = 1;
    private bool autoSni_;
    /// <summary>
    /// Set transport socket `SNI &lt;https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
    /// upstream connections based on the downstream HTTP host/authority header or any other arbitrary
    /// header when :ref:`override_auto_sni_header &lt;envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
    /// is set, as seen by the :ref:`router filter &lt;config_http_filters_router>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutoSni {
      get { return autoSni_; }
      set {
        autoSni_ = value;
      }
    }

    /// <summary>Field number for the "auto_san_validation" field.</summary>
    public const int AutoSanValidationFieldNumber = 2;
    private bool autoSanValidation_;
    /// <summary>
    /// Automatic validate upstream presented certificate for new upstream connections based on the
    /// downstream HTTP host/authority header or any other arbitrary header when :ref:`override_auto_sni_header &lt;envoy_v3_api_field_config.core.v3.UpstreamHttpProtocolOptions.override_auto_sni_header>`
    /// is set, as seen by the :ref:`router filter &lt;config_http_filters_router>`.
    /// This field is intended to be set with `auto_sni` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutoSanValidation {
      get { return autoSanValidation_; }
      set {
        autoSanValidation_ = value;
      }
    }

    /// <summary>Field number for the "override_auto_sni_header" field.</summary>
    public const int OverrideAutoSniHeaderFieldNumber = 3;
    private string overrideAutoSniHeader_ = "";
    /// <summary>
    /// An optional alternative to the host/authority header to be used for setting the SNI value.
    /// It should be a valid downstream HTTP header, as seen by the
    /// :ref:`router filter &lt;config_http_filters_router>`.
    /// If unset, host/authority header will be used for populating the SNI. If the specified header
    /// is not found or the value is empty, host/authority header will be used instead.
    /// This field is intended to be set with `auto_sni` and/or `auto_san_validation` fields.
    /// If none of these fields are set then setting this would be a no-op.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OverrideAutoSniHeader {
      get { return overrideAutoSniHeader_; }
      set {
        overrideAutoSniHeader_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamHttpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamHttpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AutoSni != other.AutoSni) return false;
      if (AutoSanValidation != other.AutoSanValidation) return false;
      if (OverrideAutoSniHeader != other.OverrideAutoSniHeader) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (AutoSni != false) hash ^= AutoSni.GetHashCode();
      if (AutoSanValidation != false) hash ^= AutoSanValidation.GetHashCode();
      if (OverrideAutoSniHeader.Length != 0) hash ^= OverrideAutoSniHeader.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AutoSni != false) {
        output.WriteRawTag(8);
        output.WriteBool(AutoSni);
      }
      if (AutoSanValidation != false) {
        output.WriteRawTag(16);
        output.WriteBool(AutoSanValidation);
      }
      if (OverrideAutoSniHeader.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(OverrideAutoSniHeader);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AutoSni != false) {
        output.WriteRawTag(8);
        output.WriteBool(AutoSni);
      }
      if (AutoSanValidation != false) {
        output.WriteRawTag(16);
        output.WriteBool(AutoSanValidation);
      }
      if (OverrideAutoSniHeader.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(OverrideAutoSniHeader);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (AutoSni != false) {
        size += 1 + 1;
      }
      if (AutoSanValidation != false) {
        size += 1 + 1;
      }
      if (OverrideAutoSniHeader.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OverrideAutoSniHeader);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamHttpProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.AutoSni != false) {
        AutoSni = other.AutoSni;
      }
      if (other.AutoSanValidation != false) {
        AutoSanValidation = other.AutoSanValidation;
      }
      if (other.OverrideAutoSniHeader.Length != 0) {
        OverrideAutoSniHeader = other.OverrideAutoSniHeader;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AutoSni = input.ReadBool();
            break;
          }
          case 16: {
            AutoSanValidation = input.ReadBool();
            break;
          }
          case 26: {
            OverrideAutoSniHeader = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            AutoSni = input.ReadBool();
            break;
          }
          case 16: {
            AutoSanValidation = input.ReadBool();
            break;
          }
          case 26: {
            OverrideAutoSniHeader = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configures the alternate protocols cache which tracks alternate protocols that can be used to
  /// make an HTTP connection to an origin server. See https://tools.ietf.org/html/rfc7838 for
  /// HTTP Alternative Services and https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-04
  /// for the "HTTPS" DNS resource record.
  /// </summary>
  public sealed partial class AlternateProtocolsCacheOptions : pb::IMessage<AlternateProtocolsCacheOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AlternateProtocolsCacheOptions> _parser = new pb::MessageParser<AlternateProtocolsCacheOptions>(() => new AlternateProtocolsCacheOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AlternateProtocolsCacheOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlternateProtocolsCacheOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlternateProtocolsCacheOptions(AlternateProtocolsCacheOptions other) : this() {
      name_ = other.name_;
      MaxEntries = other.MaxEntries;
      keyValueStoreConfig_ = other.keyValueStoreConfig_ != null ? other.keyValueStoreConfig_.Clone() : null;
      prepopulatedEntries_ = other.prepopulatedEntries_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AlternateProtocolsCacheOptions Clone() {
      return new AlternateProtocolsCacheOptions(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the cache. Multiple named caches allow independent alternate protocols cache
    /// configurations to operate within a single Envoy process using different configurations. All
    /// alternate protocols cache options with the same name *must* be equal in all fields when
    /// referenced from different configuration components. Configuration will fail to load if this is
    /// not the case.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_entries" field.</summary>
    public const int MaxEntriesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxEntries_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxEntries_;
    /// <summary>
    /// The maximum number of entries that the cache will hold. If not specified defaults to 1024.
    ///
    /// .. note:
    ///
    ///   The implementation is approximate and enforced independently on each worker thread, thus
    ///   it is possible for the maximum entries in the cache to go slightly above the configured
    ///   value depending on timing. This is similar to how other circuit breakers work.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxEntries {
      get { return maxEntries_; }
      set {
        maxEntries_ = value;
      }
    }


    /// <summary>Field number for the "key_value_store_config" field.</summary>
    public const int KeyValueStoreConfigFieldNumber = 3;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig keyValueStoreConfig_;
    /// <summary>
    /// Allows configuring a persistent
    /// :ref:`key value store &lt;envoy_v3_api_msg_config.common.key_value.v3.KeyValueStoreConfig>` to flush
    /// alternate protocols entries to disk.
    /// This function is currently only supported if concurrency is 1
    /// Cached entries will take precedence over pre-populated entries below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig KeyValueStoreConfig {
      get { return keyValueStoreConfig_; }
      set {
        keyValueStoreConfig_ = value;
      }
    }

    /// <summary>Field number for the "prepopulated_entries" field.</summary>
    public const int PrepopulatedEntriesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry> _repeated_prepopulatedEntries_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry> prepopulatedEntries_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry>();
    /// <summary>
    /// Allows pre-populating the cache with entries, as described above.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Types.AlternateProtocolsCacheEntry> PrepopulatedEntries {
      get { return prepopulatedEntries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AlternateProtocolsCacheOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AlternateProtocolsCacheOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (MaxEntries != other.MaxEntries) return false;
      if (!object.Equals(KeyValueStoreConfig, other.KeyValueStoreConfig)) return false;
      if(!prepopulatedEntries_.Equals(other.prepopulatedEntries_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (maxEntries_ != null) hash ^= MaxEntries.GetHashCode();
      if (keyValueStoreConfig_ != null) hash ^= KeyValueStoreConfig.GetHashCode();
      hash ^= prepopulatedEntries_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (maxEntries_ != null) {
        _single_maxEntries_codec.WriteTagAndValue(output, MaxEntries);
      }
      if (keyValueStoreConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(KeyValueStoreConfig);
      }
      prepopulatedEntries_.WriteTo(output, _repeated_prepopulatedEntries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (maxEntries_ != null) {
        _single_maxEntries_codec.WriteTagAndValue(ref output, MaxEntries);
      }
      if (keyValueStoreConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(KeyValueStoreConfig);
      }
      prepopulatedEntries_.WriteTo(ref output, _repeated_prepopulatedEntries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (maxEntries_ != null) {
        size += _single_maxEntries_codec.CalculateSizeWithTag(MaxEntries);
      }
      if (keyValueStoreConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyValueStoreConfig);
      }
      size += prepopulatedEntries_.CalculateSize(_repeated_prepopulatedEntries_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AlternateProtocolsCacheOptions other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.maxEntries_ != null) {
        if (maxEntries_ == null || other.MaxEntries != 0) {
          MaxEntries = other.MaxEntries;
        }
      }
      if (other.keyValueStoreConfig_ != null) {
        if (keyValueStoreConfig_ == null) {
          KeyValueStoreConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        KeyValueStoreConfig.MergeFrom(other.KeyValueStoreConfig);
      }
      prepopulatedEntries_.Add(other.prepopulatedEntries_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_maxEntries_codec.Read(input);
            if (maxEntries_ == null || value != 0) {
              MaxEntries = value;
            }
            break;
          }
          case 26: {
            if (keyValueStoreConfig_ == null) {
              KeyValueStoreConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(KeyValueStoreConfig);
            break;
          }
          case 34: {
            prepopulatedEntries_.AddEntriesFrom(input, _repeated_prepopulatedEntries_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_maxEntries_codec.Read(ref input);
            if (maxEntries_ == null || value != 0) {
              MaxEntries = value;
            }
            break;
          }
          case 26: {
            if (keyValueStoreConfig_ == null) {
              KeyValueStoreConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(KeyValueStoreConfig);
            break;
          }
          case 34: {
            prepopulatedEntries_.AddEntriesFrom(ref input, _repeated_prepopulatedEntries_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AlternateProtocolsCacheOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Allows pre-populating the cache with HTTP/3 alternate protocols entries with a 7 day lifetime.
      /// This will cause Envoy to attempt HTTP/3 to those upstreams, even if the upstreams have not
      /// advertised HTTP/3 support. These entries will be overwritten by alt-svc
      /// response headers or cached values.
      /// As with regular cached entries, if the origin response would result in clearing an existing
      /// alternate protocol cache entry, pre-populated entries will also be cleared.
      /// Adding a cache entry with hostname=foo.com port=123 is the equivalent of getting
      /// response headers
      /// alt-svc: h3=:"123"; ma=86400" in a response to a request to foo.com:123
      /// </summary>
      public sealed partial class AlternateProtocolsCacheEntry : pb::IMessage<AlternateProtocolsCacheEntry>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AlternateProtocolsCacheEntry> _parser = new pb::MessageParser<AlternateProtocolsCacheEntry>(() => new AlternateProtocolsCacheEntry());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<AlternateProtocolsCacheEntry> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Core.V3.AlternateProtocolsCacheOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AlternateProtocolsCacheEntry() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AlternateProtocolsCacheEntry(AlternateProtocolsCacheEntry other) : this() {
          hostname_ = other.hostname_;
          port_ = other.port_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AlternateProtocolsCacheEntry Clone() {
          return new AlternateProtocolsCacheEntry(this);
        }

        /// <summary>Field number for the "hostname" field.</summary>
        public const int HostnameFieldNumber = 1;
        private string hostname_ = "";
        /// <summary>
        /// The host name for the alternate protocol entry.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Hostname {
          get { return hostname_; }
          set {
            hostname_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "port" field.</summary>
        public const int PortFieldNumber = 2;
        private uint port_;
        /// <summary>
        /// The port for the alternate protocol entry.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint Port {
          get { return port_; }
          set {
            port_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as AlternateProtocolsCacheEntry);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(AlternateProtocolsCacheEntry other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Hostname != other.Hostname) return false;
          if (Port != other.Port) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Hostname.Length != 0) hash ^= Hostname.GetHashCode();
          if (Port != 0) hash ^= Port.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Hostname.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Hostname);
          }
          if (Port != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Port);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Hostname.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Hostname);
          }
          if (Port != 0) {
            output.WriteRawTag(16);
            output.WriteUInt32(Port);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Hostname.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Hostname);
          }
          if (Port != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Port);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(AlternateProtocolsCacheEntry other) {
          if (other == null) {
            return;
          }
          if (other.Hostname.Length != 0) {
            Hostname = other.Hostname;
          }
          if (other.Port != 0) {
            Port = other.Port;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Hostname = input.ReadString();
                break;
              }
              case 16: {
                Port = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Hostname = input.ReadString();
                break;
              }
              case 16: {
                Port = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class HttpProtocolOptions : pb::IMessage<HttpProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HttpProtocolOptions> _parser = new pb::MessageParser<HttpProtocolOptions>(() => new HttpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HttpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions(HttpProtocolOptions other) : this() {
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      maxConnectionDuration_ = other.maxConnectionDuration_ != null ? other.maxConnectionDuration_.Clone() : null;
      MaxHeadersCount = other.MaxHeadersCount;
      maxStreamDuration_ = other.maxStreamDuration_ != null ? other.maxStreamDuration_.Clone() : null;
      headersWithUnderscoresAction_ = other.headersWithUnderscoresAction_;
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HttpProtocolOptions Clone() {
      return new HttpProtocolOptions(this);
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for connections. The idle timeout is defined as the
    /// period in which there are no active requests. When the
    /// idle timeout is reached the connection will be closed. If the connection is an HTTP/2
    /// downstream connection a drain sequence will occur prior to closing the connection, see
    /// :ref:`drain_timeout
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
    /// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
    /// If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
    ///
    /// .. warning::
    ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
    ///   FIN packets, etc.
    ///
    /// If the :ref:`overload action &lt;config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
    /// is configured, this timeout is scaled for downstream connections according to the value for
    /// :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "max_connection_duration" field.</summary>
    public const int MaxConnectionDurationFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration maxConnectionDuration_;
    /// <summary>
    /// The maximum duration of a connection. The duration is defined as a period since a connection
    /// was established. If not set, there is no max duration. When max_connection_duration is reached
    /// and if there are no active streams, the connection will be closed. If the connection is a
    /// downstream connection and there are any active streams, the drain sequence will kick-in,
    /// and the connection will be force-closed after the drain period. See :ref:`drain_timeout
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxConnectionDuration {
      get { return maxConnectionDuration_; }
      set {
        maxConnectionDuration_ = value;
      }
    }

    /// <summary>Field number for the "max_headers_count" field.</summary>
    public const int MaxHeadersCountFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxHeadersCount_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxHeadersCount_;
    /// <summary>
    /// The maximum number of headers. If unconfigured, the default
    /// maximum number of request headers allowed is 100. Requests that exceed this limit will receive
    /// a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxHeadersCount {
      get { return maxHeadersCount_; }
      set {
        maxHeadersCount_ = value;
      }
    }


    /// <summary>Field number for the "max_stream_duration" field.</summary>
    public const int MaxStreamDurationFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration maxStreamDuration_;
    /// <summary>
    /// Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
    /// reset independent of any other timeouts. If not specified, this value is not set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxStreamDuration {
      get { return maxStreamDuration_; }
      set {
        maxStreamDuration_ = value;
      }
    }

    /// <summary>Field number for the "headers_with_underscores_action" field.</summary>
    public const int HeadersWithUnderscoresActionFieldNumber = 5;
    private global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction headersWithUnderscoresAction_ = global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow;
    /// <summary>
    /// Action to take when a client request with a header name containing underscore characters is received.
    /// If this setting is not specified, the value defaults to ALLOW.
    /// Note: upstream responses are not affected by this setting.
    /// Note: this only affects client headers. It does not affect headers added
    /// by Envoy filters and does not have any impact if added to cluster config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction HeadersWithUnderscoresAction {
      get { return headersWithUnderscoresAction_; }
      set {
        headersWithUnderscoresAction_ = value;
      }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 6;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(50);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for both upstream and downstream connections.
    /// If not specified, there is no limit.
    /// Setting this parameter to 1 will effectively disable keep alive.
    /// For HTTP/2 and HTTP/3, due to concurrent stream processing, the limit is approximate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HttpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HttpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(MaxConnectionDuration, other.MaxConnectionDuration)) return false;
      if (MaxHeadersCount != other.MaxHeadersCount) return false;
      if (!object.Equals(MaxStreamDuration, other.MaxStreamDuration)) return false;
      if (HeadersWithUnderscoresAction != other.HeadersWithUnderscoresAction) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (maxConnectionDuration_ != null) hash ^= MaxConnectionDuration.GetHashCode();
      if (maxHeadersCount_ != null) hash ^= MaxHeadersCount.GetHashCode();
      if (maxStreamDuration_ != null) hash ^= MaxStreamDuration.GetHashCode();
      if (HeadersWithUnderscoresAction != global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) hash ^= HeadersWithUnderscoresAction.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (idleTimeout_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(IdleTimeout);
      }
      if (maxHeadersCount_ != null) {
        _single_maxHeadersCount_codec.WriteTagAndValue(output, MaxHeadersCount);
      }
      if (maxConnectionDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MaxConnectionDuration);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HeadersWithUnderscoresAction);
      }
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (idleTimeout_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(IdleTimeout);
      }
      if (maxHeadersCount_ != null) {
        _single_maxHeadersCount_codec.WriteTagAndValue(ref output, MaxHeadersCount);
      }
      if (maxConnectionDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(MaxConnectionDuration);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        output.WriteRawTag(40);
        output.WriteEnum((int) HeadersWithUnderscoresAction);
      }
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(ref output, MaxRequestsPerConnection);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (maxConnectionDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxConnectionDuration);
      }
      if (maxHeadersCount_ != null) {
        size += _single_maxHeadersCount_codec.CalculateSizeWithTag(MaxHeadersCount);
      }
      if (maxStreamDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxStreamDuration);
      }
      if (HeadersWithUnderscoresAction != global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HeadersWithUnderscoresAction);
      }
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HttpProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.maxConnectionDuration_ != null) {
        if (maxConnectionDuration_ == null) {
          MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxConnectionDuration.MergeFrom(other.MaxConnectionDuration);
      }
      if (other.maxHeadersCount_ != null) {
        if (maxHeadersCount_ == null || other.MaxHeadersCount != 0) {
          MaxHeadersCount = other.MaxHeadersCount;
        }
      }
      if (other.maxStreamDuration_ != null) {
        if (maxStreamDuration_ == null) {
          MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxStreamDuration.MergeFrom(other.MaxStreamDuration);
      }
      if (other.HeadersWithUnderscoresAction != global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction.Allow) {
        HeadersWithUnderscoresAction = other.HeadersWithUnderscoresAction;
      }
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 18: {
            uint? value = _single_maxHeadersCount_codec.Read(input);
            if (maxHeadersCount_ == null || value != 0) {
              MaxHeadersCount = value;
            }
            break;
          }
          case 26: {
            if (maxConnectionDuration_ == null) {
              MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxConnectionDuration);
            break;
          }
          case 34: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 40: {
            HeadersWithUnderscoresAction = (global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) input.ReadEnum();
            break;
          }
          case 50: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 18: {
            uint? value = _single_maxHeadersCount_codec.Read(ref input);
            if (maxHeadersCount_ == null || value != 0) {
              MaxHeadersCount = value;
            }
            break;
          }
          case 26: {
            if (maxConnectionDuration_ == null) {
              MaxConnectionDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxConnectionDuration);
            break;
          }
          case 34: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 40: {
            HeadersWithUnderscoresAction = (global::Envoy.Config.Core.V3.HttpProtocolOptions.Types.HeadersWithUnderscoresAction) input.ReadEnum();
            break;
          }
          case 50: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(ref input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the HttpProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Action to take when Envoy receives client request with header names containing underscore
      /// characters.
      /// Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
      /// as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
      /// characters.
      /// </summary>
      public enum HeadersWithUnderscoresAction {
        /// <summary>
        /// Allow headers with underscores. This is the default behavior.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
        /// end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
        /// is incremented for each rejected request.
        /// </summary>
        [pbr::OriginalName("REJECT_REQUEST")] RejectRequest = 1,
        /// <summary>
        /// Drop the client header with name containing underscores. The header is dropped before the filter chain is
        /// invoked and as such filters will not see dropped headers. The
        /// "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
        /// </summary>
        [pbr::OriginalName("DROP_HEADER")] DropHeader = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// [#next-free-field: 8]
  /// </summary>
  public sealed partial class Http1ProtocolOptions : pb::IMessage<Http1ProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Http1ProtocolOptions> _parser = new pb::MessageParser<Http1ProtocolOptions>(() => new Http1ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Http1ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions(Http1ProtocolOptions other) : this() {
      AllowAbsoluteUrl = other.AllowAbsoluteUrl;
      acceptHttp10_ = other.acceptHttp10_;
      defaultHostForHttp10_ = other.defaultHostForHttp10_;
      headerKeyFormat_ = other.headerKeyFormat_ != null ? other.headerKeyFormat_.Clone() : null;
      enableTrailers_ = other.enableTrailers_;
      allowChunkedLength_ = other.allowChunkedLength_;
      OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http1ProtocolOptions Clone() {
      return new Http1ProtocolOptions(this);
    }

    /// <summary>Field number for the "allow_absolute_url" field.</summary>
    public const int AllowAbsoluteUrlFieldNumber = 1;
    private static readonly pb::FieldCodec<bool?> _single_allowAbsoluteUrl_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
    private bool? allowAbsoluteUrl_;
    /// <summary>
    /// Handle HTTP requests with absolute URLs in the requests. These requests
    /// are generally sent by clients to forward/explicit proxies. This allows clients to configure
    /// envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
    /// *http_proxy* environment variable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AllowAbsoluteUrl {
      get { return allowAbsoluteUrl_; }
      set {
        allowAbsoluteUrl_ = value;
      }
    }


    /// <summary>Field number for the "accept_http_10" field.</summary>
    public const int AcceptHttp10FieldNumber = 2;
    private bool acceptHttp10_;
    /// <summary>
    /// Handle incoming HTTP/1.0 and HTTP 0.9 requests.
    /// This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
    /// style connect logic, dechunking, and handling lack of client host iff
    /// *default_host_for_http_10* is configured.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AcceptHttp10 {
      get { return acceptHttp10_; }
      set {
        acceptHttp10_ = value;
      }
    }

    /// <summary>Field number for the "default_host_for_http_10" field.</summary>
    public const int DefaultHostForHttp10FieldNumber = 3;
    private string defaultHostForHttp10_ = "";
    /// <summary>
    /// A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
    /// Envoy does not otherwise support HTTP/1.0 without a Host header.
    /// This is a no-op if *accept_http_10* is not true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DefaultHostForHttp10 {
      get { return defaultHostForHttp10_; }
      set {
        defaultHostForHttp10_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "header_key_format" field.</summary>
    public const int HeaderKeyFormatFieldNumber = 4;
    private global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat headerKeyFormat_;
    /// <summary>
    /// Describes how the keys for response headers should be formatted. By default, all header keys
    /// are lower cased.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat HeaderKeyFormat {
      get { return headerKeyFormat_; }
      set {
        headerKeyFormat_ = value;
      }
    }

    /// <summary>Field number for the "enable_trailers" field.</summary>
    public const int EnableTrailersFieldNumber = 5;
    private bool enableTrailers_;
    /// <summary>
    /// Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
    ///
    /// .. attention::
    ///
    ///   Note that this only happens when Envoy is chunk encoding which occurs when:
    ///   - The request is HTTP/1.1.
    ///   - Is neither a HEAD only request nor a HTTP Upgrade.
    ///   - Not a response to a HEAD request.
    ///   - The content length header is not present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableTrailers {
      get { return enableTrailers_; }
      set {
        enableTrailers_ = value;
      }
    }

    /// <summary>Field number for the "allow_chunked_length" field.</summary>
    public const int AllowChunkedLengthFieldNumber = 6;
    private bool allowChunkedLength_;
    /// <summary>
    /// Allows Envoy to process requests/responses with both `Content-Length` and `Transfer-Encoding`
    /// headers set. By default such messages are rejected, but if option is enabled - Envoy will
    /// remove Content-Length header and process message.
    /// See `RFC7230, sec. 3.3.3 &lt;https://tools.ietf.org/html/rfc7230#section-3.3.3>`_ for details.
    ///
    /// .. attention::
    ///   Enabling this option might lead to request smuggling vulnerability, especially if traffic
    ///   is proxied via multiple layers of proxies.
    /// [#comment:TODO: This field is ignored when the
    /// :ref:`header validation configuration &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
    /// is present.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowChunkedLength {
      get { return allowChunkedLength_; }
      set {
        allowChunkedLength_ = value;
      }
    }

    /// <summary>Field number for the "override_stream_error_on_invalid_http_message" field.</summary>
    public const int OverrideStreamErrorOnInvalidHttpMessageFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _single_overrideStreamErrorOnInvalidHttpMessage_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    private bool? overrideStreamErrorOnInvalidHttpMessage_;
    /// <summary>
    /// Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
    /// HTTP/1.1 connections upon receiving an invalid HTTP message. However,
    /// when this option is true, then Envoy will leave the HTTP/1.1 connection
    /// open where possible.
    /// If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? OverrideStreamErrorOnInvalidHttpMessage {
      get { return overrideStreamErrorOnInvalidHttpMessage_; }
      set {
        overrideStreamErrorOnInvalidHttpMessage_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Http1ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Http1ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AllowAbsoluteUrl != other.AllowAbsoluteUrl) return false;
      if (AcceptHttp10 != other.AcceptHttp10) return false;
      if (DefaultHostForHttp10 != other.DefaultHostForHttp10) return false;
      if (!object.Equals(HeaderKeyFormat, other.HeaderKeyFormat)) return false;
      if (EnableTrailers != other.EnableTrailers) return false;
      if (AllowChunkedLength != other.AllowChunkedLength) return false;
      if (OverrideStreamErrorOnInvalidHttpMessage != other.OverrideStreamErrorOnInvalidHttpMessage) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (allowAbsoluteUrl_ != null) hash ^= AllowAbsoluteUrl.GetHashCode();
      if (AcceptHttp10 != false) hash ^= AcceptHttp10.GetHashCode();
      if (DefaultHostForHttp10.Length != 0) hash ^= DefaultHostForHttp10.GetHashCode();
      if (headerKeyFormat_ != null) hash ^= HeaderKeyFormat.GetHashCode();
      if (EnableTrailers != false) hash ^= EnableTrailers.GetHashCode();
      if (AllowChunkedLength != false) hash ^= AllowChunkedLength.GetHashCode();
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) hash ^= OverrideStreamErrorOnInvalidHttpMessage.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (allowAbsoluteUrl_ != null) {
        _single_allowAbsoluteUrl_codec.WriteTagAndValue(output, AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        output.WriteRawTag(16);
        output.WriteBool(AcceptHttp10);
      }
      if (DefaultHostForHttp10.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableTrailers);
      }
      if (AllowChunkedLength != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowChunkedLength);
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (allowAbsoluteUrl_ != null) {
        _single_allowAbsoluteUrl_codec.WriteTagAndValue(ref output, AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        output.WriteRawTag(16);
        output.WriteBool(AcceptHttp10);
      }
      if (DefaultHostForHttp10.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        output.WriteRawTag(40);
        output.WriteBool(EnableTrailers);
      }
      if (AllowChunkedLength != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowChunkedLength);
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(ref output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (allowAbsoluteUrl_ != null) {
        size += _single_allowAbsoluteUrl_codec.CalculateSizeWithTag(AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        size += 1 + 1;
      }
      if (DefaultHostForHttp10.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultHostForHttp10);
      }
      if (headerKeyFormat_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderKeyFormat);
      }
      if (EnableTrailers != false) {
        size += 1 + 1;
      }
      if (AllowChunkedLength != false) {
        size += 1 + 1;
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        size += _single_overrideStreamErrorOnInvalidHttpMessage_codec.CalculateSizeWithTag(OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Http1ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.allowAbsoluteUrl_ != null) {
        if (allowAbsoluteUrl_ == null || other.AllowAbsoluteUrl != false) {
          AllowAbsoluteUrl = other.AllowAbsoluteUrl;
        }
      }
      if (other.AcceptHttp10 != false) {
        AcceptHttp10 = other.AcceptHttp10;
      }
      if (other.DefaultHostForHttp10.Length != 0) {
        DefaultHostForHttp10 = other.DefaultHostForHttp10;
      }
      if (other.headerKeyFormat_ != null) {
        if (headerKeyFormat_ == null) {
          HeaderKeyFormat = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat();
        }
        HeaderKeyFormat.MergeFrom(other.HeaderKeyFormat);
      }
      if (other.EnableTrailers != false) {
        EnableTrailers = other.EnableTrailers;
      }
      if (other.AllowChunkedLength != false) {
        AllowChunkedLength = other.AllowChunkedLength;
      }
      if (other.overrideStreamErrorOnInvalidHttpMessage_ != null) {
        if (overrideStreamErrorOnInvalidHttpMessage_ == null || other.OverrideStreamErrorOnInvalidHttpMessage != false) {
          OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            bool? value = _single_allowAbsoluteUrl_codec.Read(input);
            if (allowAbsoluteUrl_ == null || value != false) {
              AllowAbsoluteUrl = value;
            }
            break;
          }
          case 16: {
            AcceptHttp10 = input.ReadBool();
            break;
          }
          case 26: {
            DefaultHostForHttp10 = input.ReadString();
            break;
          }
          case 34: {
            if (headerKeyFormat_ == null) {
              HeaderKeyFormat = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat();
            }
            input.ReadMessage(HeaderKeyFormat);
            break;
          }
          case 40: {
            EnableTrailers = input.ReadBool();
            break;
          }
          case 48: {
            AllowChunkedLength = input.ReadBool();
            break;
          }
          case 58: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            bool? value = _single_allowAbsoluteUrl_codec.Read(ref input);
            if (allowAbsoluteUrl_ == null || value != false) {
              AllowAbsoluteUrl = value;
            }
            break;
          }
          case 16: {
            AcceptHttp10 = input.ReadBool();
            break;
          }
          case 26: {
            DefaultHostForHttp10 = input.ReadString();
            break;
          }
          case 34: {
            if (headerKeyFormat_ == null) {
              HeaderKeyFormat = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat();
            }
            input.ReadMessage(HeaderKeyFormat);
            break;
          }
          case 40: {
            EnableTrailers = input.ReadBool();
            break;
          }
          case 48: {
            AllowChunkedLength = input.ReadBool();
            break;
          }
          case 58: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(ref input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Http1ProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// [#next-free-field: 9]
      /// </summary>
      public sealed partial class HeaderKeyFormat : pb::IMessage<HeaderKeyFormat>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HeaderKeyFormat> _parser = new pb::MessageParser<HeaderKeyFormat>(() => new HeaderKeyFormat());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HeaderKeyFormat> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Core.V3.Http1ProtocolOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat(HeaderKeyFormat other) : this() {
          switch (other.HeaderFormatCase) {
            case HeaderFormatOneofCase.ProperCaseWords:
              ProperCaseWords = other.ProperCaseWords.Clone();
              break;
            case HeaderFormatOneofCase.StatefulFormatter:
              StatefulFormatter = other.StatefulFormatter.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderKeyFormat Clone() {
          return new HeaderKeyFormat(this);
        }

        /// <summary>Field number for the "proper_case_words" field.</summary>
        public const int ProperCaseWordsFieldNumber = 1;
        /// <summary>
        /// Formats the header by proper casing words: the first character and any character following
        /// a special character will be capitalized if it's an alpha character. For example,
        /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
        /// Note that while this results in most headers following conventional casing, certain headers
        /// are not covered. For example, the "TE" header will be formatted as "Te".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords ProperCaseWords {
          get { return headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords ? (global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords) headerFormat_ : null; }
          set {
            headerFormat_ = value;
            headerFormatCase_ = value == null ? HeaderFormatOneofCase.None : HeaderFormatOneofCase.ProperCaseWords;
          }
        }

        /// <summary>Field number for the "stateful_formatter" field.</summary>
        public const int StatefulFormatterFieldNumber = 8;
        /// <summary>
        /// Configuration for stateful formatter extensions that allow using received headers to
        /// affect the output of encoding headers. E.g., preserving case during proxying.
        /// [#extension-category: envoy.http.stateful_header_formatters]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.TypedExtensionConfig StatefulFormatter {
          get { return headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter ? (global::Envoy.Config.Core.V3.TypedExtensionConfig) headerFormat_ : null; }
          set {
            headerFormat_ = value;
            headerFormatCase_ = value == null ? HeaderFormatOneofCase.None : HeaderFormatOneofCase.StatefulFormatter;
          }
        }

        private object headerFormat_;
        /// <summary>Enum of possible cases for the "header_format" oneof.</summary>
        public enum HeaderFormatOneofCase {
          None = 0,
          ProperCaseWords = 1,
          StatefulFormatter = 8,
        }
        private HeaderFormatOneofCase headerFormatCase_ = HeaderFormatOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HeaderFormatOneofCase HeaderFormatCase {
          get { return headerFormatCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHeaderFormat() {
          headerFormatCase_ = HeaderFormatOneofCase.None;
          headerFormat_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HeaderKeyFormat);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HeaderKeyFormat other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ProperCaseWords, other.ProperCaseWords)) return false;
          if (!object.Equals(StatefulFormatter, other.StatefulFormatter)) return false;
          if (HeaderFormatCase != other.HeaderFormatCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) hash ^= ProperCaseWords.GetHashCode();
          if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) hash ^= StatefulFormatter.GetHashCode();
          hash ^= (int) headerFormatCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            output.WriteRawTag(10);
            output.WriteMessage(ProperCaseWords);
          }
          if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) {
            output.WriteRawTag(66);
            output.WriteMessage(StatefulFormatter);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            output.WriteRawTag(10);
            output.WriteMessage(ProperCaseWords);
          }
          if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) {
            output.WriteRawTag(66);
            output.WriteMessage(StatefulFormatter);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProperCaseWords);
          }
          if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StatefulFormatter);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HeaderKeyFormat other) {
          if (other == null) {
            return;
          }
          switch (other.HeaderFormatCase) {
            case HeaderFormatOneofCase.ProperCaseWords:
              if (ProperCaseWords == null) {
                ProperCaseWords = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
              }
              ProperCaseWords.MergeFrom(other.ProperCaseWords);
              break;
            case HeaderFormatOneofCase.StatefulFormatter:
              if (StatefulFormatter == null) {
                StatefulFormatter = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
              }
              StatefulFormatter.MergeFrom(other.StatefulFormatter);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords subBuilder = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
                if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
                  subBuilder.MergeFrom(ProperCaseWords);
                }
                input.ReadMessage(subBuilder);
                ProperCaseWords = subBuilder;
                break;
              }
              case 66: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) {
                  subBuilder.MergeFrom(StatefulFormatter);
                }
                input.ReadMessage(subBuilder);
                StatefulFormatter = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords subBuilder = new global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Types.ProperCaseWords();
                if (headerFormatCase_ == HeaderFormatOneofCase.ProperCaseWords) {
                  subBuilder.MergeFrom(ProperCaseWords);
                }
                input.ReadMessage(subBuilder);
                ProperCaseWords = subBuilder;
                break;
              }
              case 66: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (headerFormatCase_ == HeaderFormatOneofCase.StatefulFormatter) {
                  subBuilder.MergeFrom(StatefulFormatter);
                }
                input.ReadMessage(subBuilder);
                StatefulFormatter = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the HeaderKeyFormat message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public sealed partial class ProperCaseWords : pb::IMessage<ProperCaseWords>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ProperCaseWords> _parser = new pb::MessageParser<ProperCaseWords>(() => new ProperCaseWords());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ProperCaseWords> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Core.V3.Http1ProtocolOptions.Types.HeaderKeyFormat.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords(ProperCaseWords other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ProperCaseWords Clone() {
              return new ProperCaseWords(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ProperCaseWords);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ProperCaseWords other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ProperCaseWords other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class KeepaliveSettings : pb::IMessage<KeepaliveSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeepaliveSettings> _parser = new pb::MessageParser<KeepaliveSettings>(() => new KeepaliveSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeepaliveSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeepaliveSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeepaliveSettings(KeepaliveSettings other) : this() {
      interval_ = other.interval_ != null ? other.interval_.Clone() : null;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      intervalJitter_ = other.intervalJitter_ != null ? other.intervalJitter_.Clone() : null;
      connectionIdleInterval_ = other.connectionIdleInterval_ != null ? other.connectionIdleInterval_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeepaliveSettings Clone() {
      return new KeepaliveSettings(this);
    }

    /// <summary>Field number for the "interval" field.</summary>
    public const int IntervalFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration interval_;
    /// <summary>
    /// Send HTTP/2 PING frames at this period, in order to test that the connection is still alive.
    /// If this is zero, interval PINGs will not be sent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Interval {
      get { return interval_; }
      set {
        interval_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// How long to wait for a response to a keepalive PING. If a response is not received within this
    /// time period, the connection will be aborted. Note that in order to prevent the influence of
    /// Head-of-line (HOL) blocking the timeout period is extended when *any* frame is received on
    /// the connection, under the assumption that if a frame is received the connection is healthy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "interval_jitter" field.</summary>
    public const int IntervalJitterFieldNumber = 3;
    private global::Envoy.Type.V3.Percent intervalJitter_;
    /// <summary>
    /// A random jitter amount as a percentage of interval that will be added to each interval.
    /// A value of zero means there will be no jitter.
    /// The default value is 15%.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.Percent IntervalJitter {
      get { return intervalJitter_; }
      set {
        intervalJitter_ = value;
      }
    }

    /// <summary>Field number for the "connection_idle_interval" field.</summary>
    public const int ConnectionIdleIntervalFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectionIdleInterval_;
    /// <summary>
    /// If the connection has been idle for this duration, send a HTTP/2 ping ahead
    /// of new stream creation, to quickly detect dead connections.
    /// If this is zero, this type of PING will not be sent.
    /// If an interval ping is outstanding, a second ping will not be sent as the
    /// interval ping will determine if the connection is dead.
    ///
    /// The same feature for HTTP/3 is given by inheritance from QUICHE which uses :ref:`connection idle_timeout &lt;envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.idle_timeout>` and the current PTO of the connection to decide whether to probe before sending a new request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectionIdleInterval {
      get { return connectionIdleInterval_; }
      set {
        connectionIdleInterval_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeepaliveSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeepaliveSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Interval, other.Interval)) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (!object.Equals(IntervalJitter, other.IntervalJitter)) return false;
      if (!object.Equals(ConnectionIdleInterval, other.ConnectionIdleInterval)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (interval_ != null) hash ^= Interval.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (intervalJitter_ != null) hash ^= IntervalJitter.GetHashCode();
      if (connectionIdleInterval_ != null) hash ^= ConnectionIdleInterval.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (interval_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Interval);
      }
      if (timeout_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timeout);
      }
      if (intervalJitter_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IntervalJitter);
      }
      if (connectionIdleInterval_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectionIdleInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (interval_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Interval);
      }
      if (timeout_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timeout);
      }
      if (intervalJitter_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IntervalJitter);
      }
      if (connectionIdleInterval_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectionIdleInterval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (interval_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Interval);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (intervalJitter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IntervalJitter);
      }
      if (connectionIdleInterval_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionIdleInterval);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeepaliveSettings other) {
      if (other == null) {
        return;
      }
      if (other.interval_ != null) {
        if (interval_ == null) {
          Interval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Interval.MergeFrom(other.Interval);
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.intervalJitter_ != null) {
        if (intervalJitter_ == null) {
          IntervalJitter = new global::Envoy.Type.V3.Percent();
        }
        IntervalJitter.MergeFrom(other.IntervalJitter);
      }
      if (other.connectionIdleInterval_ != null) {
        if (connectionIdleInterval_ == null) {
          ConnectionIdleInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectionIdleInterval.MergeFrom(other.ConnectionIdleInterval);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (interval_ == null) {
              Interval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Interval);
            break;
          }
          case 18: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 26: {
            if (intervalJitter_ == null) {
              IntervalJitter = new global::Envoy.Type.V3.Percent();
            }
            input.ReadMessage(IntervalJitter);
            break;
          }
          case 34: {
            if (connectionIdleInterval_ == null) {
              ConnectionIdleInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectionIdleInterval);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (interval_ == null) {
              Interval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Interval);
            break;
          }
          case 18: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 26: {
            if (intervalJitter_ == null) {
              IntervalJitter = new global::Envoy.Type.V3.Percent();
            }
            input.ReadMessage(IntervalJitter);
            break;
          }
          case 34: {
            if (connectionIdleInterval_ == null) {
              ConnectionIdleInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectionIdleInterval);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 16]
  /// </summary>
  public sealed partial class Http2ProtocolOptions : pb::IMessage<Http2ProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Http2ProtocolOptions> _parser = new pb::MessageParser<Http2ProtocolOptions>(() => new Http2ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Http2ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions(Http2ProtocolOptions other) : this() {
      HpackTableSize = other.HpackTableSize;
      MaxConcurrentStreams = other.MaxConcurrentStreams;
      InitialStreamWindowSize = other.InitialStreamWindowSize;
      InitialConnectionWindowSize = other.InitialConnectionWindowSize;
      allowConnect_ = other.allowConnect_;
      allowMetadata_ = other.allowMetadata_;
      MaxOutboundFrames = other.MaxOutboundFrames;
      MaxOutboundControlFrames = other.MaxOutboundControlFrames;
      MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
      MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
      MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
      streamErrorOnInvalidHttpMessaging_ = other.streamErrorOnInvalidHttpMessaging_;
      OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
      customSettingsParameters_ = other.customSettingsParameters_.Clone();
      connectionKeepalive_ = other.connectionKeepalive_ != null ? other.connectionKeepalive_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http2ProtocolOptions Clone() {
      return new Http2ProtocolOptions(this);
    }

    /// <summary>Field number for the "hpack_table_size" field.</summary>
    public const int HpackTableSizeFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_hpackTableSize_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? hpackTableSize_;
    /// <summary>
    /// `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
    /// (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
    /// range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
    /// compression.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? HpackTableSize {
      get { return hpackTableSize_; }
      set {
        hpackTableSize_ = value;
      }
    }


    /// <summary>Field number for the "max_concurrent_streams" field.</summary>
    public const int MaxConcurrentStreamsFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxConcurrentStreams_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxConcurrentStreams_;
    /// <summary>
    /// `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
    /// allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
    /// and defaults to 2147483647.
    ///
    /// For upstream connections, this also limits how many streams Envoy will initiate concurrently
    /// on a single connection. If the limit is reached, Envoy may queue requests or establish
    /// additional connections (as allowed per circuit breaker limits).
    ///
    /// This acts as an upper bound: Envoy will lower the max concurrent streams allowed on a given
    /// connection based on upstream settings. Config dumps will reflect the configured upper bound,
    /// not the per-connection negotiated limits.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxConcurrentStreams {
      get { return maxConcurrentStreams_; }
      set {
        maxConcurrentStreams_ = value;
      }
    }


    /// <summary>Field number for the "initial_stream_window_size" field.</summary>
    public const int InitialStreamWindowSizeFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_initialStreamWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? initialStreamWindowSize_;
    /// <summary>
    /// `Initial stream-level flow-control window
    /// &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
    /// (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
    /// (256 * 1024 * 1024).
    ///
    /// NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
    /// window size now, so it's also the minimum.
    ///
    /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    /// HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    /// stop the flow of data to the codec buffers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialStreamWindowSize {
      get { return initialStreamWindowSize_; }
      set {
        initialStreamWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "initial_connection_window_size" field.</summary>
    public const int InitialConnectionWindowSizeFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_initialConnectionWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? initialConnectionWindowSize_;
    /// <summary>
    /// Similar to *initial_stream_window_size*, but for connection-level flow-control
    /// window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialConnectionWindowSize {
      get { return initialConnectionWindowSize_; }
      set {
        initialConnectionWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "allow_connect" field.</summary>
    public const int AllowConnectFieldNumber = 5;
    private bool allowConnect_;
    /// <summary>
    /// Allows proxying Websocket and other upgrades over H2 connect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowConnect {
      get { return allowConnect_; }
      set {
        allowConnect_ = value;
      }
    }

    /// <summary>Field number for the "allow_metadata" field.</summary>
    public const int AllowMetadataFieldNumber = 6;
    private bool allowMetadata_;
    /// <summary>
    /// [#not-implemented-hide:] Hiding until envoy has full metadata support.
    /// Still under implementation. DO NOT USE.
    ///
    /// Allows metadata. See [metadata
    /// docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowMetadata {
      get { return allowMetadata_; }
      set {
        allowMetadata_ = value;
      }
    }

    /// <summary>Field number for the "max_outbound_frames" field.</summary>
    public const int MaxOutboundFramesFieldNumber = 7;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(58);
    private uint? maxOutboundFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of all types (frames that are waiting to
    /// be written into the socket). Exceeding this limit triggers flood mitigation and connection is
    /// terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
    /// to flood mitigation. The default limit is 10000.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxOutboundFrames {
      get { return maxOutboundFrames_; }
      set {
        maxOutboundFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_outbound_control_frames" field.</summary>
    public const int MaxOutboundControlFramesFieldNumber = 8;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundControlFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(66);
    private uint? maxOutboundControlFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
    /// preventing high memory utilization when receiving continuous stream of these frames. Exceeding
    /// this limit triggers flood mitigation and connection is terminated. The
    /// ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
    /// mitigation. The default limit is 1000.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxOutboundControlFrames {
      get { return maxOutboundControlFrames_; }
      set {
        maxOutboundControlFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_consecutive_inbound_frames_with_empty_payload" field.</summary>
    public const int MaxConsecutiveInboundFramesWithEmptyPayloadFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxConsecutiveInboundFramesWithEmptyPayload_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxConsecutiveInboundFramesWithEmptyPayload_;
    /// <summary>
    /// Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
    /// empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
    /// might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
    /// stat tracks the number of connections terminated due to flood mitigation.
    /// Setting this to 0 will terminate connection upon receiving first frame with an empty payload
    /// and no end stream flag. The default limit is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxConsecutiveInboundFramesWithEmptyPayload {
      get { return maxConsecutiveInboundFramesWithEmptyPayload_; }
      set {
        maxConsecutiveInboundFramesWithEmptyPayload_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_priority_frames_per_stream" field.</summary>
    public const int MaxInboundPriorityFramesPerStreamFieldNumber = 10;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundPriorityFramesPerStream_codec = pb::FieldCodec.ForStructWrapper<uint>(82);
    private uint? maxInboundPriorityFramesPerStream_;
    /// <summary>
    /// Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
    /// of PRIORITY frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///   max_inbound_priority_frames_per_stream * (1 + opened_streams)
    ///
    /// the connection is terminated. For downstream connections the `opened_streams` is incremented when
    /// Envoy receives complete response headers from the upstream server. For upstream connection the
    /// `opened_streams` is incremented when Envoy send the HEADERS frame for a new stream. The
    /// ``http2.inbound_priority_frames_flood`` stat tracks
    /// the number of connections terminated due to flood mitigation. The default limit is 100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInboundPriorityFramesPerStream {
      get { return maxInboundPriorityFramesPerStream_; }
      set {
        maxInboundPriorityFramesPerStream_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_window_update_frames_per_data_frame_sent" field.</summary>
    public const int MaxInboundWindowUpdateFramesPerDataFrameSentFieldNumber = 11;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec = pb::FieldCodec.ForStructWrapper<uint>(90);
    private uint? maxInboundWindowUpdateFramesPerDataFrameSent_;
    /// <summary>
    /// Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
    /// of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///   5 + 2 * (opened_streams +
    ///            max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
    ///
    /// the connection is terminated. For downstream connections the `opened_streams` is incremented when
    /// Envoy receives complete response headers from the upstream server. For upstream connections the
    /// `opened_streams` is incremented when Envoy sends the HEADERS frame for a new stream. The
    /// ``http2.inbound_priority_frames_flood`` stat tracks the number of connections terminated due to
    /// flood mitigation. The default max_inbound_window_update_frames_per_data_frame_sent value is 10.
    /// Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
    /// but more complex implementations that try to estimate available bandwidth require at least 2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInboundWindowUpdateFramesPerDataFrameSent {
      get { return maxInboundWindowUpdateFramesPerDataFrameSent_; }
      set {
        maxInboundWindowUpdateFramesPerDataFrameSent_ = value;
      }
    }


    /// <summary>Field number for the "stream_error_on_invalid_http_messaging" field.</summary>
    public const int StreamErrorOnInvalidHttpMessagingFieldNumber = 12;
    private bool streamErrorOnInvalidHttpMessaging_;
    /// <summary>
    /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    /// when this option is enabled, only the offending stream is terminated.
    ///
    /// This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    /// iff present.
    ///
    /// This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
    /// &lt;envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
    ///
    /// See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StreamErrorOnInvalidHttpMessaging {
      get { return streamErrorOnInvalidHttpMessaging_; }
      set {
        streamErrorOnInvalidHttpMessaging_ = value;
      }
    }

    /// <summary>Field number for the "override_stream_error_on_invalid_http_message" field.</summary>
    public const int OverrideStreamErrorOnInvalidHttpMessageFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_overrideStreamErrorOnInvalidHttpMessage_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? overrideStreamErrorOnInvalidHttpMessage_;
    /// <summary>
    /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    /// when this option is enabled, only the offending stream is terminated.
    ///
    /// This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
    ///
    /// See `RFC7540, sec. 8.1 &lt;https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? OverrideStreamErrorOnInvalidHttpMessage {
      get { return overrideStreamErrorOnInvalidHttpMessage_; }
      set {
        overrideStreamErrorOnInvalidHttpMessage_ = value;
      }
    }


    /// <summary>Field number for the "custom_settings_parameters" field.</summary>
    public const int CustomSettingsParametersFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter> _repeated_customSettingsParameters_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter> customSettingsParameters_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter>();
    /// <summary>
    /// [#not-implemented-hide:]
    /// Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
    ///
    /// 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
    /// Envoy.
    ///
    /// 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
    /// 'allow_connect'.
    ///
    /// Note that custom parameters specified through this field can not also be set in the
    /// corresponding named parameters:
    ///
    /// .. code-block:: text
    ///
    ///   ID    Field Name
    ///   ----------------
    ///   0x1   hpack_table_size
    ///   0x3   max_concurrent_streams
    ///   0x4   initial_stream_window_size
    ///
    /// Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
    /// between custom parameters with the same identifier will trigger a failure.
    ///
    /// See `IANA HTTP/2 Settings
    /// &lt;https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
    /// standardized identifiers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.Http2ProtocolOptions.Types.SettingsParameter> CustomSettingsParameters {
      get { return customSettingsParameters_; }
    }

    /// <summary>Field number for the "connection_keepalive" field.</summary>
    public const int ConnectionKeepaliveFieldNumber = 15;
    private global::Envoy.Config.Core.V3.KeepaliveSettings connectionKeepalive_;
    /// <summary>
    /// Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
    /// does not respond within the configured timeout, the connection will be aborted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.KeepaliveSettings ConnectionKeepalive {
      get { return connectionKeepalive_; }
      set {
        connectionKeepalive_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Http2ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Http2ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HpackTableSize != other.HpackTableSize) return false;
      if (MaxConcurrentStreams != other.MaxConcurrentStreams) return false;
      if (InitialStreamWindowSize != other.InitialStreamWindowSize) return false;
      if (InitialConnectionWindowSize != other.InitialConnectionWindowSize) return false;
      if (AllowConnect != other.AllowConnect) return false;
      if (AllowMetadata != other.AllowMetadata) return false;
      if (MaxOutboundFrames != other.MaxOutboundFrames) return false;
      if (MaxOutboundControlFrames != other.MaxOutboundControlFrames) return false;
      if (MaxConsecutiveInboundFramesWithEmptyPayload != other.MaxConsecutiveInboundFramesWithEmptyPayload) return false;
      if (MaxInboundPriorityFramesPerStream != other.MaxInboundPriorityFramesPerStream) return false;
      if (MaxInboundWindowUpdateFramesPerDataFrameSent != other.MaxInboundWindowUpdateFramesPerDataFrameSent) return false;
      if (StreamErrorOnInvalidHttpMessaging != other.StreamErrorOnInvalidHttpMessaging) return false;
      if (OverrideStreamErrorOnInvalidHttpMessage != other.OverrideStreamErrorOnInvalidHttpMessage) return false;
      if(!customSettingsParameters_.Equals(other.customSettingsParameters_)) return false;
      if (!object.Equals(ConnectionKeepalive, other.ConnectionKeepalive)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (hpackTableSize_ != null) hash ^= HpackTableSize.GetHashCode();
      if (maxConcurrentStreams_ != null) hash ^= MaxConcurrentStreams.GetHashCode();
      if (initialStreamWindowSize_ != null) hash ^= InitialStreamWindowSize.GetHashCode();
      if (initialConnectionWindowSize_ != null) hash ^= InitialConnectionWindowSize.GetHashCode();
      if (AllowConnect != false) hash ^= AllowConnect.GetHashCode();
      if (AllowMetadata != false) hash ^= AllowMetadata.GetHashCode();
      if (maxOutboundFrames_ != null) hash ^= MaxOutboundFrames.GetHashCode();
      if (maxOutboundControlFrames_ != null) hash ^= MaxOutboundControlFrames.GetHashCode();
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) hash ^= MaxConsecutiveInboundFramesWithEmptyPayload.GetHashCode();
      if (maxInboundPriorityFramesPerStream_ != null) hash ^= MaxInboundPriorityFramesPerStream.GetHashCode();
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) hash ^= MaxInboundWindowUpdateFramesPerDataFrameSent.GetHashCode();
      if (StreamErrorOnInvalidHttpMessaging != false) hash ^= StreamErrorOnInvalidHttpMessaging.GetHashCode();
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) hash ^= OverrideStreamErrorOnInvalidHttpMessage.GetHashCode();
      hash ^= customSettingsParameters_.GetHashCode();
      if (connectionKeepalive_ != null) hash ^= ConnectionKeepalive.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (hpackTableSize_ != null) {
        _single_hpackTableSize_codec.WriteTagAndValue(output, HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(output, InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowConnect);
      }
      if (AllowMetadata != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowMetadata);
      }
      if (maxOutboundFrames_ != null) {
        _single_maxOutboundFrames_codec.WriteTagAndValue(output, MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        _single_maxOutboundControlFrames_codec.WriteTagAndValue(output, MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.WriteTagAndValue(output, MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        _single_maxInboundPriorityFramesPerStream_codec.WriteTagAndValue(output, MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.WriteTagAndValue(output, MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        output.WriteRawTag(96);
        output.WriteBool(StreamErrorOnInvalidHttpMessaging);
      }
      customSettingsParameters_.WriteTo(output, _repeated_customSettingsParameters_codec);
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (connectionKeepalive_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (hpackTableSize_ != null) {
        _single_hpackTableSize_codec.WriteTagAndValue(ref output, HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(ref output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(ref output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(ref output, InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowConnect);
      }
      if (AllowMetadata != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowMetadata);
      }
      if (maxOutboundFrames_ != null) {
        _single_maxOutboundFrames_codec.WriteTagAndValue(ref output, MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        _single_maxOutboundControlFrames_codec.WriteTagAndValue(ref output, MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.WriteTagAndValue(ref output, MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        _single_maxInboundPriorityFramesPerStream_codec.WriteTagAndValue(ref output, MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.WriteTagAndValue(ref output, MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        output.WriteRawTag(96);
        output.WriteBool(StreamErrorOnInvalidHttpMessaging);
      }
      customSettingsParameters_.WriteTo(ref output, _repeated_customSettingsParameters_codec);
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(ref output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (connectionKeepalive_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (hpackTableSize_ != null) {
        size += _single_hpackTableSize_codec.CalculateSizeWithTag(HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        size += _single_maxConcurrentStreams_codec.CalculateSizeWithTag(MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        size += _single_initialStreamWindowSize_codec.CalculateSizeWithTag(InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        size += _single_initialConnectionWindowSize_codec.CalculateSizeWithTag(InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        size += 1 + 1;
      }
      if (AllowMetadata != false) {
        size += 1 + 1;
      }
      if (maxOutboundFrames_ != null) {
        size += _single_maxOutboundFrames_codec.CalculateSizeWithTag(MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        size += _single_maxOutboundControlFrames_codec.CalculateSizeWithTag(MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        size += _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.CalculateSizeWithTag(MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        size += _single_maxInboundPriorityFramesPerStream_codec.CalculateSizeWithTag(MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        size += _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.CalculateSizeWithTag(MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        size += 1 + 1;
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        size += _single_overrideStreamErrorOnInvalidHttpMessage_codec.CalculateSizeWithTag(OverrideStreamErrorOnInvalidHttpMessage);
      }
      size += customSettingsParameters_.CalculateSize(_repeated_customSettingsParameters_codec);
      if (connectionKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionKeepalive);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Http2ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.hpackTableSize_ != null) {
        if (hpackTableSize_ == null || other.HpackTableSize != 0) {
          HpackTableSize = other.HpackTableSize;
        }
      }
      if (other.maxConcurrentStreams_ != null) {
        if (maxConcurrentStreams_ == null || other.MaxConcurrentStreams != 0) {
          MaxConcurrentStreams = other.MaxConcurrentStreams;
        }
      }
      if (other.initialStreamWindowSize_ != null) {
        if (initialStreamWindowSize_ == null || other.InitialStreamWindowSize != 0) {
          InitialStreamWindowSize = other.InitialStreamWindowSize;
        }
      }
      if (other.initialConnectionWindowSize_ != null) {
        if (initialConnectionWindowSize_ == null || other.InitialConnectionWindowSize != 0) {
          InitialConnectionWindowSize = other.InitialConnectionWindowSize;
        }
      }
      if (other.AllowConnect != false) {
        AllowConnect = other.AllowConnect;
      }
      if (other.AllowMetadata != false) {
        AllowMetadata = other.AllowMetadata;
      }
      if (other.maxOutboundFrames_ != null) {
        if (maxOutboundFrames_ == null || other.MaxOutboundFrames != 0) {
          MaxOutboundFrames = other.MaxOutboundFrames;
        }
      }
      if (other.maxOutboundControlFrames_ != null) {
        if (maxOutboundControlFrames_ == null || other.MaxOutboundControlFrames != 0) {
          MaxOutboundControlFrames = other.MaxOutboundControlFrames;
        }
      }
      if (other.maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || other.MaxConsecutiveInboundFramesWithEmptyPayload != 0) {
          MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
        }
      }
      if (other.maxInboundPriorityFramesPerStream_ != null) {
        if (maxInboundPriorityFramesPerStream_ == null || other.MaxInboundPriorityFramesPerStream != 0) {
          MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
        }
      }
      if (other.maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || other.MaxInboundWindowUpdateFramesPerDataFrameSent != 0) {
          MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
        }
      }
      if (other.StreamErrorOnInvalidHttpMessaging != false) {
        StreamErrorOnInvalidHttpMessaging = other.StreamErrorOnInvalidHttpMessaging;
      }
      if (other.overrideStreamErrorOnInvalidHttpMessage_ != null) {
        if (overrideStreamErrorOnInvalidHttpMessage_ == null || other.OverrideStreamErrorOnInvalidHttpMessage != false) {
          OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
        }
      }
      customSettingsParameters_.Add(other.customSettingsParameters_);
      if (other.connectionKeepalive_ != null) {
        if (connectionKeepalive_ == null) {
          ConnectionKeepalive = new global::Envoy.Config.Core.V3.KeepaliveSettings();
        }
        ConnectionKeepalive.MergeFrom(other.ConnectionKeepalive);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_hpackTableSize_codec.Read(input);
            if (hpackTableSize_ == null || value != 0) {
              HpackTableSize = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_maxConcurrentStreams_codec.Read(input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialStreamWindowSize_codec.Read(input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 40: {
            AllowConnect = input.ReadBool();
            break;
          }
          case 48: {
            AllowMetadata = input.ReadBool();
            break;
          }
          case 58: {
            uint? value = _single_maxOutboundFrames_codec.Read(input);
            if (maxOutboundFrames_ == null || value != 0) {
              MaxOutboundFrames = value;
            }
            break;
          }
          case 66: {
            uint? value = _single_maxOutboundControlFrames_codec.Read(input);
            if (maxOutboundControlFrames_ == null || value != 0) {
              MaxOutboundControlFrames = value;
            }
            break;
          }
          case 74: {
            uint? value = _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.Read(input);
            if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || value != 0) {
              MaxConsecutiveInboundFramesWithEmptyPayload = value;
            }
            break;
          }
          case 82: {
            uint? value = _single_maxInboundPriorityFramesPerStream_codec.Read(input);
            if (maxInboundPriorityFramesPerStream_ == null || value != 0) {
              MaxInboundPriorityFramesPerStream = value;
            }
            break;
          }
          case 90: {
            uint? value = _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.Read(input);
            if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || value != 0) {
              MaxInboundWindowUpdateFramesPerDataFrameSent = value;
            }
            break;
          }
          case 96: {
            StreamErrorOnInvalidHttpMessaging = input.ReadBool();
            break;
          }
          case 106: {
            customSettingsParameters_.AddEntriesFrom(input, _repeated_customSettingsParameters_codec);
            break;
          }
          case 114: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 122: {
            if (connectionKeepalive_ == null) {
              ConnectionKeepalive = new global::Envoy.Config.Core.V3.KeepaliveSettings();
            }
            input.ReadMessage(ConnectionKeepalive);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_hpackTableSize_codec.Read(ref input);
            if (hpackTableSize_ == null || value != 0) {
              HpackTableSize = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_maxConcurrentStreams_codec.Read(ref input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialStreamWindowSize_codec.Read(ref input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(ref input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 40: {
            AllowConnect = input.ReadBool();
            break;
          }
          case 48: {
            AllowMetadata = input.ReadBool();
            break;
          }
          case 58: {
            uint? value = _single_maxOutboundFrames_codec.Read(ref input);
            if (maxOutboundFrames_ == null || value != 0) {
              MaxOutboundFrames = value;
            }
            break;
          }
          case 66: {
            uint? value = _single_maxOutboundControlFrames_codec.Read(ref input);
            if (maxOutboundControlFrames_ == null || value != 0) {
              MaxOutboundControlFrames = value;
            }
            break;
          }
          case 74: {
            uint? value = _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.Read(ref input);
            if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || value != 0) {
              MaxConsecutiveInboundFramesWithEmptyPayload = value;
            }
            break;
          }
          case 82: {
            uint? value = _single_maxInboundPriorityFramesPerStream_codec.Read(ref input);
            if (maxInboundPriorityFramesPerStream_ == null || value != 0) {
              MaxInboundPriorityFramesPerStream = value;
            }
            break;
          }
          case 90: {
            uint? value = _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.Read(ref input);
            if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || value != 0) {
              MaxInboundWindowUpdateFramesPerDataFrameSent = value;
            }
            break;
          }
          case 96: {
            StreamErrorOnInvalidHttpMessaging = input.ReadBool();
            break;
          }
          case 106: {
            customSettingsParameters_.AddEntriesFrom(ref input, _repeated_customSettingsParameters_codec);
            break;
          }
          case 114: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(ref input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 122: {
            if (connectionKeepalive_ == null) {
              ConnectionKeepalive = new global::Envoy.Config.Core.V3.KeepaliveSettings();
            }
            input.ReadMessage(ConnectionKeepalive);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Http2ProtocolOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Defines a parameter to be sent in the SETTINGS frame.
      /// See `RFC7540, sec. 6.5.1 &lt;https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
      /// </summary>
      public sealed partial class SettingsParameter : pb::IMessage<SettingsParameter>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SettingsParameter> _parser = new pb::MessageParser<SettingsParameter>(() => new SettingsParameter());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SettingsParameter> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Core.V3.Http2ProtocolOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter(SettingsParameter other) : this() {
          Identifier = other.Identifier;
          Value = other.Value;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SettingsParameter Clone() {
          return new SettingsParameter(this);
        }

        /// <summary>Field number for the "identifier" field.</summary>
        public const int IdentifierFieldNumber = 1;
        private static readonly pb::FieldCodec<uint?> _single_identifier_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
        private uint? identifier_;
        /// <summary>
        /// The 16 bit parameter identifier.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? Identifier {
          get { return identifier_; }
          set {
            identifier_ = value;
          }
        }


        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_value_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? value_;
        /// <summary>
        /// The 32 bit parameter value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SettingsParameter);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SettingsParameter other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Identifier != other.Identifier) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (identifier_ != null) hash ^= Identifier.GetHashCode();
          if (value_ != null) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (identifier_ != null) {
            _single_identifier_codec.WriteTagAndValue(output, Identifier);
          }
          if (value_ != null) {
            _single_value_codec.WriteTagAndValue(output, Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (identifier_ != null) {
            _single_identifier_codec.WriteTagAndValue(ref output, Identifier);
          }
          if (value_ != null) {
            _single_value_codec.WriteTagAndValue(ref output, Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (identifier_ != null) {
            size += _single_identifier_codec.CalculateSizeWithTag(Identifier);
          }
          if (value_ != null) {
            size += _single_value_codec.CalculateSizeWithTag(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SettingsParameter other) {
          if (other == null) {
            return;
          }
          if (other.identifier_ != null) {
            if (identifier_ == null || other.Identifier != 0) {
              Identifier = other.Identifier;
            }
          }
          if (other.value_ != null) {
            if (value_ == null || other.Value != 0) {
              Value = other.Value;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                uint? value = _single_identifier_codec.Read(input);
                if (identifier_ == null || value != 0) {
                  Identifier = value;
                }
                break;
              }
              case 18: {
                uint? value = _single_value_codec.Read(input);
                if (value_ == null || value != 0) {
                  Value = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                uint? value = _single_identifier_codec.Read(ref input);
                if (identifier_ == null || value != 0) {
                  Identifier = value;
                }
                break;
              }
              case 18: {
                uint? value = _single_value_codec.Read(ref input);
                if (value_ == null || value != 0) {
                  Value = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class GrpcProtocolOptions : pb::IMessage<GrpcProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GrpcProtocolOptions> _parser = new pb::MessageParser<GrpcProtocolOptions>(() => new GrpcProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GrpcProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions(GrpcProtocolOptions other) : this() {
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GrpcProtocolOptions Clone() {
      return new GrpcProtocolOptions(this);
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 1;
    private global::Envoy.Config.Core.V3.Http2ProtocolOptions http2ProtocolOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GrpcProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GrpcProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GrpcProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A message which allows using HTTP/3.
  /// [#next-free-field: 6]
  /// </summary>
  public sealed partial class Http3ProtocolOptions : pb::IMessage<Http3ProtocolOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Http3ProtocolOptions> _parser = new pb::MessageParser<Http3ProtocolOptions>(() => new Http3ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Http3ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http3ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http3ProtocolOptions(Http3ProtocolOptions other) : this() {
      quicProtocolOptions_ = other.quicProtocolOptions_ != null ? other.quicProtocolOptions_.Clone() : null;
      OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
      allowExtendedConnect_ = other.allowExtendedConnect_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Http3ProtocolOptions Clone() {
      return new Http3ProtocolOptions(this);
    }

    /// <summary>Field number for the "quic_protocol_options" field.</summary>
    public const int QuicProtocolOptionsFieldNumber = 1;
    private global::Envoy.Config.Core.V3.QuicProtocolOptions quicProtocolOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.QuicProtocolOptions QuicProtocolOptions {
      get { return quicProtocolOptions_; }
      set {
        quicProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "override_stream_error_on_invalid_http_message" field.</summary>
    public const int OverrideStreamErrorOnInvalidHttpMessageFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_overrideStreamErrorOnInvalidHttpMessage_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? overrideStreamErrorOnInvalidHttpMessage_;
    /// <summary>
    /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    /// the whole HTTP/3 connection is terminated upon receiving invalid HEADERS frame. However,
    /// when this option is enabled, only the offending stream is terminated.
    ///
    /// If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? OverrideStreamErrorOnInvalidHttpMessage {
      get { return overrideStreamErrorOnInvalidHttpMessage_; }
      set {
        overrideStreamErrorOnInvalidHttpMessage_ = value;
      }
    }


    /// <summary>Field number for the "allow_extended_connect" field.</summary>
    public const int AllowExtendedConnectFieldNumber = 5;
    private bool allowExtendedConnect_;
    /// <summary>
    /// Allows proxying Websocket and other upgrades over HTTP/3 CONNECT using
    /// the header mechanisms from the `HTTP/2 extended connect RFC
    /// &lt;https://datatracker.ietf.org/doc/html/rfc8441>`_
    /// and settings `proposed for HTTP/3
    /// &lt;https://datatracker.ietf.org/doc/draft-ietf-httpbis-h3-websockets/>`_
    /// Note that HTTP/3 CONNECT is not yet an RFC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowExtendedConnect {
      get { return allowExtendedConnect_; }
      set {
        allowExtendedConnect_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Http3ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Http3ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(QuicProtocolOptions, other.QuicProtocolOptions)) return false;
      if (OverrideStreamErrorOnInvalidHttpMessage != other.OverrideStreamErrorOnInvalidHttpMessage) return false;
      if (AllowExtendedConnect != other.AllowExtendedConnect) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (quicProtocolOptions_ != null) hash ^= QuicProtocolOptions.GetHashCode();
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) hash ^= OverrideStreamErrorOnInvalidHttpMessage.GetHashCode();
      if (AllowExtendedConnect != false) hash ^= AllowExtendedConnect.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (quicProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(QuicProtocolOptions);
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (AllowExtendedConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowExtendedConnect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (quicProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(QuicProtocolOptions);
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        _single_overrideStreamErrorOnInvalidHttpMessage_codec.WriteTagAndValue(ref output, OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (AllowExtendedConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowExtendedConnect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (quicProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(QuicProtocolOptions);
      }
      if (overrideStreamErrorOnInvalidHttpMessage_ != null) {
        size += _single_overrideStreamErrorOnInvalidHttpMessage_codec.CalculateSizeWithTag(OverrideStreamErrorOnInvalidHttpMessage);
      }
      if (AllowExtendedConnect != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Http3ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.quicProtocolOptions_ != null) {
        if (quicProtocolOptions_ == null) {
          QuicProtocolOptions = new global::Envoy.Config.Core.V3.QuicProtocolOptions();
        }
        QuicProtocolOptions.MergeFrom(other.QuicProtocolOptions);
      }
      if (other.overrideStreamErrorOnInvalidHttpMessage_ != null) {
        if (overrideStreamErrorOnInvalidHttpMessage_ == null || other.OverrideStreamErrorOnInvalidHttpMessage != false) {
          OverrideStreamErrorOnInvalidHttpMessage = other.OverrideStreamErrorOnInvalidHttpMessage;
        }
      }
      if (other.AllowExtendedConnect != false) {
        AllowExtendedConnect = other.AllowExtendedConnect;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (quicProtocolOptions_ == null) {
              QuicProtocolOptions = new global::Envoy.Config.Core.V3.QuicProtocolOptions();
            }
            input.ReadMessage(QuicProtocolOptions);
            break;
          }
          case 18: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 40: {
            AllowExtendedConnect = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (quicProtocolOptions_ == null) {
              QuicProtocolOptions = new global::Envoy.Config.Core.V3.QuicProtocolOptions();
            }
            input.ReadMessage(QuicProtocolOptions);
            break;
          }
          case 18: {
            bool? value = _single_overrideStreamErrorOnInvalidHttpMessage_codec.Read(ref input);
            if (overrideStreamErrorOnInvalidHttpMessage_ == null || value != false) {
              OverrideStreamErrorOnInvalidHttpMessage = value;
            }
            break;
          }
          case 40: {
            AllowExtendedConnect = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A message to control transformations to the :scheme header
  /// </summary>
  public sealed partial class SchemeHeaderTransformation : pb::IMessage<SchemeHeaderTransformation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SchemeHeaderTransformation> _parser = new pb::MessageParser<SchemeHeaderTransformation>(() => new SchemeHeaderTransformation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SchemeHeaderTransformation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchemeHeaderTransformation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchemeHeaderTransformation(SchemeHeaderTransformation other) : this() {
      switch (other.TransformationCase) {
        case TransformationOneofCase.SchemeToOverwrite:
          SchemeToOverwrite = other.SchemeToOverwrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchemeHeaderTransformation Clone() {
      return new SchemeHeaderTransformation(this);
    }

    /// <summary>Field number for the "scheme_to_overwrite" field.</summary>
    public const int SchemeToOverwriteFieldNumber = 1;
    /// <summary>
    /// Overwrite any Scheme header with the contents of this string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SchemeToOverwrite {
      get { return transformationCase_ == TransformationOneofCase.SchemeToOverwrite ? (string) transformation_ : ""; }
      set {
        transformation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        transformationCase_ = TransformationOneofCase.SchemeToOverwrite;
      }
    }

    private object transformation_;
    /// <summary>Enum of possible cases for the "transformation" oneof.</summary>
    public enum TransformationOneofCase {
      None = 0,
      SchemeToOverwrite = 1,
    }
    private TransformationOneofCase transformationCase_ = TransformationOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransformationOneofCase TransformationCase {
      get { return transformationCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTransformation() {
      transformationCase_ = TransformationOneofCase.None;
      transformation_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SchemeHeaderTransformation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SchemeHeaderTransformation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SchemeToOverwrite != other.SchemeToOverwrite) return false;
      if (TransformationCase != other.TransformationCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (transformationCase_ == TransformationOneofCase.SchemeToOverwrite) hash ^= SchemeToOverwrite.GetHashCode();
      hash ^= (int) transformationCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (transformationCase_ == TransformationOneofCase.SchemeToOverwrite) {
        output.WriteRawTag(10);
        output.WriteString(SchemeToOverwrite);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (transformationCase_ == TransformationOneofCase.SchemeToOverwrite) {
        output.WriteRawTag(10);
        output.WriteString(SchemeToOverwrite);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (transformationCase_ == TransformationOneofCase.SchemeToOverwrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemeToOverwrite);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SchemeHeaderTransformation other) {
      if (other == null) {
        return;
      }
      switch (other.TransformationCase) {
        case TransformationOneofCase.SchemeToOverwrite:
          SchemeToOverwrite = other.SchemeToOverwrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SchemeToOverwrite = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SchemeToOverwrite = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
