// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/core/v3/config_source.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Core.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/core/v3/config_source.proto</summary>
  public static partial class ConfigSourceReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/core/v3/config_source.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigSourceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CihlbnZveS9jb25maWcvY29yZS92My9jb25maWdfc291cmNlLnByb3RvEhRl",
            "bnZveS5jb25maWcuY29yZS52MxofZW52b3kvY29uZmlnL2NvcmUvdjMvYmFz",
            "ZS5wcm90bxokZW52b3kvY29uZmlnL2NvcmUvdjMvZXh0ZW5zaW9uLnByb3Rv",
            "GidlbnZveS9jb25maWcvY29yZS92My9ncnBjX3NlcnZpY2UucHJvdG8aGWdv",
            "b2dsZS9wcm90b2J1Zi9hbnkucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi9kdXJh",
            "dGlvbi5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGht4",
            "ZHMvY29yZS92My9hdXRob3JpdHkucHJvdG8aI2Vudm95L2Fubm90YXRpb25z",
            "L2RlcHJlY2F0aW9uLnByb3RvGh11ZHBhL2Fubm90YXRpb25zL3N0YXR1cy5w",
            "cm90bxohdWRwYS9hbm5vdGF0aW9ucy92ZXJzaW9uaW5nLnByb3RvGhd2YWxp",
            "ZGF0ZS92YWxpZGF0ZS5wcm90byLcBQoPQXBpQ29uZmlnU291cmNlEkkKCGFw",
            "aV90eXBlGAEgASgOMi0uZW52b3kuY29uZmlnLmNvcmUudjMuQXBpQ29uZmln",
            "U291cmNlLkFwaVR5cGVCCPpCBYIBAhABEkkKFXRyYW5zcG9ydF9hcGlfdmVy",
            "c2lvbhgIIAEoDjIgLmVudm95LmNvbmZpZy5jb3JlLnYzLkFwaVZlcnNpb25C",
            "CPpCBYIBAhABEhUKDWNsdXN0ZXJfbmFtZXMYAiADKAkSOAoNZ3JwY19zZXJ2",
            "aWNlcxgEIAMoCzIhLmVudm95LmNvbmZpZy5jb3JlLnYzLkdycGNTZXJ2aWNl",
            "EjAKDXJlZnJlc2hfZGVsYXkYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVy",
            "YXRpb24SPAoPcmVxdWVzdF90aW1lb3V0GAUgASgLMhkuZ29vZ2xlLnByb3Rv",
            "YnVmLkR1cmF0aW9uQgj6QgWqAQIqABJEChNyYXRlX2xpbWl0X3NldHRpbmdz",
            "GAYgASgLMicuZW52b3kuY29uZmlnLmNvcmUudjMuUmF0ZUxpbWl0U2V0dGlu",
            "Z3MSJgoec2V0X25vZGVfb25fZmlyc3RfbWVzc2FnZV9vbmx5GAcgASgIEkUK",
            "EWNvbmZpZ192YWxpZGF0b3JzGAkgAygLMiouZW52b3kuY29uZmlnLmNvcmUu",
            "djMuVHlwZWRFeHRlbnNpb25Db25maWcikgEKB0FwaVR5cGUSMwolREVQUkVD",
            "QVRFRF9BTkRfVU5BVkFJTEFCTEVfRE9fTk9UX1VTRRAAGggIAaj3tIsCARII",
            "CgRSRVNUEAESCAoER1JQQxACEg4KCkRFTFRBX0dSUEMQAxITCg9BR0dSRUdB",
            "VEVEX0dSUEMQBRIZChVBR0dSRUdBVEVEX0RFTFRBX0dSUEMQBjoomsWIHiMK",
            "IWVudm95LmFwaS52Mi5jb3JlLkFwaUNvbmZpZ1NvdXJjZSJJChZBZ2dyZWdh",
            "dGVkQ29uZmlnU291cmNlOi+axYgeKgooZW52b3kuYXBpLnYyLmNvcmUuQWdn",
            "cmVnYXRlZENvbmZpZ1NvdXJjZSKIAQoQU2VsZkNvbmZpZ1NvdXJjZRJJChV0",
            "cmFuc3BvcnRfYXBpX3ZlcnNpb24YASABKA4yIC5lbnZveS5jb25maWcuY29y",
            "ZS52My5BcGlWZXJzaW9uQgj6QgWCAQIQATopmsWIHiQKImVudm95LmFwaS52",
            "Mi5jb3JlLlNlbGZDb25maWdTb3VyY2UisgEKEVJhdGVMaW1pdFNldHRpbmdz",
            "EjAKCm1heF90b2tlbnMYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMy",
            "VmFsdWUSPwoJZmlsbF9yYXRlGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRv",
            "dWJsZVZhbHVlQg76QgsSCSEAAAAAAAAAADoqmsWIHiUKI2Vudm95LmFwaS52",
            "Mi5jb3JlLlJhdGVMaW1pdFNldHRpbmdzImwKEFBhdGhDb25maWdTb3VyY2US",
            "FQoEcGF0aBgBIAEoCUIH+kIEcgIQARJBChF3YXRjaGVkX2RpcmVjdG9yeRgC",
            "IAEoCzImLmVudm95LmNvbmZpZy5jb3JlLnYzLldhdGNoZWREaXJlY3Rvcnki",
            "ogQKDENvbmZpZ1NvdXJjZRIrCgthdXRob3JpdGllcxgHIAMoCzIWLnhkcy5j",
            "b3JlLnYzLkF1dGhvcml0eRIbCgRwYXRoGAEgASgJQgsYAZLHhtgEAzMuMEgA",
            "EkQKEnBhdGhfY29uZmlnX3NvdXJjZRgIIAEoCzImLmVudm95LmNvbmZpZy5j",
            "b3JlLnYzLlBhdGhDb25maWdTb3VyY2VIABJCChFhcGlfY29uZmlnX3NvdXJj",
            "ZRgCIAEoCzIlLmVudm95LmNvbmZpZy5jb3JlLnYzLkFwaUNvbmZpZ1NvdXJj",
            "ZUgAEjsKA2FkcxgDIAEoCzIsLmVudm95LmNvbmZpZy5jb3JlLnYzLkFnZ3Jl",
            "Z2F0ZWRDb25maWdTb3VyY2VIABI2CgRzZWxmGAUgASgLMiYuZW52b3kuY29u",
            "ZmlnLmNvcmUudjMuU2VsZkNvbmZpZ1NvdXJjZUgAEjgKFWluaXRpYWxfZmV0",
            "Y2hfdGltZW91dBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJI",
            "ChRyZXNvdXJjZV9hcGlfdmVyc2lvbhgGIAEoDjIgLmVudm95LmNvbmZpZy5j",
            "b3JlLnYzLkFwaVZlcnNpb25CCPpCBYIBAhABOiWaxYgeIAoeZW52b3kuYXBp",
            "LnYyLmNvcmUuQ29uZmlnU291cmNlQh4KF2NvbmZpZ19zb3VyY2Vfc3BlY2lm",
            "aWVyEgP4QgEi1QEKFUV4dGVuc2lvbkNvbmZpZ1NvdXJjZRJDCg1jb25maWdf",
            "c291cmNlGAEgASgLMiIuZW52b3kuY29uZmlnLmNvcmUudjMuQ29uZmlnU291",
            "cmNlQgj6QgWiAQIIARIsCg5kZWZhdWx0X2NvbmZpZxgCIAEoCzIULmdvb2ds",
            "ZS5wcm90b2J1Zi5BbnkSLAokYXBwbHlfZGVmYXVsdF9jb25maWdfd2l0aG91",
            "dF93YXJtaW5nGAMgASgIEhsKCXR5cGVfdXJscxgEIAMoCUII+kIFkgECCAEi",
            "EgoQUmVzdFN1YnNjcmlwdGlvbiIYChZGaWxlc3lzdGVtU3Vic2NyaXB0aW9u",
            "IiIKIEZpbGVzeXN0ZW1Db2xsZWN0aW9uU3Vic2NyaXB0aW9uKkAKCkFwaVZl",
            "cnNpb24SFQoEQVVUTxAAGgsIAYr0m7MFAzMuMBITCgJWMhABGgsIAYr0m7MF",
            "AzMuMBIGCgJWMxACQoUBCiJpby5lbnZveXByb3h5LmVudm95LmNvbmZpZy5j",
            "b3JlLnYzQhFDb25maWdTb3VyY2VQcm90b1ABWkJnaXRodWIuY29tL2Vudm95",
            "cHJveHkvZ28tY29udHJvbC1wbGFuZS9lbnZveS9jb25maWcvY29yZS92Mztj",
            "b3JldjO6gMjRBgIQAmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Core.V3.GrpcServiceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Core.V3.AuthorityReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Envoy.Config.Core.V3.ApiVersion), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ApiConfigSource), global::Envoy.Config.Core.V3.ApiConfigSource.Parser, new[]{ "ApiType", "TransportApiVersion", "ClusterNames", "GrpcServices", "RefreshDelay", "RequestTimeout", "RateLimitSettings", "SetNodeOnFirstMessageOnly", "ConfigValidators" }, null, new[]{ typeof(global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.AggregatedConfigSource), global::Envoy.Config.Core.V3.AggregatedConfigSource.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.SelfConfigSource), global::Envoy.Config.Core.V3.SelfConfigSource.Parser, new[]{ "TransportApiVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.RateLimitSettings), global::Envoy.Config.Core.V3.RateLimitSettings.Parser, new[]{ "MaxTokens", "FillRate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.PathConfigSource), global::Envoy.Config.Core.V3.PathConfigSource.Parser, new[]{ "Path", "WatchedDirectory" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ConfigSource), global::Envoy.Config.Core.V3.ConfigSource.Parser, new[]{ "Authorities", "Path", "PathConfigSource", "ApiConfigSource", "Ads", "Self", "InitialFetchTimeout", "ResourceApiVersion" }, new[]{ "ConfigSourceSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.ExtensionConfigSource), global::Envoy.Config.Core.V3.ExtensionConfigSource.Parser, new[]{ "ConfigSource", "DefaultConfig", "ApplyDefaultConfigWithoutWarming", "TypeUrls" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.RestSubscription), global::Envoy.Config.Core.V3.RestSubscription.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.FilesystemSubscription), global::Envoy.Config.Core.V3.FilesystemSubscription.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Core.V3.FilesystemCollectionSubscription), global::Envoy.Config.Core.V3.FilesystemCollectionSubscription.Parser, null, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// xDS API and non-xDS services version. This is used to describe both resource and transport
  /// protocol versions (in distinct configuration fields).
  /// </summary>
  public enum ApiVersion {
    /// <summary>
    /// When not specified, we assume v2, to ease migration to Envoy's stable API
    /// versioning. If a client does not support v2 (e.g. due to deprecation), this
    /// is an invalid value.
    /// </summary>
    [pbr::OriginalName("AUTO")] Auto = 0,
    /// <summary>
    /// Use xDS v2 API.
    /// </summary>
    [pbr::OriginalName("V2")] V2 = 1,
    /// <summary>
    /// Use xDS v3 API.
    /// </summary>
    [pbr::OriginalName("V3")] V3 = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// API configuration source. This identifies the API type and cluster that Envoy
  /// will use to fetch an xDS API.
  /// [#next-free-field: 10]
  /// </summary>
  public sealed partial class ApiConfigSource : pb::IMessage<ApiConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApiConfigSource> _parser = new pb::MessageParser<ApiConfigSource>(() => new ApiConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ApiConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource(ApiConfigSource other) : this() {
      apiType_ = other.apiType_;
      transportApiVersion_ = other.transportApiVersion_;
      clusterNames_ = other.clusterNames_.Clone();
      grpcServices_ = other.grpcServices_.Clone();
      refreshDelay_ = other.refreshDelay_ != null ? other.refreshDelay_.Clone() : null;
      requestTimeout_ = other.requestTimeout_ != null ? other.requestTimeout_.Clone() : null;
      rateLimitSettings_ = other.rateLimitSettings_ != null ? other.rateLimitSettings_.Clone() : null;
      setNodeOnFirstMessageOnly_ = other.setNodeOnFirstMessageOnly_;
      configValidators_ = other.configValidators_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ApiConfigSource Clone() {
      return new ApiConfigSource(this);
    }

    /// <summary>Field number for the "api_type" field.</summary>
    public const int ApiTypeFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType apiType_ = global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse;
    /// <summary>
    /// API type (gRPC, REST, delta gRPC)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType ApiType {
      get { return apiType_; }
      set {
        apiType_ = value;
      }
    }

    /// <summary>Field number for the "transport_api_version" field.</summary>
    public const int TransportApiVersionFieldNumber = 8;
    private global::Envoy.Config.Core.V3.ApiVersion transportApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS transport protocol. This describes the xDS gRPC/REST
    /// endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion TransportApiVersion {
      get { return transportApiVersion_; }
      set {
        transportApiVersion_ = value;
      }
    }

    /// <summary>Field number for the "cluster_names" field.</summary>
    public const int ClusterNamesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_clusterNames_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> clusterNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Cluster names should be used only with REST. If > 1
    /// cluster is defined, clusters will be cycled through if any kind of failure
    /// occurs.
    ///
    /// .. note::
    ///
    ///  The cluster with name ``cluster_name`` must be statically defined and its
    ///  type must not be ``EDS``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ClusterNames {
      get { return clusterNames_; }
    }

    /// <summary>Field number for the "grpc_services" field.</summary>
    public const int GrpcServicesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.GrpcService> _repeated_grpcServices_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Core.V3.GrpcService.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService> grpcServices_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService>();
    /// <summary>
    /// Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
    /// services will be cycled through if any kind of failure occurs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.GrpcService> GrpcServices {
      get { return grpcServices_; }
    }

    /// <summary>Field number for the "refresh_delay" field.</summary>
    public const int RefreshDelayFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration refreshDelay_;
    /// <summary>
    /// For REST APIs, the delay between successive polls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RefreshDelay {
      get { return refreshDelay_; }
      set {
        refreshDelay_ = value;
      }
    }

    /// <summary>Field number for the "request_timeout" field.</summary>
    public const int RequestTimeoutFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration requestTimeout_;
    /// <summary>
    /// For REST APIs, the request timeout. If not set, a default value of 1s will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestTimeout {
      get { return requestTimeout_; }
      set {
        requestTimeout_ = value;
      }
    }

    /// <summary>Field number for the "rate_limit_settings" field.</summary>
    public const int RateLimitSettingsFieldNumber = 6;
    private global::Envoy.Config.Core.V3.RateLimitSettings rateLimitSettings_;
    /// <summary>
    /// For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
    /// rate limited.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RateLimitSettings RateLimitSettings {
      get { return rateLimitSettings_; }
      set {
        rateLimitSettings_ = value;
      }
    }

    /// <summary>Field number for the "set_node_on_first_message_only" field.</summary>
    public const int SetNodeOnFirstMessageOnlyFieldNumber = 7;
    private bool setNodeOnFirstMessageOnly_;
    /// <summary>
    /// Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetNodeOnFirstMessageOnly {
      get { return setNodeOnFirstMessageOnly_; }
      set {
        setNodeOnFirstMessageOnly_ = value;
      }
    }

    /// <summary>Field number for the "config_validators" field.</summary>
    public const int ConfigValidatorsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.TypedExtensionConfig> _repeated_configValidators_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Config.Core.V3.TypedExtensionConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> configValidators_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig>();
    /// <summary>
    /// A list of config validators that will be executed when a new update is
    /// received from the ApiConfigSource. Note that each validator handles a
    /// specific xDS service type, and only the validators corresponding to the
    /// type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
    /// will be invoked.
    /// If the validator returns false or throws an exception, the config will be rejected by
    /// the client, and a NACK will be sent.
    /// [#extension-category: envoy.config.validators]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> ConfigValidators {
      get { return configValidators_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ApiConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ApiConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApiType != other.ApiType) return false;
      if (TransportApiVersion != other.TransportApiVersion) return false;
      if(!clusterNames_.Equals(other.clusterNames_)) return false;
      if(!grpcServices_.Equals(other.grpcServices_)) return false;
      if (!object.Equals(RefreshDelay, other.RefreshDelay)) return false;
      if (!object.Equals(RequestTimeout, other.RequestTimeout)) return false;
      if (!object.Equals(RateLimitSettings, other.RateLimitSettings)) return false;
      if (SetNodeOnFirstMessageOnly != other.SetNodeOnFirstMessageOnly) return false;
      if(!configValidators_.Equals(other.configValidators_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) hash ^= ApiType.GetHashCode();
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= TransportApiVersion.GetHashCode();
      hash ^= clusterNames_.GetHashCode();
      hash ^= grpcServices_.GetHashCode();
      if (refreshDelay_ != null) hash ^= RefreshDelay.GetHashCode();
      if (requestTimeout_ != null) hash ^= RequestTimeout.GetHashCode();
      if (rateLimitSettings_ != null) hash ^= RateLimitSettings.GetHashCode();
      if (SetNodeOnFirstMessageOnly != false) hash ^= SetNodeOnFirstMessageOnly.GetHashCode();
      hash ^= configValidators_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApiType);
      }
      clusterNames_.WriteTo(output, _repeated_clusterNames_codec);
      if (refreshDelay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RefreshDelay);
      }
      grpcServices_.WriteTo(output, _repeated_grpcServices_codec);
      if (requestTimeout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        output.WriteRawTag(56);
        output.WriteBool(SetNodeOnFirstMessageOnly);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(64);
        output.WriteEnum((int) TransportApiVersion);
      }
      configValidators_.WriteTo(output, _repeated_configValidators_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApiType);
      }
      clusterNames_.WriteTo(ref output, _repeated_clusterNames_codec);
      if (refreshDelay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RefreshDelay);
      }
      grpcServices_.WriteTo(ref output, _repeated_grpcServices_codec);
      if (requestTimeout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        output.WriteRawTag(56);
        output.WriteBool(SetNodeOnFirstMessageOnly);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(64);
        output.WriteEnum((int) TransportApiVersion);
      }
      configValidators_.WriteTo(ref output, _repeated_configValidators_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ApiType);
      }
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransportApiVersion);
      }
      size += clusterNames_.CalculateSize(_repeated_clusterNames_codec);
      size += grpcServices_.CalculateSize(_repeated_grpcServices_codec);
      if (refreshDelay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RefreshDelay);
      }
      if (requestTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        size += 1 + 1;
      }
      size += configValidators_.CalculateSize(_repeated_configValidators_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ApiConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.ApiType != global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType.DeprecatedAndUnavailableDoNotUse) {
        ApiType = other.ApiType;
      }
      if (other.TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        TransportApiVersion = other.TransportApiVersion;
      }
      clusterNames_.Add(other.clusterNames_);
      grpcServices_.Add(other.grpcServices_);
      if (other.refreshDelay_ != null) {
        if (refreshDelay_ == null) {
          RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RefreshDelay.MergeFrom(other.RefreshDelay);
      }
      if (other.requestTimeout_ != null) {
        if (requestTimeout_ == null) {
          RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestTimeout.MergeFrom(other.RequestTimeout);
      }
      if (other.rateLimitSettings_ != null) {
        if (rateLimitSettings_ == null) {
          RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
        }
        RateLimitSettings.MergeFrom(other.RateLimitSettings);
      }
      if (other.SetNodeOnFirstMessageOnly != false) {
        SetNodeOnFirstMessageOnly = other.SetNodeOnFirstMessageOnly;
      }
      configValidators_.Add(other.configValidators_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ApiType = (global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) input.ReadEnum();
            break;
          }
          case 18: {
            clusterNames_.AddEntriesFrom(input, _repeated_clusterNames_codec);
            break;
          }
          case 26: {
            if (refreshDelay_ == null) {
              RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RefreshDelay);
            break;
          }
          case 34: {
            grpcServices_.AddEntriesFrom(input, _repeated_grpcServices_codec);
            break;
          }
          case 42: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 50: {
            if (rateLimitSettings_ == null) {
              RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
            }
            input.ReadMessage(RateLimitSettings);
            break;
          }
          case 56: {
            SetNodeOnFirstMessageOnly = input.ReadBool();
            break;
          }
          case 64: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 74: {
            configValidators_.AddEntriesFrom(input, _repeated_configValidators_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ApiType = (global::Envoy.Config.Core.V3.ApiConfigSource.Types.ApiType) input.ReadEnum();
            break;
          }
          case 18: {
            clusterNames_.AddEntriesFrom(ref input, _repeated_clusterNames_codec);
            break;
          }
          case 26: {
            if (refreshDelay_ == null) {
              RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RefreshDelay);
            break;
          }
          case 34: {
            grpcServices_.AddEntriesFrom(ref input, _repeated_grpcServices_codec);
            break;
          }
          case 42: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 50: {
            if (rateLimitSettings_ == null) {
              RateLimitSettings = new global::Envoy.Config.Core.V3.RateLimitSettings();
            }
            input.ReadMessage(RateLimitSettings);
            break;
          }
          case 56: {
            SetNodeOnFirstMessageOnly = input.ReadBool();
            break;
          }
          case 64: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 74: {
            configValidators_.AddEntriesFrom(ref input, _repeated_configValidators_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ApiConfigSource message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// APIs may be fetched via either REST or gRPC.
      /// </summary>
      public enum ApiType {
        /// <summary>
        /// Ideally this would be 'reserved 0' but one can't reserve the default
        /// value. Instead we throw an exception if this is ever used.
        /// </summary>
        [pbr::OriginalName("DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE")] DeprecatedAndUnavailableDoNotUse = 0,
        /// <summary>
        /// REST-JSON v2 API. The `canonical JSON encoding
        /// &lt;https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
        /// the v2 protos is used.
        /// </summary>
        [pbr::OriginalName("REST")] Rest = 1,
        /// <summary>
        /// SotW gRPC service.
        /// </summary>
        [pbr::OriginalName("GRPC")] Grpc = 2,
        /// <summary>
        /// Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
        /// rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
        /// with every update, the xDS server only sends what has changed since the last update.
        /// </summary>
        [pbr::OriginalName("DELTA_GRPC")] DeltaGrpc = 3,
        /// <summary>
        /// SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
        /// multiplexed on a single connection to an ADS endpoint.
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("AGGREGATED_GRPC")] AggregatedGrpc = 5,
        /// <summary>
        /// Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
        /// multiplexed on a single connection to an ADS endpoint.
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("AGGREGATED_DELTA_GRPC")] AggregatedDeltaGrpc = 6,
      }

    }
    #endregion

  }

  /// <summary>
  /// Aggregated Discovery Service (ADS) options. This is currently empty, but when
  /// set in :ref:`ConfigSource &lt;envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
  /// specify that ADS is to be used.
  /// </summary>
  public sealed partial class AggregatedConfigSource : pb::IMessage<AggregatedConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AggregatedConfigSource> _parser = new pb::MessageParser<AggregatedConfigSource>(() => new AggregatedConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AggregatedConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource(AggregatedConfigSource other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedConfigSource Clone() {
      return new AggregatedConfigSource(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AggregatedConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AggregatedConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AggregatedConfigSource other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// Self-referencing config source options. This is currently empty, but when
  /// set in :ref:`ConfigSource &lt;envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
  /// specify that other data can be obtained from the same server.
  /// </summary>
  public sealed partial class SelfConfigSource : pb::IMessage<SelfConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SelfConfigSource> _parser = new pb::MessageParser<SelfConfigSource>(() => new SelfConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SelfConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource(SelfConfigSource other) : this() {
      transportApiVersion_ = other.transportApiVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelfConfigSource Clone() {
      return new SelfConfigSource(this);
    }

    /// <summary>Field number for the "transport_api_version" field.</summary>
    public const int TransportApiVersionFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ApiVersion transportApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS transport protocol. This describes the xDS gRPC/REST
    /// endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion TransportApiVersion {
      get { return transportApiVersion_; }
      set {
        transportApiVersion_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SelfConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SelfConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TransportApiVersion != other.TransportApiVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= TransportApiVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TransportApiVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SelfConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.TransportApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        TransportApiVersion = other.TransportApiVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TransportApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Rate Limit settings to be applied for discovery requests made by Envoy.
  /// </summary>
  public sealed partial class RateLimitSettings : pb::IMessage<RateLimitSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RateLimitSettings> _parser = new pb::MessageParser<RateLimitSettings>(() => new RateLimitSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RateLimitSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings(RateLimitSettings other) : this() {
      MaxTokens = other.MaxTokens;
      FillRate = other.FillRate;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimitSettings Clone() {
      return new RateLimitSettings(this);
    }

    /// <summary>Field number for the "max_tokens" field.</summary>
    public const int MaxTokensFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxTokens_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxTokens_;
    /// <summary>
    /// Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
    /// default value of 100 will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxTokens {
      get { return maxTokens_; }
      set {
        maxTokens_ = value;
      }
    }


    /// <summary>Field number for the "fill_rate" field.</summary>
    public const int FillRateFieldNumber = 2;
    private static readonly pb::FieldCodec<double?> _single_fillRate_codec = pb::FieldCodec.ForStructWrapper<double>(18);
    private double? fillRate_;
    /// <summary>
    /// Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
    /// per second will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double? FillRate {
      get { return fillRate_; }
      set {
        fillRate_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RateLimitSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RateLimitSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxTokens != other.MaxTokens) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(FillRate, other.FillRate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxTokens_ != null) hash ^= MaxTokens.GetHashCode();
      if (fillRate_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(FillRate);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxTokens_ != null) {
        _single_maxTokens_codec.WriteTagAndValue(output, MaxTokens);
      }
      if (fillRate_ != null) {
        _single_fillRate_codec.WriteTagAndValue(output, FillRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxTokens_ != null) {
        _single_maxTokens_codec.WriteTagAndValue(ref output, MaxTokens);
      }
      if (fillRate_ != null) {
        _single_fillRate_codec.WriteTagAndValue(ref output, FillRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxTokens_ != null) {
        size += _single_maxTokens_codec.CalculateSizeWithTag(MaxTokens);
      }
      if (fillRate_ != null) {
        size += _single_fillRate_codec.CalculateSizeWithTag(FillRate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RateLimitSettings other) {
      if (other == null) {
        return;
      }
      if (other.maxTokens_ != null) {
        if (maxTokens_ == null || other.MaxTokens != 0) {
          MaxTokens = other.MaxTokens;
        }
      }
      if (other.fillRate_ != null) {
        if (fillRate_ == null || other.FillRate != 0D) {
          FillRate = other.FillRate;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxTokens_codec.Read(input);
            if (maxTokens_ == null || value != 0) {
              MaxTokens = value;
            }
            break;
          }
          case 18: {
            double? value = _single_fillRate_codec.Read(input);
            if (fillRate_ == null || value != 0D) {
              FillRate = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_maxTokens_codec.Read(ref input);
            if (maxTokens_ == null || value != 0) {
              MaxTokens = value;
            }
            break;
          }
          case 18: {
            double? value = _single_fillRate_codec.Read(ref input);
            if (fillRate_ == null || value != 0D) {
              FillRate = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Local filesystem path configuration source.
  /// </summary>
  public sealed partial class PathConfigSource : pb::IMessage<PathConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PathConfigSource> _parser = new pb::MessageParser<PathConfigSource>(() => new PathConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PathConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PathConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PathConfigSource(PathConfigSource other) : this() {
      path_ = other.path_;
      watchedDirectory_ = other.watchedDirectory_ != null ? other.watchedDirectory_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PathConfigSource Clone() {
      return new PathConfigSource(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private string path_ = "";
    /// <summary>
    /// Path on the filesystem to source and watch for configuration updates.
    /// When sourcing configuration for a :ref:`secret &lt;envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
    /// the certificate and key files are also watched for updates.
    ///
    /// .. note::
    ///
    ///  The path to the source must exist at config load time.
    ///
    /// .. note::
    ///
    ///   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
    ///   This is because in general only moves are atomic. The same method of swapping files as is
    ///   demonstrated in the :ref:`runtime documentation &lt;config_runtime_symbolic_link_swap>` can be
    ///   used here also. If ``watched_directory`` is configured, no watch will be placed directly on
    ///   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
    ///   this path. This is required in certain deployment scenarios. See below for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "watched_directory" field.</summary>
    public const int WatchedDirectoryFieldNumber = 2;
    private global::Envoy.Config.Core.V3.WatchedDirectory watchedDirectory_;
    /// <summary>
    /// If configured, this directory will be watched for *moves*. When an entry in this directory is
    /// moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.
    ///
    /// Specifically, if trying to load an xDS resource using a
    /// `Kubernetes ConfigMap &lt;https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
    /// following configuration might be used:
    /// 1. Store xds.yaml inside a ConfigMap.
    /// 2. Mount the ConfigMap to ``/config_map/xds``
    /// 3. Configure path ``/config_map/xds/xds.yaml``
    /// 4. Configure watched directory ``/config_map/xds``
    ///
    /// The above configuration will ensure that Envoy watches the owning directory for moves which is
    /// required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.WatchedDirectory WatchedDirectory {
      get { return watchedDirectory_; }
      set {
        watchedDirectory_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PathConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PathConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (!object.Equals(WatchedDirectory, other.WatchedDirectory)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Path.Length != 0) hash ^= Path.GetHashCode();
      if (watchedDirectory_ != null) hash ^= WatchedDirectory.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(WatchedDirectory);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (watchedDirectory_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(WatchedDirectory);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Path.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (watchedDirectory_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WatchedDirectory);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PathConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.Path.Length != 0) {
        Path = other.Path;
      }
      if (other.watchedDirectory_ != null) {
        if (watchedDirectory_ == null) {
          WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
        }
        WatchedDirectory.MergeFrom(other.WatchedDirectory);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (watchedDirectory_ == null) {
              WatchedDirectory = new global::Envoy.Config.Core.V3.WatchedDirectory();
            }
            input.ReadMessage(WatchedDirectory);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for :ref:`listeners &lt;config_listeners>`, :ref:`clusters
  /// &lt;config_cluster_manager>`, :ref:`routes
  /// &lt;envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
  /// &lt;arch_overview_service_discovery>` etc. may either be sourced from the
  /// filesystem or from an xDS API source. Filesystem configs are watched with
  /// inotify for updates.
  /// [#next-free-field: 9]
  /// </summary>
  public sealed partial class ConfigSource : pb::IMessage<ConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigSource> _parser = new pb::MessageParser<ConfigSource>(() => new ConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource(ConfigSource other) : this() {
      authorities_ = other.authorities_.Clone();
      initialFetchTimeout_ = other.initialFetchTimeout_ != null ? other.initialFetchTimeout_.Clone() : null;
      resourceApiVersion_ = other.resourceApiVersion_;
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.PathConfigSource:
          PathConfigSource = other.PathConfigSource.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          ApiConfigSource = other.ApiConfigSource.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          Ads = other.Ads.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.Self:
          Self = other.Self.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSource Clone() {
      return new ConfigSource(this);
    }

    /// <summary>Field number for the "authorities" field.</summary>
    public const int AuthoritiesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Xds.Core.V3.Authority> _repeated_authorities_codec
        = pb::FieldCodec.ForMessage(58, global::Xds.Core.V3.Authority.Parser);
    private readonly pbc::RepeatedField<global::Xds.Core.V3.Authority> authorities_ = new pbc::RepeatedField<global::Xds.Core.V3.Authority>();
    /// <summary>
    /// Authorities that this config source may be used for. An authority specified in a xdstp:// URL
    /// is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
    /// association between authority name and configuration source.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Xds.Core.V3.Authority> Authorities {
      get { return authorities_; }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    /// <summary>
    /// Deprecated in favor of ``path_config_source``. Use that field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path ? (string) configSourceSpecifier_ : ""; }
      set {
        configSourceSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "path_config_source" field.</summary>
    public const int PathConfigSourceFieldNumber = 8;
    /// <summary>
    /// Local filesystem path configuration source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.PathConfigSource PathConfigSource {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource ? (global::Envoy.Config.Core.V3.PathConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.PathConfigSource;
      }
    }

    /// <summary>Field number for the "api_config_source" field.</summary>
    public const int ApiConfigSourceFieldNumber = 2;
    /// <summary>
    /// API configuration source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiConfigSource ApiConfigSource {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource ? (global::Envoy.Config.Core.V3.ApiConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.ApiConfigSource;
      }
    }

    /// <summary>Field number for the "ads" field.</summary>
    public const int AdsFieldNumber = 3;
    /// <summary>
    /// When set, ADS will be used to fetch resources. The ADS API configuration
    /// source in the bootstrap configuration is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.AggregatedConfigSource Ads {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads ? (global::Envoy.Config.Core.V3.AggregatedConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.Ads;
      }
    }

    /// <summary>Field number for the "self" field.</summary>
    public const int SelfFieldNumber = 5;
    /// <summary>
    /// [#not-implemented-hide:]
    /// When set, the client will access the resources from the same server it got the
    /// ConfigSource from, although not necessarily from the same stream. This is similar to the
    /// :ref:`ads&lt;envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
    /// different stream to the same server. As a result, this field can be used for things
    /// like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
    /// LDS to RDS on the same server without requiring the management server to know its name
    /// or required credentials.
    /// [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
    /// this field can implicitly mean to use the same stream in the case where the ConfigSource
    /// is provided via ADS and the specified data can also be obtained via ADS.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.SelfConfigSource Self {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self ? (global::Envoy.Config.Core.V3.SelfConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.Self;
      }
    }

    /// <summary>Field number for the "initial_fetch_timeout" field.</summary>
    public const int InitialFetchTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration initialFetchTimeout_;
    /// <summary>
    /// When this timeout is specified, Envoy will wait no longer than the specified time for first
    /// config response on this xDS subscription during the :ref:`initialization process
    /// &lt;arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
    /// initialization phase, even if the first config is not delivered yet. The timer is activated
    /// when the xDS API subscription starts, and is disarmed on first config update or on error. 0
    /// means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
    /// timeout applies). The default is 15s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration InitialFetchTimeout {
      get { return initialFetchTimeout_; }
      set {
        initialFetchTimeout_ = value;
      }
    }

    /// <summary>Field number for the "resource_api_version" field.</summary>
    public const int ResourceApiVersionFieldNumber = 6;
    private global::Envoy.Config.Core.V3.ApiVersion resourceApiVersion_ = global::Envoy.Config.Core.V3.ApiVersion.Auto;
    /// <summary>
    /// API version for xDS resources. This implies the type URLs that the client
    /// will request for resources and the resource type that the client will in
    /// turn expect to be delivered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ApiVersion ResourceApiVersion {
      get { return resourceApiVersion_; }
      set {
        resourceApiVersion_ = value;
      }
    }

    private object configSourceSpecifier_;
    /// <summary>Enum of possible cases for the "config_source_specifier" oneof.</summary>
    public enum ConfigSourceSpecifierOneofCase {
      None = 0,
      Path = 1,
      PathConfigSource = 8,
      ApiConfigSource = 2,
      Ads = 3,
      Self = 5,
    }
    private ConfigSourceSpecifierOneofCase configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigSourceSpecifierOneofCase ConfigSourceSpecifierCase {
      get { return configSourceSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConfigSourceSpecifier() {
      configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
      configSourceSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!authorities_.Equals(other.authorities_)) return false;
      if (Path != other.Path) return false;
      if (!object.Equals(PathConfigSource, other.PathConfigSource)) return false;
      if (!object.Equals(ApiConfigSource, other.ApiConfigSource)) return false;
      if (!object.Equals(Ads, other.Ads)) return false;
      if (!object.Equals(Self, other.Self)) return false;
      if (!object.Equals(InitialFetchTimeout, other.InitialFetchTimeout)) return false;
      if (ResourceApiVersion != other.ResourceApiVersion) return false;
      if (ConfigSourceSpecifierCase != other.ConfigSourceSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= authorities_.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) hash ^= PathConfigSource.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) hash ^= ApiConfigSource.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) hash ^= Ads.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) hash ^= Self.GetHashCode();
      if (initialFetchTimeout_ != null) hash ^= InitialFetchTimeout.GetHashCode();
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) hash ^= ResourceApiVersion.GetHashCode();
      hash ^= (int) configSourceSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        output.WriteRawTag(18);
        output.WriteMessage(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        output.WriteRawTag(26);
        output.WriteMessage(Ads);
      }
      if (initialFetchTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InitialFetchTimeout);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        output.WriteRawTag(42);
        output.WriteMessage(Self);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ResourceApiVersion);
      }
      authorities_.WriteTo(output, _repeated_authorities_codec);
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) {
        output.WriteRawTag(66);
        output.WriteMessage(PathConfigSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        output.WriteRawTag(18);
        output.WriteMessage(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        output.WriteRawTag(26);
        output.WriteMessage(Ads);
      }
      if (initialFetchTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InitialFetchTimeout);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        output.WriteRawTag(42);
        output.WriteMessage(Self);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ResourceApiVersion);
      }
      authorities_.WriteTo(ref output, _repeated_authorities_codec);
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) {
        output.WriteRawTag(66);
        output.WriteMessage(PathConfigSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += authorities_.CalculateSize(_repeated_authorities_codec);
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PathConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ads);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Self);
      }
      if (initialFetchTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialFetchTimeout);
      }
      if (ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResourceApiVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigSource other) {
      if (other == null) {
        return;
      }
      authorities_.Add(other.authorities_);
      if (other.initialFetchTimeout_ != null) {
        if (initialFetchTimeout_ == null) {
          InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        InitialFetchTimeout.MergeFrom(other.InitialFetchTimeout);
      }
      if (other.ResourceApiVersion != global::Envoy.Config.Core.V3.ApiVersion.Auto) {
        ResourceApiVersion = other.ResourceApiVersion;
      }
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.PathConfigSource:
          if (PathConfigSource == null) {
            PathConfigSource = new global::Envoy.Config.Core.V3.PathConfigSource();
          }
          PathConfigSource.MergeFrom(other.PathConfigSource);
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          if (ApiConfigSource == null) {
            ApiConfigSource = new global::Envoy.Config.Core.V3.ApiConfigSource();
          }
          ApiConfigSource.MergeFrom(other.ApiConfigSource);
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          if (Ads == null) {
            Ads = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
          }
          Ads.MergeFrom(other.Ads);
          break;
        case ConfigSourceSpecifierOneofCase.Self:
          if (Self == null) {
            Self = new global::Envoy.Config.Core.V3.SelfConfigSource();
          }
          Self.MergeFrom(other.Self);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.ApiConfigSource subBuilder = new global::Envoy.Config.Core.V3.ApiConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
              subBuilder.MergeFrom(ApiConfigSource);
            }
            input.ReadMessage(subBuilder);
            ApiConfigSource = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.AggregatedConfigSource subBuilder = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
              subBuilder.MergeFrom(Ads);
            }
            input.ReadMessage(subBuilder);
            Ads = subBuilder;
            break;
          }
          case 34: {
            if (initialFetchTimeout_ == null) {
              InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialFetchTimeout);
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.SelfConfigSource subBuilder = new global::Envoy.Config.Core.V3.SelfConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
              subBuilder.MergeFrom(Self);
            }
            input.ReadMessage(subBuilder);
            Self = subBuilder;
            break;
          }
          case 48: {
            ResourceApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 58: {
            authorities_.AddEntriesFrom(input, _repeated_authorities_codec);
            break;
          }
          case 66: {
            global::Envoy.Config.Core.V3.PathConfigSource subBuilder = new global::Envoy.Config.Core.V3.PathConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) {
              subBuilder.MergeFrom(PathConfigSource);
            }
            input.ReadMessage(subBuilder);
            PathConfigSource = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Config.Core.V3.ApiConfigSource subBuilder = new global::Envoy.Config.Core.V3.ApiConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
              subBuilder.MergeFrom(ApiConfigSource);
            }
            input.ReadMessage(subBuilder);
            ApiConfigSource = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Core.V3.AggregatedConfigSource subBuilder = new global::Envoy.Config.Core.V3.AggregatedConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
              subBuilder.MergeFrom(Ads);
            }
            input.ReadMessage(subBuilder);
            Ads = subBuilder;
            break;
          }
          case 34: {
            if (initialFetchTimeout_ == null) {
              InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialFetchTimeout);
            break;
          }
          case 42: {
            global::Envoy.Config.Core.V3.SelfConfigSource subBuilder = new global::Envoy.Config.Core.V3.SelfConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Self) {
              subBuilder.MergeFrom(Self);
            }
            input.ReadMessage(subBuilder);
            Self = subBuilder;
            break;
          }
          case 48: {
            ResourceApiVersion = (global::Envoy.Config.Core.V3.ApiVersion) input.ReadEnum();
            break;
          }
          case 58: {
            authorities_.AddEntriesFrom(ref input, _repeated_authorities_codec);
            break;
          }
          case 66: {
            global::Envoy.Config.Core.V3.PathConfigSource subBuilder = new global::Envoy.Config.Core.V3.PathConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.PathConfigSource) {
              subBuilder.MergeFrom(PathConfigSource);
            }
            input.ReadMessage(subBuilder);
            PathConfigSource = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration source specifier for a late-bound extension configuration. The
  /// parent resource is warmed until all the initial extension configurations are
  /// received, unless the flag to apply the default configuration is set.
  /// Subsequent extension updates are atomic on a per-worker basis. Once an
  /// extension configuration is applied to a request or a connection, it remains
  /// constant for the duration of processing. If the initial delivery of the
  /// extension configuration fails, due to a timeout for example, the optional
  /// default configuration is applied. Without a default configuration, the
  /// extension is disabled, until an extension configuration is received. The
  /// behavior of a disabled extension depends on the context. For example, a
  /// filter chain with a disabled extension filter rejects all incoming streams.
  /// </summary>
  public sealed partial class ExtensionConfigSource : pb::IMessage<ExtensionConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExtensionConfigSource> _parser = new pb::MessageParser<ExtensionConfigSource>(() => new ExtensionConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExtensionConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtensionConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtensionConfigSource(ExtensionConfigSource other) : this() {
      configSource_ = other.configSource_ != null ? other.configSource_.Clone() : null;
      defaultConfig_ = other.defaultConfig_ != null ? other.defaultConfig_.Clone() : null;
      applyDefaultConfigWithoutWarming_ = other.applyDefaultConfigWithoutWarming_;
      typeUrls_ = other.typeUrls_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExtensionConfigSource Clone() {
      return new ExtensionConfigSource(this);
    }

    /// <summary>Field number for the "config_source" field.</summary>
    public const int ConfigSourceFieldNumber = 1;
    private global::Envoy.Config.Core.V3.ConfigSource configSource_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ConfigSource ConfigSource {
      get { return configSource_; }
      set {
        configSource_ = value;
      }
    }

    /// <summary>Field number for the "default_config" field.</summary>
    public const int DefaultConfigFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Any defaultConfig_;
    /// <summary>
    /// Optional default configuration to use as the initial configuration if
    /// there is a failure to receive the initial extension configuration or if
    /// ``apply_default_config_without_warming`` flag is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any DefaultConfig {
      get { return defaultConfig_; }
      set {
        defaultConfig_ = value;
      }
    }

    /// <summary>Field number for the "apply_default_config_without_warming" field.</summary>
    public const int ApplyDefaultConfigWithoutWarmingFieldNumber = 3;
    private bool applyDefaultConfigWithoutWarming_;
    /// <summary>
    /// Use the default config as the initial configuration without warming and
    /// waiting for the first discovery response. Requires the default configuration
    /// to be supplied.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ApplyDefaultConfigWithoutWarming {
      get { return applyDefaultConfigWithoutWarming_; }
      set {
        applyDefaultConfigWithoutWarming_ = value;
      }
    }

    /// <summary>Field number for the "type_urls" field.</summary>
    public const int TypeUrlsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_typeUrls_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> typeUrls_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A set of permitted extension type URLs. Extension configuration updates are rejected
    /// if they do not match any type URL in the set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> TypeUrls {
      get { return typeUrls_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExtensionConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExtensionConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConfigSource, other.ConfigSource)) return false;
      if (!object.Equals(DefaultConfig, other.DefaultConfig)) return false;
      if (ApplyDefaultConfigWithoutWarming != other.ApplyDefaultConfigWithoutWarming) return false;
      if(!typeUrls_.Equals(other.typeUrls_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (configSource_ != null) hash ^= ConfigSource.GetHashCode();
      if (defaultConfig_ != null) hash ^= DefaultConfig.GetHashCode();
      if (ApplyDefaultConfigWithoutWarming != false) hash ^= ApplyDefaultConfigWithoutWarming.GetHashCode();
      hash ^= typeUrls_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (defaultConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DefaultConfig);
      }
      if (ApplyDefaultConfigWithoutWarming != false) {
        output.WriteRawTag(24);
        output.WriteBool(ApplyDefaultConfigWithoutWarming);
      }
      typeUrls_.WriteTo(output, _repeated_typeUrls_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (defaultConfig_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DefaultConfig);
      }
      if (ApplyDefaultConfigWithoutWarming != false) {
        output.WriteRawTag(24);
        output.WriteBool(ApplyDefaultConfigWithoutWarming);
      }
      typeUrls_.WriteTo(ref output, _repeated_typeUrls_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (configSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigSource);
      }
      if (defaultConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultConfig);
      }
      if (ApplyDefaultConfigWithoutWarming != false) {
        size += 1 + 1;
      }
      size += typeUrls_.CalculateSize(_repeated_typeUrls_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExtensionConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.configSource_ != null) {
        if (configSource_ == null) {
          ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
        }
        ConfigSource.MergeFrom(other.ConfigSource);
      }
      if (other.defaultConfig_ != null) {
        if (defaultConfig_ == null) {
          DefaultConfig = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        DefaultConfig.MergeFrom(other.DefaultConfig);
      }
      if (other.ApplyDefaultConfigWithoutWarming != false) {
        ApplyDefaultConfigWithoutWarming = other.ApplyDefaultConfigWithoutWarming;
      }
      typeUrls_.Add(other.typeUrls_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (configSource_ == null) {
              ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 18: {
            if (defaultConfig_ == null) {
              DefaultConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(DefaultConfig);
            break;
          }
          case 24: {
            ApplyDefaultConfigWithoutWarming = input.ReadBool();
            break;
          }
          case 34: {
            typeUrls_.AddEntriesFrom(input, _repeated_typeUrls_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (configSource_ == null) {
              ConfigSource = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 18: {
            if (defaultConfig_ == null) {
              DefaultConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(DefaultConfig);
            break;
          }
          case 24: {
            ApplyDefaultConfigWithoutWarming = input.ReadBool();
            break;
          }
          case 34: {
            typeUrls_.AddEntriesFrom(ref input, _repeated_typeUrls_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A placeholder proto for the registration for the REST subscription implementation.
  /// </summary>
  public sealed partial class RestSubscription : pb::IMessage<RestSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RestSubscription> _parser = new pb::MessageParser<RestSubscription>(() => new RestSubscription());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RestSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RestSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RestSubscription(RestSubscription other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RestSubscription Clone() {
      return new RestSubscription(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RestSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RestSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RestSubscription other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A placeholder proto for the registration for the filesystem subscription implementation.
  /// </summary>
  public sealed partial class FilesystemSubscription : pb::IMessage<FilesystemSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FilesystemSubscription> _parser = new pb::MessageParser<FilesystemSubscription>(() => new FilesystemSubscription());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FilesystemSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemSubscription(FilesystemSubscription other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemSubscription Clone() {
      return new FilesystemSubscription(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FilesystemSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FilesystemSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FilesystemSubscription other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A placeholder proto for the registration for the filesystem collection subscription implementation.
  /// </summary>
  public sealed partial class FilesystemCollectionSubscription : pb::IMessage<FilesystemCollectionSubscription>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FilesystemCollectionSubscription> _parser = new pb::MessageParser<FilesystemCollectionSubscription>(() => new FilesystemCollectionSubscription());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FilesystemCollectionSubscription> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemCollectionSubscription() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemCollectionSubscription(FilesystemCollectionSubscription other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilesystemCollectionSubscription Clone() {
      return new FilesystemCollectionSubscription(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FilesystemCollectionSubscription);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FilesystemCollectionSubscription other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FilesystemCollectionSubscription other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
