// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/cluster/v3/cluster.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Cluster.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/cluster/v3/cluster.proto</summary>
  public static partial class ClusterReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/cluster/v3/cluster.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ClusterReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiVlbnZveS9jb25maWcvY2x1c3Rlci92My9jbHVzdGVyLnByb3RvEhdlbnZv",
            "eS5jb25maWcuY2x1c3Rlci52MxotZW52b3kvY29uZmlnL2NsdXN0ZXIvdjMv",
            "Y2lyY3VpdF9icmVha2VyLnByb3RvGiRlbnZveS9jb25maWcvY2x1c3Rlci92",
            "My9maWx0ZXIucHJvdG8aL2Vudm95L2NvbmZpZy9jbHVzdGVyL3YzL291dGxp",
            "ZXJfZGV0ZWN0aW9uLnByb3RvGiJlbnZveS9jb25maWcvY29yZS92My9hZGRy",
            "ZXNzLnByb3RvGh9lbnZveS9jb25maWcvY29yZS92My9iYXNlLnByb3RvGihl",
            "bnZveS9jb25maWcvY29yZS92My9jb25maWdfc291cmNlLnByb3RvGiRlbnZv",
            "eS9jb25maWcvY29yZS92My9leHRlbnNpb24ucHJvdG8aJ2Vudm95L2NvbmZp",
            "Zy9jb3JlL3YzL2hlYWx0aF9jaGVjay5wcm90bxojZW52b3kvY29uZmlnL2Nv",
            "cmUvdjMvcHJvdG9jb2wucHJvdG8aI2Vudm95L2NvbmZpZy9jb3JlL3YzL3Jl",
            "c29sdmVyLnByb3RvGidlbnZveS9jb25maWcvZW5kcG9pbnQvdjMvZW5kcG9p",
            "bnQucHJvdG8aG2Vudm95L3R5cGUvdjMvcGVyY2VudC5wcm90bxoZZ29vZ2xl",
            "L3Byb3RvYnVmL2FueS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9u",
            "LnByb3RvGhxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvGh5nb29nbGUv",
            "cHJvdG9idWYvd3JhcHBlcnMucHJvdG8aInhkcy9jb3JlL3YzL2NvbGxlY3Rp",
            "b25fZW50cnkucHJvdG8aI2Vudm95L2Fubm90YXRpb25zL2RlcHJlY2F0aW9u",
            "LnByb3RvGh51ZHBhL2Fubm90YXRpb25zL21pZ3JhdGUucHJvdG8aH3VkcGEv",
            "YW5ub3RhdGlvbnMvc2VjdXJpdHkucHJvdG8aHXVkcGEvYW5ub3RhdGlvbnMv",
            "c3RhdHVzLnByb3RvGiF1ZHBhL2Fubm90YXRpb25zL3ZlcnNpb25pbmcucHJv",
            "dG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIkIKEUNsdXN0ZXJDb2xsZWN0",
            "aW9uEi0KB2VudHJpZXMYASABKAsyHC54ZHMuY29yZS52My5Db2xsZWN0aW9u",
            "RW50cnki6UEKB0NsdXN0ZXISVwoYdHJhbnNwb3J0X3NvY2tldF9tYXRjaGVz",
            "GCsgAygLMjUuZW52b3kuY29uZmlnLmNsdXN0ZXIudjMuQ2x1c3Rlci5UcmFu",
            "c3BvcnRTb2NrZXRNYXRjaBIVCgRuYW1lGAEgASgJQgf6QgRyAhABEjEKDWFs",
            "dF9zdGF0X25hbWUYHCABKAlCGvKY/o8FFAoSb2JzZXJ2YWJpbGl0eV9uYW1l",
            "EkgKBHR5cGUYAiABKA4yLi5lbnZveS5jb25maWcuY2x1c3Rlci52My5DbHVz",
            "dGVyLkRpc2NvdmVyeVR5cGVCCPpCBYIBAhABSAASSgoMY2x1c3Rlcl90eXBl",
            "GCYgASgLMjIuZW52b3kuY29uZmlnLmNsdXN0ZXIudjMuQ2x1c3Rlci5DdXN0",
            "b21DbHVzdGVyVHlwZUgAEk0KEmVkc19jbHVzdGVyX2NvbmZpZxgDIAEoCzIx",
            "LmVudm95LmNvbmZpZy5jbHVzdGVyLnYzLkNsdXN0ZXIuRWRzQ2x1c3RlckNv",
            "bmZpZxI8Cg9jb25uZWN0X3RpbWVvdXQYBCABKAsyGS5nb29nbGUucHJvdG9i",
            "dWYuRHVyYXRpb25CCPpCBaoBAioAElAKIXBlcl9jb25uZWN0aW9uX2J1ZmZl",
            "cl9saW1pdF9ieXRlcxgFIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZUIHipO3KgIQARJGCglsYl9wb2xpY3kYBiABKA4yKS5lbnZveS5jb25m",
            "aWcuY2x1c3Rlci52My5DbHVzdGVyLkxiUG9saWN5Qgj6QgWCAQIQARJICg9s",
            "b2FkX2Fzc2lnbm1lbnQYISABKAsyLy5lbnZveS5jb25maWcuZW5kcG9pbnQu",
            "djMuQ2x1c3RlckxvYWRBc3NpZ25tZW50EjgKDWhlYWx0aF9jaGVja3MYCCAD",
            "KAsyIS5lbnZveS5jb25maWcuY29yZS52My5IZWFsdGhDaGVjaxJOChttYXhf",
            "cmVxdWVzdHNfcGVyX2Nvbm5lY3Rpb24YCSABKAsyHC5nb29nbGUucHJvdG9i",
            "dWYuVUludDMyVmFsdWVCCxgBkseG2AQDMy4wEkIKEGNpcmN1aXRfYnJlYWtl",
            "cnMYCiABKAsyKC5lbnZveS5jb25maWcuY2x1c3Rlci52My5DaXJjdWl0QnJl",
            "YWtlcnMSZgoedXBzdHJlYW1faHR0cF9wcm90b2NvbF9vcHRpb25zGC4gASgL",
            "MjEuZW52b3kuY29uZmlnLmNvcmUudjMuVXBzdHJlYW1IdHRwUHJvdG9jb2xP",
            "cHRpb25zQgsYAZLHhtgEAzMuMBJcChxjb21tb25faHR0cF9wcm90b2NvbF9v",
            "cHRpb25zGB0gASgLMikuZW52b3kuY29uZmlnLmNvcmUudjMuSHR0cFByb3Rv",
            "Y29sT3B0aW9uc0ILGAGSx4bYBAMzLjASVgoVaHR0cF9wcm90b2NvbF9vcHRp",
            "b25zGA0gASgLMiouZW52b3kuY29uZmlnLmNvcmUudjMuSHR0cDFQcm90b2Nv",
            "bE9wdGlvbnNCCxgBkseG2AQDMy4wEl4KFmh0dHAyX3Byb3RvY29sX29wdGlv",
            "bnMYDiABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5IdHRwMlByb3RvY29s",
            "T3B0aW9uc0ISGAGKk7cqAhABkseG2AQDMy4wEm0KIHR5cGVkX2V4dGVuc2lv",
            "bl9wcm90b2NvbF9vcHRpb25zGCQgAygLMkMuZW52b3kuY29uZmlnLmNsdXN0",
            "ZXIudjMuQ2x1c3Rlci5UeXBlZEV4dGVuc2lvblByb3RvY29sT3B0aW9uc0Vu",
            "dHJ5EkEKEGRuc19yZWZyZXNoX3JhdGUYECABKAsyGS5nb29nbGUucHJvdG9i",
            "dWYuRHVyYXRpb25CDPpCCaoBBioEEMCEPRJOChhkbnNfZmFpbHVyZV9yZWZy",
            "ZXNoX3JhdGUYLCABKAsyLC5lbnZveS5jb25maWcuY2x1c3Rlci52My5DbHVz",
            "dGVyLlJlZnJlc2hSYXRlEhcKD3Jlc3BlY3RfZG5zX3R0bBgnIAEoCBJVChFk",
            "bnNfbG9va3VwX2ZhbWlseRgRIAEoDjIwLmVudm95LmNvbmZpZy5jbHVzdGVy",
            "LnYzLkNsdXN0ZXIuRG5zTG9va3VwRmFtaWx5Qgj6QgWCAQIQARJBCg1kbnNf",
            "cmVzb2x2ZXJzGBIgAygLMh0uZW52b3kuY29uZmlnLmNvcmUudjMuQWRkcmVz",
            "c0ILGAGSx4bYBAMzLjASLAoXdXNlX3RjcF9mb3JfZG5zX2xvb2t1cHMYLSAB",
            "KAhCCxgBkseG2AQDMy4wElUKFWRuc19yZXNvbHV0aW9uX2NvbmZpZxg1IAEo",
            "CzIpLmVudm95LmNvbmZpZy5jb3JlLnYzLkRuc1Jlc29sdXRpb25Db25maWdC",
            "CxgBkseG2AQDMy4wEk0KGXR5cGVkX2Ruc19yZXNvbHZlcl9jb25maWcYNyAB",
            "KAsyKi5lbnZveS5jb25maWcuY29yZS52My5UeXBlZEV4dGVuc2lvbkNvbmZp",
            "ZxI5ChV3YWl0X2Zvcl93YXJtX29uX2luaXQYNiABKAsyGi5nb29nbGUucHJv",
            "dG9idWYuQm9vbFZhbHVlEkQKEW91dGxpZXJfZGV0ZWN0aW9uGBMgASgLMiku",
            "ZW52b3kuY29uZmlnLmNsdXN0ZXIudjMuT3V0bGllckRldGVjdGlvbhI9ChBj",
            "bGVhbnVwX2ludGVydmFsGBQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0",
            "aW9uQgj6QgWqAQIqABI+ChR1cHN0cmVhbV9iaW5kX2NvbmZpZxgVIAEoCzIg",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLkJpbmRDb25maWcSSQoQbGJfc3Vic2V0",
            "X2NvbmZpZxgWIAEoCzIvLmVudm95LmNvbmZpZy5jbHVzdGVyLnYzLkNsdXN0",
            "ZXIuTGJTdWJzZXRDb25maWcSUAoTcmluZ19oYXNoX2xiX2NvbmZpZxgXIAEo",
            "CzIxLmVudm95LmNvbmZpZy5jbHVzdGVyLnYzLkNsdXN0ZXIuUmluZ0hhc2hM",
            "YkNvbmZpZ0gBEksKEG1hZ2xldl9sYl9jb25maWcYNCABKAsyLy5lbnZveS5j",
            "b25maWcuY2x1c3Rlci52My5DbHVzdGVyLk1hZ2xldkxiQ29uZmlnSAESVgoW",
            "b3JpZ2luYWxfZHN0X2xiX2NvbmZpZxgiIAEoCzI0LmVudm95LmNvbmZpZy5j",
            "bHVzdGVyLnYzLkNsdXN0ZXIuT3JpZ2luYWxEc3RMYkNvbmZpZ0gBElgKF2xl",
            "YXN0X3JlcXVlc3RfbGJfY29uZmlnGCUgASgLMjUuZW52b3kuY29uZmlnLmNs",
            "dXN0ZXIudjMuQ2x1c3Rlci5MZWFzdFJlcXVlc3RMYkNvbmZpZ0gBElQKFXJv",
            "dW5kX3JvYmluX2xiX2NvbmZpZxg4IAEoCzIzLmVudm95LmNvbmZpZy5jbHVz",
            "dGVyLnYzLkNsdXN0ZXIuUm91bmRSb2JpbkxiQ29uZmlnSAESSQoQY29tbW9u",
            "X2xiX2NvbmZpZxgbIAEoCzIvLmVudm95LmNvbmZpZy5jbHVzdGVyLnYzLkNs",
            "dXN0ZXIuQ29tbW9uTGJDb25maWcSPwoQdHJhbnNwb3J0X3NvY2tldBgYIAEo",
            "CzIlLmVudm95LmNvbmZpZy5jb3JlLnYzLlRyYW5zcG9ydFNvY2tldBIwCght",
            "ZXRhZGF0YRgZIAEoCzIeLmVudm95LmNvbmZpZy5jb3JlLnYzLk1ldGFkYXRh",
            "EmIKEnByb3RvY29sX3NlbGVjdGlvbhgaIAEoDjI5LmVudm95LmNvbmZpZy5j",
            "bHVzdGVyLnYzLkNsdXN0ZXIuQ2x1c3RlclByb3RvY29sU2VsZWN0aW9uQgsY",
            "AZLHhtgEAzMuMBJXCht1cHN0cmVhbV9jb25uZWN0aW9uX29wdGlvbnMYHiAB",
            "KAsyMi5lbnZveS5jb25maWcuY2x1c3Rlci52My5VcHN0cmVhbUNvbm5lY3Rp",
            "b25PcHRpb25zEjAKKGNsb3NlX2Nvbm5lY3Rpb25zX29uX2hvc3RfaGVhbHRo",
            "X2ZhaWx1cmUYHyABKAgSJQodaWdub3JlX2hlYWx0aF9vbl9ob3N0X3JlbW92",
            "YWwYICABKAgSMAoHZmlsdGVycxgoIAMoCzIfLmVudm95LmNvbmZpZy5jbHVz",
            "dGVyLnYzLkZpbHRlchJLChVsb2FkX2JhbGFuY2luZ19wb2xpY3kYKSABKAsy",
            "LC5lbnZveS5jb25maWcuY2x1c3Rlci52My5Mb2FkQmFsYW5jaW5nUG9saWN5",
            "EjYKCmxyc19zZXJ2ZXIYKiABKAsyIi5lbnZveS5jb25maWcuY29yZS52My5D",
            "b25maWdTb3VyY2USKgoVdHJhY2tfdGltZW91dF9idWRnZXRzGC8gASgIQgsY",
            "AZLHhtgEAzMuMBJDCg91cHN0cmVhbV9jb25maWcYMCABKAsyKi5lbnZveS5j",
            "b25maWcuY29yZS52My5UeXBlZEV4dGVuc2lvbkNvbmZpZxJHChN0cmFja19j",
            "bHVzdGVyX3N0YXRzGDEgASgLMiouZW52b3kuY29uZmlnLmNsdXN0ZXIudjMu",
            "VHJhY2tDbHVzdGVyU3RhdHMSTAoRcHJlY29ubmVjdF9wb2xpY3kYMiABKAsy",
            "MS5lbnZveS5jb25maWcuY2x1c3Rlci52My5DbHVzdGVyLlByZWNvbm5lY3RQ",
            "b2xpY3kSMQopY29ubmVjdGlvbl9wb29sX3Blcl9kb3duc3RyZWFtX2Nvbm5l",
            "Y3Rpb24YMyABKAgayAEKFFRyYW5zcG9ydFNvY2tldE1hdGNoEhUKBG5hbWUY",
            "ASABKAlCB/pCBHICEAESJgoFbWF0Y2gYAiABKAsyFy5nb29nbGUucHJvdG9i",
            "dWYuU3RydWN0Ej8KEHRyYW5zcG9ydF9zb2NrZXQYAyABKAsyJS5lbnZveS5j",
            "b25maWcuY29yZS52My5UcmFuc3BvcnRTb2NrZXQ6MJrFiB4rCillbnZveS5h",
            "cGkudjIuQ2x1c3Rlci5UcmFuc3BvcnRTb2NrZXRNYXRjaBqFAQoRQ3VzdG9t",
            "Q2x1c3RlclR5cGUSFQoEbmFtZRgBIAEoCUIH+kIEcgIQARIqCgx0eXBlZF9j",
            "b25maWcYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55Oi2axYgeKAomZW52",
            "b3kuYXBpLnYyLkNsdXN0ZXIuQ3VzdG9tQ2x1c3RlclR5cGUajgEKEEVkc0Ns",
            "dXN0ZXJDb25maWcSNgoKZWRzX2NvbmZpZxgBIAEoCzIiLmVudm95LmNvbmZp",
            "Zy5jb3JlLnYzLkNvbmZpZ1NvdXJjZRIUCgxzZXJ2aWNlX25hbWUYAiABKAk6",
            "LJrFiB4nCiVlbnZveS5hcGkudjIuQ2x1c3Rlci5FZHNDbHVzdGVyQ29uZmln",
            "Go4HCg5MYlN1YnNldENvbmZpZxJpCg9mYWxsYmFja19wb2xpY3kYASABKA4y",
            "Ri5lbnZveS5jb25maWcuY2x1c3Rlci52My5DbHVzdGVyLkxiU3Vic2V0Q29u",
            "ZmlnLkxiU3Vic2V0RmFsbGJhY2tQb2xpY3lCCPpCBYIBAhABEi8KDmRlZmF1",
            "bHRfc3Vic2V0GAIgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdBJaChBz",
            "dWJzZXRfc2VsZWN0b3JzGAMgAygLMkAuZW52b3kuY29uZmlnLmNsdXN0ZXIu",
            "djMuQ2x1c3Rlci5MYlN1YnNldENvbmZpZy5MYlN1YnNldFNlbGVjdG9yEh0K",
            "FWxvY2FsaXR5X3dlaWdodF9hd2FyZRgEIAEoCBIdChVzY2FsZV9sb2NhbGl0",
            "eV93ZWlnaHQYBSABKAgSFgoOcGFuaWNfbW9kZV9hbnkYBiABKAgSEwoLbGlz",
            "dF9hc19hbnkYByABKAgamwMKEExiU3Vic2V0U2VsZWN0b3ISDAoEa2V5cxgB",
            "IAMoCRIeChZzaW5nbGVfaG9zdF9wZXJfc3Vic2V0GAQgASgIEoIBCg9mYWxs",
            "YmFja19wb2xpY3kYAiABKA4yXy5lbnZveS5jb25maWcuY2x1c3Rlci52My5D",
            "bHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxiU3Vic2V0U2VsZWN0b3IuTGJTdWJz",
            "ZXRTZWxlY3RvckZhbGxiYWNrUG9saWN5Qgj6QgWCAQIQARIcChRmYWxsYmFj",
            "a19rZXlzX3N1YnNldBgDIAMoCSJ5Ch5MYlN1YnNldFNlbGVjdG9yRmFsbGJh",
            "Y2tQb2xpY3kSDwoLTk9UX0RFRklORUQQABIPCgtOT19GQUxMQkFDSxABEhAK",
            "DEFOWV9FTkRQT0lOVBACEhIKDkRFRkFVTFRfU1VCU0VUEAMSDwoLS0VZU19T",
            "VUJTRVQQBDo7msWIHjYKNGVudm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0",
            "Q29uZmlnLkxiU3Vic2V0U2VsZWN0b3IiTwoWTGJTdWJzZXRGYWxsYmFja1Bv",
            "bGljeRIPCgtOT19GQUxMQkFDSxAAEhAKDEFOWV9FTkRQT0lOVBABEhIKDkRF",
            "RkFVTFRfU1VCU0VUEAI6KprFiB4lCiNlbnZveS5hcGkudjIuQ2x1c3Rlci5M",
            "YlN1YnNldENvbmZpZxq0AQoPU2xvd1N0YXJ0Q29uZmlnEjQKEXNsb3dfc3Rh",
            "cnRfd2luZG93GAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjcK",
            "CmFnZ3Jlc3Npb24YAiABKAsyIy5lbnZveS5jb25maWcuY29yZS52My5SdW50",
            "aW1lRG91YmxlEjIKEm1pbl93ZWlnaHRfcGVyY2VudBgDIAEoCzIWLmVudm95",
            "LnR5cGUudjMuUGVyY2VudBphChJSb3VuZFJvYmluTGJDb25maWcSSwoRc2xv",
            "d19zdGFydF9jb25maWcYASABKAsyMC5lbnZveS5jb25maWcuY2x1c3Rlci52",
            "My5DbHVzdGVyLlNsb3dTdGFydENvbmZpZxqUAgoUTGVhc3RSZXF1ZXN0TGJD",
            "b25maWcSOwoMY2hvaWNlX2NvdW50GAEgASgLMhwuZ29vZ2xlLnByb3RvYnVm",
            "LlVJbnQzMlZhbHVlQgf6QgQqAigCEkAKE2FjdGl2ZV9yZXF1ZXN0X2JpYXMY",
            "AiABKAsyIy5lbnZveS5jb25maWcuY29yZS52My5SdW50aW1lRG91YmxlEksK",
            "EXNsb3dfc3RhcnRfY29uZmlnGAMgASgLMjAuZW52b3kuY29uZmlnLmNsdXN0",
            "ZXIudjMuQ2x1c3Rlci5TbG93U3RhcnRDb25maWc6MJrFiB4rCillbnZveS5h",
            "cGkudjIuQ2x1c3Rlci5MZWFzdFJlcXVlc3RMYkNvbmZpZxrhAgoQUmluZ0hh",
            "c2hMYkNvbmZpZxJDChFtaW5pbXVtX3Jpbmdfc2l6ZRgBIAEoCzIcLmdvb2ds",
            "ZS5wcm90b2J1Zi5VSW50NjRWYWx1ZUIK+kIHMgUYgICABBJfCg1oYXNoX2Z1",
            "bmN0aW9uGAMgASgOMj4uZW52b3kuY29uZmlnLmNsdXN0ZXIudjMuQ2x1c3Rl",
            "ci5SaW5nSGFzaExiQ29uZmlnLkhhc2hGdW5jdGlvbkII+kIFggECEAESQwoR",
            "bWF4aW11bV9yaW5nX3NpemUYBCABKAsyHC5nb29nbGUucHJvdG9idWYuVUlu",
            "dDY0VmFsdWVCCvpCBzIFGICAgAQiLgoMSGFzaEZ1bmN0aW9uEgsKB1hYX0hB",
            "U0gQABIRCg1NVVJNVVJfSEFTSF8yEAE6LJrFiB4nCiVlbnZveS5hcGkudjIu",
            "Q2x1c3Rlci5SaW5nSGFzaExiQ29uZmlnSgQIAhADGk4KDk1hZ2xldkxiQ29u",
            "ZmlnEjwKCnRhYmxlX3NpemUYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUlu",
            "dDY0VmFsdWVCCvpCBzIFGMuWsQIaeQoTT3JpZ2luYWxEc3RMYkNvbmZpZxIX",
            "Cg91c2VfaHR0cF9oZWFkZXIYASABKAgSGAoQaHR0cF9oZWFkZXJfbmFtZRgC",
            "IAEoCTovmsWIHioKKGVudm95LmFwaS52Mi5DbHVzdGVyLk9yaWdpbmFsRHN0",
            "TGJDb25maWcasgkKDkNvbW1vbkxiQ29uZmlnEjcKF2hlYWx0aHlfcGFuaWNf",
            "dGhyZXNob2xkGAEgASgLMhYuZW52b3kudHlwZS52My5QZXJjZW50EmEKFHpv",
            "bmVfYXdhcmVfbGJfY29uZmlnGAIgASgLMkEuZW52b3kuY29uZmlnLmNsdXN0",
            "ZXIudjMuQ2x1c3Rlci5Db21tb25MYkNvbmZpZy5ab25lQXdhcmVMYkNvbmZp",
            "Z0gAEm8KG2xvY2FsaXR5X3dlaWdodGVkX2xiX2NvbmZpZxgDIAEoCzJILmVu",
            "dm95LmNvbmZpZy5jbHVzdGVyLnYzLkNsdXN0ZXIuQ29tbW9uTGJDb25maWcu",
            "TG9jYWxpdHlXZWlnaHRlZExiQ29uZmlnSAASNgoTdXBkYXRlX21lcmdlX3dp",
            "bmRvdxgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhInCh9pZ25v",
            "cmVfbmV3X2hvc3RzX3VudGlsX2ZpcnN0X2hjGAUgASgIEiwKJGNsb3NlX2Nv",
            "bm5lY3Rpb25zX29uX2hvc3Rfc2V0X2NoYW5nZRgGIAEoCBJvChxjb25zaXN0",
            "ZW50X2hhc2hpbmdfbGJfY29uZmlnGAcgASgLMkkuZW52b3kuY29uZmlnLmNs",
            "dXN0ZXIudjMuQ2x1c3Rlci5Db21tb25MYkNvbmZpZy5Db25zaXN0ZW50SGFz",
            "aGluZ0xiQ29uZmlnEkMKFG92ZXJyaWRlX2hvc3Rfc3RhdHVzGAggASgLMiUu",
            "ZW52b3kuY29uZmlnLmNvcmUudjMuSGVhbHRoU3RhdHVzU2V0GtkBChFab25l",
            "QXdhcmVMYkNvbmZpZxIvCg9yb3V0aW5nX2VuYWJsZWQYASABKAsyFi5lbnZv",
            "eS50eXBlLnYzLlBlcmNlbnQSNgoQbWluX2NsdXN0ZXJfc2l6ZRgCIAEoCzIc",
            "Lmdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZRIdChVmYWlsX3RyYWZmaWNf",
            "b25fcGFuaWMYAyABKAg6PJrFiB43CjVlbnZveS5hcGkudjIuQ2x1c3Rlci5D",
            "b21tb25MYkNvbmZpZy5ab25lQXdhcmVMYkNvbmZpZxpfChhMb2NhbGl0eVdl",
            "aWdodGVkTGJDb25maWc6Q5rFiB4+CjxlbnZveS5hcGkudjIuQ2x1c3Rlci5D",
            "b21tb25MYkNvbmZpZy5Mb2NhbGl0eVdlaWdodGVkTGJDb25maWcaxwEKGUNv",
            "bnNpc3RlbnRIYXNoaW5nTGJDb25maWcSIAoYdXNlX2hvc3RuYW1lX2Zvcl9o",
            "YXNoaW5nGAEgASgIEkIKE2hhc2hfYmFsYW5jZV9mYWN0b3IYAiABKAsyHC5n",
            "b29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCB/pCBCoCKGQ6RJrFiB4/Cj1l",
            "bnZveS5hcGkudjIuQ2x1c3Rlci5Db21tb25MYkNvbmZpZy5Db25zaXN0ZW50",
            "SGFzaGluZ0xiQ29uZmlnOiqaxYgeJQojZW52b3kuYXBpLnYyLkNsdXN0ZXIu",
            "Q29tbW9uTGJDb25maWdCGwoZbG9jYWxpdHlfY29uZmlnX3NwZWNpZmllchq3",
            "AQoLUmVmcmVzaFJhdGUSQAoNYmFzZV9pbnRlcnZhbBgBIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbkIO+kILqgEICAEqBBDAhD0SPQoMbWF4X2lu",
            "dGVydmFsGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgz6Qgmq",
            "AQYqBBDAhD06J5rFiB4iCiBlbnZveS5hcGkudjIuQ2x1c3Rlci5SZWZyZXNo",
            "UmF0ZRrMAQoQUHJlY29ubmVjdFBvbGljeRJcCh1wZXJfdXBzdHJlYW1fcHJl",
            "Y29ubmVjdF9yYXRpbxgBIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5Eb3VibGVW",
            "YWx1ZUIX+kIUEhIZAAAAAAAACEApAAAAAAAA8D8SWgobcHJlZGljdGl2ZV9w",
            "cmVjb25uZWN0X3JhdGlvGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRvdWJs",
            "ZVZhbHVlQhf6QhQSEhkAAAAAAAAIQCkAAAAAAADwPxpaCiJUeXBlZEV4dGVu",
            "c2lvblByb3RvY29sT3B0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2YWx1",
            "ZRgCIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5Bbnk6AjgBIlcKDURpc2NvdmVy",
            "eVR5cGUSCgoGU1RBVElDEAASDgoKU1RSSUNUX0ROUxABEg8KC0xPR0lDQUxf",
            "RE5TEAISBwoDRURTEAMSEAoMT1JJR0lOQUxfRFNUEAQipAEKCExiUG9saWN5",
            "Eg8KC1JPVU5EX1JPQklOEAASEQoNTEVBU1RfUkVRVUVTVBABEg0KCVJJTkdf",
            "SEFTSBACEgoKBlJBTkRPTRADEgoKBk1BR0xFVhAFEhQKEENMVVNURVJfUFJP",
            "VklERUQQBhIgChxMT0FEX0JBTEFOQ0lOR19QT0xJQ1lfQ09ORklHEAciBAgE",
            "EAQqD09SSUdJTkFMX0RTVF9MQiJQCg9EbnNMb29rdXBGYW1pbHkSCAoEQVVU",
            "TxAAEgsKB1Y0X09OTFkQARILCgdWNl9PTkxZEAISEAoMVjRfUFJFRkVSUkVE",
            "EAMSBwoDQUxMEAQiVAoYQ2x1c3RlclByb3RvY29sU2VsZWN0aW9uEhsKF1VT",
            "RV9DT05GSUdVUkVEX1BST1RPQ09MEAASGwoXVVNFX0RPV05TVFJFQU1fUFJP",
            "VE9DT0wQATobmsWIHhYKFGVudm95LmFwaS52Mi5DbHVzdGVyQhgKFmNsdXN0",
            "ZXJfZGlzY292ZXJ5X3R5cGVCCwoJbGJfY29uZmlnSgQIDBANSgQIDxAQSgQI",
            "BxAISgQICxAMSgQIIxAkUgVob3N0c1ILdGxzX2NvbnRleHRSGmV4dGVuc2lv",
            "bl9wcm90b2NvbF9vcHRpb25zIroCChNMb2FkQmFsYW5jaW5nUG9saWN5EkUK",
            "CHBvbGljaWVzGAEgAygLMjMuZW52b3kuY29uZmlnLmNsdXN0ZXIudjMuTG9h",
            "ZEJhbGFuY2luZ1BvbGljeS5Qb2xpY3kasgEKBlBvbGljeRJKChZ0eXBlZF9l",
            "eHRlbnNpb25fY29uZmlnGAQgASgLMiouZW52b3kuY29uZmlnLmNvcmUudjMu",
            "VHlwZWRFeHRlbnNpb25Db25maWc6LprFiB4pCidlbnZveS5hcGkudjIuTG9h",
            "ZEJhbGFuY2luZ1BvbGljeS5Qb2xpY3lKBAgCEANKBAgBEAJKBAgDEARSBmNv",
            "bmZpZ1IEbmFtZVIMdHlwZWRfY29uZmlnOieaxYgeIgogZW52b3kuYXBpLnYy",
            "LkxvYWRCYWxhbmNpbmdQb2xpY3kicwoSVXBzdHJlYW1CaW5kQ29uZmlnEjUK",
            "DnNvdXJjZV9hZGRyZXNzGAEgASgLMh0uZW52b3kuY29uZmlnLmNvcmUudjMu",
            "QWRkcmVzczommsWIHiEKH2Vudm95LmFwaS52Mi5VcHN0cmVhbUJpbmRDb25m",
            "aWcivwEKGVVwc3RyZWFtQ29ubmVjdGlvbk9wdGlvbnMSOQoNdGNwX2tlZXBh",
            "bGl2ZRgBIAEoCzIiLmVudm95LmNvbmZpZy5jb3JlLnYzLlRjcEtlZXBhbGl2",
            "ZRI4CjBzZXRfbG9jYWxfaW50ZXJmYWNlX25hbWVfb25fdXBzdHJlYW1fY29u",
            "bmVjdGlvbnMYAiABKAg6LZrFiB4oCiZlbnZveS5hcGkudjIuVXBzdHJlYW1D",
            "b25uZWN0aW9uT3B0aW9ucyJMChFUcmFja0NsdXN0ZXJTdGF0cxIXCg90aW1l",
            "b3V0X2J1ZGdldHMYASABKAgSHgoWcmVxdWVzdF9yZXNwb25zZV9zaXplcxgC",
            "IAEoCEKJAQolaW8uZW52b3lwcm94eS5lbnZveS5jb25maWcuY2x1c3Rlci52",
            "M0IMQ2x1c3RlclByb3RvUAFaSGdpdGh1Yi5jb20vZW52b3lwcm94eS9nby1j",
            "b250cm9sLXBsYW5lL2Vudm95L2NvbmZpZy9jbHVzdGVyL3YzO2NsdXN0ZXJ2",
            "M7qAyNEGAhACYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Cluster.V3.CircuitBreakerReflection.Descriptor, global::Envoy.Config.Cluster.V3.FilterReflection.Descriptor, global::Envoy.Config.Cluster.V3.OutlierDetectionReflection.Descriptor, global::Envoy.Config.Core.V3.AddressReflection.Descriptor, global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ConfigSourceReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Core.V3.HealthCheckReflection.Descriptor, global::Envoy.Config.Core.V3.ProtocolReflection.Descriptor, global::Envoy.Config.Core.V3.ResolverReflection.Descriptor, global::Envoy.Config.Endpoint.V3.EndpointReflection.Descriptor, global::Envoy.Type.V3.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Core.V3.CollectionEntryReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.SecurityReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.ClusterCollection), global::Envoy.Config.Cluster.V3.ClusterCollection.Parser, new[]{ "Entries" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster), global::Envoy.Config.Cluster.V3.Cluster.Parser, new[]{ "TransportSocketMatches", "Name", "AltStatName", "Type", "ClusterType", "EdsClusterConfig", "ConnectTimeout", "PerConnectionBufferLimitBytes", "LbPolicy", "LoadAssignment", "HealthChecks", "MaxRequestsPerConnection", "CircuitBreakers", "UpstreamHttpProtocolOptions", "CommonHttpProtocolOptions", "HttpProtocolOptions", "Http2ProtocolOptions", "TypedExtensionProtocolOptions", "DnsRefreshRate", "DnsFailureRefreshRate", "RespectDnsTtl", "DnsLookupFamily", "DnsResolvers", "UseTcpForDnsLookups", "DnsResolutionConfig", "TypedDnsResolverConfig", "WaitForWarmOnInit", "OutlierDetection", "CleanupInterval", "UpstreamBindConfig", "LbSubsetConfig", "RingHashLbConfig", "MaglevLbConfig", "OriginalDstLbConfig", "LeastRequestLbConfig", "RoundRobinLbConfig", "CommonLbConfig", "TransportSocket", "Metadata", "ProtocolSelection", "UpstreamConnectionOptions", "CloseConnectionsOnHostHealthFailure", "IgnoreHealthOnHostRemoval", "Filters", "LoadBalancingPolicy", "LrsServer", "TrackTimeoutBudgets", "UpstreamConfig", "TrackClusterStats", "PreconnectPolicy", "ConnectionPoolPerDownstreamConnection" }, new[]{ "ClusterDiscoveryType", "LbConfig" }, new[]{ typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.DiscoveryType), typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy), typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily), typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch), global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch.Parser, new[]{ "Name", "Match", "TransportSocket" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType), global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType.Parser, new[]{ "Name", "TypedConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig.Parser, new[]{ "EdsConfig", "ServiceName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Parser, new[]{ "FallbackPolicy", "DefaultSubset", "SubsetSelectors", "LocalityWeightAware", "ScaleLocalityWeight", "PanicModeAny", "ListAsAny" }, null, new[]{ typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector), global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser, new[]{ "Keys", "SingleHostPerSubset", "FallbackPolicy", "FallbackKeysSubset" }, null, new[]{ typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig.Parser, new[]{ "SlowStartWindow", "Aggression", "MinWeightPercent" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig.Parser, new[]{ "SlowStartConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig.Parser, new[]{ "ChoiceCount", "ActiveRequestBias", "SlowStartConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Parser, new[]{ "MinimumRingSize", "HashFunction", "MaximumRingSize" }, null, new[]{ typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig.Parser, new[]{ "TableSize" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig.Parser, new[]{ "UseHttpHeader", "HttpHeaderName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Parser, new[]{ "HealthyPanicThreshold", "ZoneAwareLbConfig", "LocalityWeightedLbConfig", "UpdateMergeWindow", "IgnoreNewHostsUntilFirstHc", "CloseConnectionsOnHostSetChange", "ConsistentHashingLbConfig", "OverrideHostStatus" }, new[]{ "LocalityConfigSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig.Parser, new[]{ "RoutingEnabled", "MinClusterSize", "FailTrafficOnPanic" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig), global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig.Parser, new[]{ "UseHostnameForHashing", "HashBalanceFactor" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate), global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate.Parser, new[]{ "BaseInterval", "MaxInterval" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy), global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy.Parser, new[]{ "PerUpstreamPreconnectRatio", "PredictivePreconnectRatio" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.LoadBalancingPolicy), global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Parser, new[]{ "Policies" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy), global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy.Parser, new[]{ "TypedExtensionConfig" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.UpstreamBindConfig), global::Envoy.Config.Cluster.V3.UpstreamBindConfig.Parser, new[]{ "SourceAddress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions), global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions.Parser, new[]{ "TcpKeepalive", "SetLocalInterfaceNameOnUpstreamConnections" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Cluster.V3.TrackClusterStats), global::Envoy.Config.Cluster.V3.TrackClusterStats.Parser, new[]{ "TimeoutBudgets", "RequestResponseSizes" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Cluster list collections. Entries are *Cluster* resources or references.
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class ClusterCollection : pb::IMessage<ClusterCollection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClusterCollection> _parser = new pb::MessageParser<ClusterCollection>(() => new ClusterCollection());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClusterCollection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterCollection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterCollection(ClusterCollection other) : this() {
      entries_ = other.entries_ != null ? other.entries_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterCollection Clone() {
      return new ClusterCollection(this);
    }

    /// <summary>Field number for the "entries" field.</summary>
    public const int EntriesFieldNumber = 1;
    private global::Xds.Core.V3.CollectionEntry entries_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Xds.Core.V3.CollectionEntry Entries {
      get { return entries_; }
      set {
        entries_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClusterCollection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClusterCollection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Entries, other.Entries)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (entries_ != null) hash ^= Entries.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (entries_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Entries);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (entries_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Entries);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (entries_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Entries);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClusterCollection other) {
      if (other == null) {
        return;
      }
      if (other.entries_ != null) {
        if (entries_ == null) {
          Entries = new global::Xds.Core.V3.CollectionEntry();
        }
        Entries.MergeFrom(other.Entries);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (entries_ == null) {
              Entries = new global::Xds.Core.V3.CollectionEntry();
            }
            input.ReadMessage(Entries);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (entries_ == null) {
              Entries = new global::Xds.Core.V3.CollectionEntry();
            }
            input.ReadMessage(Entries);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Configuration for a single upstream cluster.
  /// [#next-free-field: 57]
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster(Cluster other) : this() {
      transportSocketMatches_ = other.transportSocketMatches_.Clone();
      name_ = other.name_;
      altStatName_ = other.altStatName_;
      edsClusterConfig_ = other.edsClusterConfig_ != null ? other.edsClusterConfig_.Clone() : null;
      connectTimeout_ = other.connectTimeout_ != null ? other.connectTimeout_.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      lbPolicy_ = other.lbPolicy_;
      loadAssignment_ = other.loadAssignment_ != null ? other.loadAssignment_.Clone() : null;
      healthChecks_ = other.healthChecks_.Clone();
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      circuitBreakers_ = other.circuitBreakers_ != null ? other.circuitBreakers_.Clone() : null;
      upstreamHttpProtocolOptions_ = other.upstreamHttpProtocolOptions_ != null ? other.upstreamHttpProtocolOptions_.Clone() : null;
      commonHttpProtocolOptions_ = other.commonHttpProtocolOptions_ != null ? other.commonHttpProtocolOptions_.Clone() : null;
      httpProtocolOptions_ = other.httpProtocolOptions_ != null ? other.httpProtocolOptions_.Clone() : null;
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      typedExtensionProtocolOptions_ = other.typedExtensionProtocolOptions_.Clone();
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      dnsFailureRefreshRate_ = other.dnsFailureRefreshRate_ != null ? other.dnsFailureRefreshRate_.Clone() : null;
      respectDnsTtl_ = other.respectDnsTtl_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsResolvers_ = other.dnsResolvers_.Clone();
      useTcpForDnsLookups_ = other.useTcpForDnsLookups_;
      dnsResolutionConfig_ = other.dnsResolutionConfig_ != null ? other.dnsResolutionConfig_.Clone() : null;
      typedDnsResolverConfig_ = other.typedDnsResolverConfig_ != null ? other.typedDnsResolverConfig_.Clone() : null;
      WaitForWarmOnInit = other.WaitForWarmOnInit;
      outlierDetection_ = other.outlierDetection_ != null ? other.outlierDetection_.Clone() : null;
      cleanupInterval_ = other.cleanupInterval_ != null ? other.cleanupInterval_.Clone() : null;
      upstreamBindConfig_ = other.upstreamBindConfig_ != null ? other.upstreamBindConfig_.Clone() : null;
      lbSubsetConfig_ = other.lbSubsetConfig_ != null ? other.lbSubsetConfig_.Clone() : null;
      commonLbConfig_ = other.commonLbConfig_ != null ? other.commonLbConfig_.Clone() : null;
      transportSocket_ = other.transportSocket_ != null ? other.transportSocket_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      protocolSelection_ = other.protocolSelection_;
      upstreamConnectionOptions_ = other.upstreamConnectionOptions_ != null ? other.upstreamConnectionOptions_.Clone() : null;
      closeConnectionsOnHostHealthFailure_ = other.closeConnectionsOnHostHealthFailure_;
      ignoreHealthOnHostRemoval_ = other.ignoreHealthOnHostRemoval_;
      filters_ = other.filters_.Clone();
      loadBalancingPolicy_ = other.loadBalancingPolicy_ != null ? other.loadBalancingPolicy_.Clone() : null;
      lrsServer_ = other.lrsServer_ != null ? other.lrsServer_.Clone() : null;
      trackTimeoutBudgets_ = other.trackTimeoutBudgets_;
      upstreamConfig_ = other.upstreamConfig_ != null ? other.upstreamConfig_.Clone() : null;
      trackClusterStats_ = other.trackClusterStats_ != null ? other.trackClusterStats_.Clone() : null;
      preconnectPolicy_ = other.preconnectPolicy_ != null ? other.preconnectPolicy_.Clone() : null;
      connectionPoolPerDownstreamConnection_ = other.connectionPoolPerDownstreamConnection_;
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          ClusterType = other.ClusterType.Clone();
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          RingHashLbConfig = other.RingHashLbConfig.Clone();
          break;
        case LbConfigOneofCase.MaglevLbConfig:
          MaglevLbConfig = other.MaglevLbConfig.Clone();
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          OriginalDstLbConfig = other.OriginalDstLbConfig.Clone();
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          LeastRequestLbConfig = other.LeastRequestLbConfig.Clone();
          break;
        case LbConfigOneofCase.RoundRobinLbConfig:
          RoundRobinLbConfig = other.RoundRobinLbConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "transport_socket_matches" field.</summary>
    public const int TransportSocketMatchesFieldNumber = 43;
    private static readonly pb::FieldCodec<global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch> _repeated_transportSocketMatches_codec
        = pb::FieldCodec.ForMessage(346, global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch> transportSocketMatches_ = new pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch>();
    /// <summary>
    /// Configuration to use different transport sockets for different endpoints.
    /// The entry of *envoy.transport_socket_match* in the
    /// :ref:`LbEndpoint.Metadata &lt;envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`
    /// is used to match against the transport sockets as they appear in the list. The first
    /// :ref:`match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
    /// For example, with the following match
    ///
    /// .. code-block:: yaml
    ///
    ///  transport_socket_matches:
    ///  - name: "enableMTLS"
    ///    match:
    ///      acceptMTLS: true
    ///    transport_socket:
    ///      name: envoy.transport_sockets.tls
    ///      config: { ... } # tls socket configuration
    ///  - name: "defaultToPlaintext"
    ///    match: {}
    ///    transport_socket:
    ///      name: envoy.transport_sockets.raw_buffer
    ///
    /// Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
    /// having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
    ///
    /// If a :ref:`socket match &lt;envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
    /// criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
    /// socket match in case above.
    ///
    /// If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
    /// *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
    /// *transport_socket* specified in this cluster.
    ///
    /// This field allows gradual and flexible transport socket configuration changes.
    ///
    /// The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
    /// an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
    /// "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
    /// has "acceptPlaintext": "true" metadata information.
    ///
    /// Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
    /// traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
    /// *TransportSocketMatch* in this field. Other client Envoys receive CDS without
    /// *transport_socket_match* set, and still send plain text traffic to the same cluster.
    ///
    /// This field can be used to specify custom transport socket configurations for health
    /// checks by adding matching key/value pairs in a health check's
    /// :ref:`transport socket match criteria &lt;envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
    ///
    /// [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.TransportSocketMatch> TransportSocketMatches {
      get { return transportSocketMatches_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Supplies the name of the cluster which must be unique across all clusters.
    /// The cluster name is used when emitting
    /// :ref:`statistics &lt;config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    /// &lt;envoy_v3_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
    /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alt_stat_name" field.</summary>
    public const int AltStatNameFieldNumber = 28;
    private string altStatName_ = "";
    /// <summary>
    /// An optional alternative to the cluster name to be used for observability. This name is used
    /// emitting stats for the cluster and access logging the cluster name. This will appear as
    /// additional information in configuration dumps of a cluster's current status as
    /// :ref:`observability_name &lt;envoy_v3_api_field_admin.v3.ClusterStatus.observability_name>`
    /// and as an additional tag "upstream_cluster.name" while tracing. Note: Any ``:`` in the name
    /// will be converted to ``_`` when emitting statistics. This should not be confused with
    /// :ref:`Router Filter Header &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AltStatName {
      get { return altStatName_; }
      set {
        altStatName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    /// <summary>
    /// The :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.DiscoveryType Type {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type ? (global::Envoy.Config.Cluster.V3.Cluster.Types.DiscoveryType) clusterDiscoveryType_ : global::Envoy.Config.Cluster.V3.Cluster.Types.DiscoveryType.Static; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
      }
    }

    /// <summary>Field number for the "cluster_type" field.</summary>
    public const int ClusterTypeFieldNumber = 38;
    /// <summary>
    /// The custom cluster type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType ClusterType {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType ? (global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType) clusterDiscoveryType_ : null; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = value == null ? ClusterDiscoveryTypeOneofCase.None : ClusterDiscoveryTypeOneofCase.ClusterType;
      }
    }

    /// <summary>Field number for the "eds_cluster_config" field.</summary>
    public const int EdsClusterConfigFieldNumber = 3;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig edsClusterConfig_;
    /// <summary>
    /// Configuration to use for EDS updates for the Cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig EdsClusterConfig {
      get { return edsClusterConfig_; }
      set {
        edsClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "connect_timeout" field.</summary>
    public const int ConnectTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectTimeout_;
    /// <summary>
    /// The timeout for new network connections to hosts in the cluster.
    /// If not set, a default value of 5s will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectTimeout {
      get { return connectTimeout_; }
      set {
        connectTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the cluster’s connections read and write buffers. If
    /// unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "lb_policy" field.</summary>
    public const int LbPolicyFieldNumber = 6;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy lbPolicy_ = global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin;
    /// <summary>
    /// The :ref:`load balancer type &lt;arch_overview_load_balancing_types>` to use
    /// when picking a host in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy LbPolicy {
      get { return lbPolicy_; }
      set {
        lbPolicy_ = value;
      }
    }

    /// <summary>Field number for the "load_assignment" field.</summary>
    public const int LoadAssignmentFieldNumber = 33;
    private global::Envoy.Config.Endpoint.V3.ClusterLoadAssignment loadAssignment_;
    /// <summary>
    /// Setting this is required for specifying members of
    /// :ref:`STATIC&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
    /// This field supersedes the *hosts* field in the v2 API.
    ///
    /// .. attention::
    ///
    ///   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
    ///   :ref:`endpoint assignments&lt;envoy_v3_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Endpoint.V3.ClusterLoadAssignment LoadAssignment {
      get { return loadAssignment_; }
      set {
        loadAssignment_ = value;
      }
    }

    /// <summary>Field number for the "health_checks" field.</summary>
    public const int HealthChecksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HealthCheck> _repeated_healthChecks_codec
        = pb::FieldCodec.ForMessage(66, global::Envoy.Config.Core.V3.HealthCheck.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HealthCheck> healthChecks_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HealthCheck>();
    /// <summary>
    /// Optional :ref:`active health checking &lt;arch_overview_health_checking>`
    /// configuration for the cluster. If no
    /// configuration is specified no health checking will be done and all cluster
    /// members will be considered healthy at all times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HealthCheck> HealthChecks {
      get { return healthChecks_; }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for a single upstream connection. This parameter
    /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
    /// implementations. If not specified, there is no limit. Setting this
    /// parameter to 1 will effectively disable keep alive.
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of the :ref:`max_requests_per_connection &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_requests_per_connection>` field.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }


    /// <summary>Field number for the "circuit_breakers" field.</summary>
    public const int CircuitBreakersFieldNumber = 10;
    private global::Envoy.Config.Cluster.V3.CircuitBreakers circuitBreakers_;
    /// <summary>
    /// Optional :ref:`circuit breaking &lt;arch_overview_circuit_break>` for the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.CircuitBreakers CircuitBreakers {
      get { return circuitBreakers_; }
      set {
        circuitBreakers_ = value;
      }
    }

    /// <summary>Field number for the "upstream_http_protocol_options" field.</summary>
    public const int UpstreamHttpProtocolOptionsFieldNumber = 46;
    private global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions upstreamHttpProtocolOptions_;
    /// <summary>
    /// HTTP protocol options that are applied only to upstream HTTP connections.
    /// These options apply to all HTTP versions.
    /// This has been deprecated in favor of
    /// :ref:`upstream_http_protocol_options &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
    /// in the :ref:`http_protocol_options &lt;envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
    /// upstream_http_protocol_options can be set via the cluster's
    /// :ref:`extension_protocol_options&lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
    /// See :ref:`upstream_http_protocol_options
    /// &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
    /// for example usage.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions UpstreamHttpProtocolOptions {
      get { return upstreamHttpProtocolOptions_; }
      set {
        upstreamHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "common_http_protocol_options" field.</summary>
    public const int CommonHttpProtocolOptionsFieldNumber = 29;
    private global::Envoy.Config.Core.V3.HttpProtocolOptions commonHttpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP requests upstream. These options will be applicable to
    /// both HTTP1 and HTTP2 requests.
    /// This has been deprecated in favor of
    /// :ref:`common_http_protocol_options &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.common_http_protocol_options>`
    /// in the :ref:`http_protocol_options &lt;envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
    /// common_http_protocol_options can be set via the cluster's
    /// :ref:`extension_protocol_options&lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
    /// See :ref:`upstream_http_protocol_options
    /// &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
    /// for example usage.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.HttpProtocolOptions CommonHttpProtocolOptions {
      get { return commonHttpProtocolOptions_; }
      set {
        commonHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 13;
    private global::Envoy.Config.Core.V3.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP1 requests.
    /// This has been deprecated in favor of http_protocol_options fields in the
    /// :ref:`http_protocol_options &lt;envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
    /// http_protocol_options can be set via the cluster's
    /// :ref:`extension_protocol_options&lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
    /// See :ref:`upstream_http_protocol_options
    /// &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
    /// for example usage.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 14;
    private global::Envoy.Config.Core.V3.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Even if default HTTP2 protocol options are desired, this field must be
    /// set so that Envoy will assume that the upstream supports HTTP/2 when
    /// making new HTTP connection pool connections. Currently, Envoy only
    /// supports prior knowledge for upstream connections. Even if TLS is used
    /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    /// connections to happen over plain text.
    /// This has been deprecated in favor of http2_protocol_options fields in the
    /// :ref:`http_protocol_options &lt;envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>`
    /// message. http2_protocol_options can be set via the cluster's
    /// :ref:`extension_protocol_options&lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
    /// See :ref:`upstream_http_protocol_options
    /// &lt;envoy_v3_api_field_extensions.upstreams.http.v3.HttpProtocolOptions.upstream_http_protocol_options>`
    /// for example usage.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "typed_extension_protocol_options" field.</summary>
    public const int TypedExtensionProtocolOptionsFieldNumber = 36;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedExtensionProtocolOptions_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 290);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedExtensionProtocolOptions_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The extension_protocol_options field is used to provide extension-specific protocol options
    /// for upstream connections. The key should match the extension filter name, such as
    /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    /// specific options.
    /// [#next-major-version: make this a list of typed extensions.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedExtensionProtocolOptions {
      get { return typedExtensionProtocolOptions_; }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// If the DNS refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used as the cluster’s DNS refresh
    /// rate. The value configured must be at least 1ms. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "dns_failure_refresh_rate" field.</summary>
    public const int DnsFailureRefreshRateFieldNumber = 44;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate dnsFailureRefreshRate_;
    /// <summary>
    /// If the DNS failure refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this is used as the cluster’s DNS refresh rate when requests are failing. If this setting is
    /// not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
    /// other than :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
    /// :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
    /// ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate DnsFailureRefreshRate {
      get { return dnsFailureRefreshRate_; }
      set {
        dnsFailureRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "respect_dns_ttl" field.</summary>
    public const int RespectDnsTtlFieldNumber = 39;
    private bool respectDnsTtl_;
    /// <summary>
    /// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
    /// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
    /// resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RespectDnsTtl {
      get { return respectDnsTtl_; }
      set {
        respectDnsTtl_ = value;
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 17;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS IP address resolution policy. If this setting is not specified, the
    /// value defaults to
    /// :ref:`AUTO&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolvers" field.</summary>
    public const int DnsResolversFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.Address> _repeated_dnsResolvers_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Config.Core.V3.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.Address> dnsResolvers_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.Address>();
    /// <summary>
    /// If DNS resolvers are specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used to specify the cluster’s dns resolvers.
    /// If this setting is not specified, the value defaults to the default
    /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
    /// other than
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// This field is deprecated in favor of *dns_resolution_config*
    /// which aggregates all of the DNS resolver configuration in a single message.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.Address> DnsResolvers {
      get { return dnsResolvers_; }
    }

    /// <summary>Field number for the "use_tcp_for_dns_lookups" field.</summary>
    public const int UseTcpForDnsLookupsFieldNumber = 45;
    private bool useTcpForDnsLookups_;
    /// <summary>
    /// Always use TCP queries instead of UDP queries for DNS lookups.
    /// This field is deprecated in favor of *dns_resolution_config*
    /// which aggregates all of the DNS resolver configuration in a single message.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseTcpForDnsLookups {
      get { return useTcpForDnsLookups_; }
      set {
        useTcpForDnsLookups_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolution_config" field.</summary>
    public const int DnsResolutionConfigFieldNumber = 53;
    private global::Envoy.Config.Core.V3.DnsResolutionConfig dnsResolutionConfig_;
    /// <summary>
    /// DNS resolution configuration which includes the underlying dns resolver addresses and options.
    /// This field is deprecated in favor of
    /// :ref:`typed_dns_resolver_config &lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_dns_resolver_config>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DnsResolutionConfig DnsResolutionConfig {
      get { return dnsResolutionConfig_; }
      set {
        dnsResolutionConfig_ = value;
      }
    }

    /// <summary>Field number for the "typed_dns_resolver_config" field.</summary>
    public const int TypedDnsResolverConfigFieldNumber = 55;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig typedDnsResolverConfig_;
    /// <summary>
    /// DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
    /// or any other DNS resolver types and the related parameters.
    /// For example, an object of
    /// :ref:`CaresDnsResolverConfig &lt;envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
    /// can be packed into this *typed_dns_resolver_config*. This configuration replaces the
    /// :ref:`dns_resolution_config &lt;envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
    /// configuration.
    /// During the transition period when both *dns_resolution_config* and *typed_dns_resolver_config* exists,
    /// when *typed_dns_resolver_config* is in place, Envoy will use it and ignore *dns_resolution_config*.
    /// When *typed_dns_resolver_config* is missing, the default behavior is in place.
    /// [#extension-category: envoy.network.dns_resolver]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig TypedDnsResolverConfig {
      get { return typedDnsResolverConfig_; }
      set {
        typedDnsResolverConfig_ = value;
      }
    }

    /// <summary>Field number for the "wait_for_warm_on_init" field.</summary>
    public const int WaitForWarmOnInitFieldNumber = 54;
    private static readonly pb::FieldCodec<bool?> _single_waitForWarmOnInit_codec = pb::FieldCodec.ForStructWrapper<bool>(434);
    private bool? waitForWarmOnInit_;
    /// <summary>
    /// Optional configuration for having cluster readiness block on warm-up. Currently, only applicable for
    /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`.
    /// If true, cluster readiness blocks on warm-up. If false, the cluster will complete
    /// initialization whether or not warm-up has completed. Defaults to true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? WaitForWarmOnInit {
      get { return waitForWarmOnInit_; }
      set {
        waitForWarmOnInit_ = value;
      }
    }


    /// <summary>Field number for the "outlier_detection" field.</summary>
    public const int OutlierDetectionFieldNumber = 19;
    private global::Envoy.Config.Cluster.V3.OutlierDetection outlierDetection_;
    /// <summary>
    /// If specified, outlier detection will be enabled for this upstream cluster.
    /// Each of the configuration values can be overridden via
    /// :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.OutlierDetection OutlierDetection {
      get { return outlierDetection_; }
      set {
        outlierDetection_ = value;
      }
    }

    /// <summary>Field number for the "cleanup_interval" field.</summary>
    public const int CleanupIntervalFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Duration cleanupInterval_;
    /// <summary>
    /// The interval for removing stale hosts from a cluster type
    /// :ref:`ORIGINAL_DST&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
    /// Hosts are considered stale if they have not been used
    /// as upstream destinations during this interval. New hosts are added
    /// to original destination clusters on demand as new connections are
    /// redirected to Envoy, causing the number of hosts in the cluster to
    /// grow over time. Hosts that are not stale (they are actively used as
    /// destinations) are kept in the cluster, which allows connections to
    /// them remain open, saving the latency that would otherwise be spent
    /// on opening new connections. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`ORIGINAL_DST&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration CleanupInterval {
      get { return cleanupInterval_; }
      set {
        cleanupInterval_ = value;
      }
    }

    /// <summary>Field number for the "upstream_bind_config" field.</summary>
    public const int UpstreamBindConfigFieldNumber = 21;
    private global::Envoy.Config.Core.V3.BindConfig upstreamBindConfig_;
    /// <summary>
    /// Optional configuration used to bind newly established upstream connections.
    /// This overrides any bind_config specified in the bootstrap proto.
    /// If the address and port are empty, no bind will be performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.BindConfig UpstreamBindConfig {
      get { return upstreamBindConfig_; }
      set {
        upstreamBindConfig_ = value;
      }
    }

    /// <summary>Field number for the "lb_subset_config" field.</summary>
    public const int LbSubsetConfigFieldNumber = 22;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig lbSubsetConfig_;
    /// <summary>
    /// Configuration for load balancing subsetting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig LbSubsetConfig {
      get { return lbSubsetConfig_; }
      set {
        lbSubsetConfig_ = value;
      }
    }

    /// <summary>Field number for the "ring_hash_lb_config" field.</summary>
    public const int RingHashLbConfigFieldNumber = 23;
    /// <summary>
    /// Optional configuration for the Ring Hash load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig RingHashLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RingHashLbConfig;
      }
    }

    /// <summary>Field number for the "maglev_lb_config" field.</summary>
    public const int MaglevLbConfigFieldNumber = 52;
    /// <summary>
    /// Optional configuration for the Maglev load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig MaglevLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.MaglevLbConfig;
      }
    }

    /// <summary>Field number for the "original_dst_lb_config" field.</summary>
    public const int OriginalDstLbConfigFieldNumber = 34;
    /// <summary>
    /// Optional configuration for the Original Destination load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig OriginalDstLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.OriginalDstLbConfig;
      }
    }

    /// <summary>Field number for the "least_request_lb_config" field.</summary>
    public const int LeastRequestLbConfigFieldNumber = 37;
    /// <summary>
    /// Optional configuration for the LeastRequest load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig LeastRequestLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.LeastRequestLbConfig;
      }
    }

    /// <summary>Field number for the "round_robin_lb_config" field.</summary>
    public const int RoundRobinLbConfigFieldNumber = 56;
    /// <summary>
    /// Optional configuration for the RoundRobin load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig RoundRobinLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RoundRobinLbConfig;
      }
    }

    /// <summary>Field number for the "common_lb_config" field.</summary>
    public const int CommonLbConfigFieldNumber = 27;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig commonLbConfig_;
    /// <summary>
    /// Common configuration for all load balancer implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig CommonLbConfig {
      get { return commonLbConfig_; }
      set {
        commonLbConfig_ = value;
      }
    }

    /// <summary>Field number for the "transport_socket" field.</summary>
    public const int TransportSocketFieldNumber = 24;
    private global::Envoy.Config.Core.V3.TransportSocket transportSocket_;
    /// <summary>
    /// Optional custom transport socket implementation to use for upstream connections.
    /// To setup TLS, set a transport socket with name `envoy.transport_sockets.tls` and
    /// :ref:`UpstreamTlsContexts &lt;envoy_v3_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the `typed_config`.
    /// If no transport socket configuration is specified, new connections
    /// will be set up with plaintext.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TransportSocket TransportSocket {
      get { return transportSocket_; }
      set {
        transportSocket_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 25;
    private global::Envoy.Config.Core.V3.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information about the
    /// cluster. It can be used for stats, logging, and varying filter behavior.
    /// Fields should use reverse DNS notation to denote which entity within Envoy
    /// will need the information. For instance, if the metadata is intended for
    /// the Router filter, the filter name should be specified as *envoy.filters.http.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "protocol_selection" field.</summary>
    public const int ProtocolSelectionFieldNumber = 26;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection protocolSelection_ = global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol;
    /// <summary>
    /// Determines how Envoy selects the protocol used to speak to upstream hosts.
    /// This has been deprecated in favor of setting explicit protocol selection
    /// in the :ref:`http_protocol_options
    /// &lt;envoy_v3_api_msg_extensions.upstreams.http.v3.HttpProtocolOptions>` message.
    /// http_protocol_options can be set via the cluster's
    /// :ref:`extension_protocol_options&lt;envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection ProtocolSelection {
      get { return protocolSelection_; }
      set {
        protocolSelection_ = value;
      }
    }

    /// <summary>Field number for the "upstream_connection_options" field.</summary>
    public const int UpstreamConnectionOptionsFieldNumber = 30;
    private global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions upstreamConnectionOptions_;
    /// <summary>
    /// Optional options for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions UpstreamConnectionOptions {
      get { return upstreamConnectionOptions_; }
      set {
        upstreamConnectionOptions_ = value;
      }
    }

    /// <summary>Field number for the "close_connections_on_host_health_failure" field.</summary>
    public const int CloseConnectionsOnHostHealthFailureFieldNumber = 31;
    private bool closeConnectionsOnHostHealthFailure_;
    /// <summary>
    /// If an upstream host becomes unhealthy (as determined by the configured health checks
    /// or outlier detection), immediately close all connections to the failed host.
    ///
    /// .. note::
    ///
    ///   This is currently only supported for connections created by tcp_proxy.
    ///
    /// .. note::
    ///
    ///   The current implementation of this feature closes all connections immediately when
    ///   the unhealthy status is detected. If there are a large number of connections open
    ///   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
    ///   time exclusively closing these connections, and not processing any other traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CloseConnectionsOnHostHealthFailure {
      get { return closeConnectionsOnHostHealthFailure_; }
      set {
        closeConnectionsOnHostHealthFailure_ = value;
      }
    }

    /// <summary>Field number for the "ignore_health_on_host_removal" field.</summary>
    public const int IgnoreHealthOnHostRemovalFieldNumber = 32;
    private bool ignoreHealthOnHostRemoval_;
    /// <summary>
    /// If set to true, Envoy will ignore the health value of a host when processing its removal
    /// from service discovery. This means that if active health checking is used, Envoy will *not*
    /// wait for the endpoint to go unhealthy before removing it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IgnoreHealthOnHostRemoval {
      get { return ignoreHealthOnHostRemoval_; }
      set {
        ignoreHealthOnHostRemoval_ = value;
      }
    }

    /// <summary>Field number for the "filters" field.</summary>
    public const int FiltersFieldNumber = 40;
    private static readonly pb::FieldCodec<global::Envoy.Config.Cluster.V3.Filter> _repeated_filters_codec
        = pb::FieldCodec.ForMessage(322, global::Envoy.Config.Cluster.V3.Filter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Filter> filters_ = new pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Filter>();
    /// <summary>
    /// An (optional) network filter chain, listed in the order the filters should be applied.
    /// The chain will be applied to all outgoing connections that Envoy makes to the upstream
    /// servers of this cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Filter> Filters {
      get { return filters_; }
    }

    /// <summary>Field number for the "load_balancing_policy" field.</summary>
    public const int LoadBalancingPolicyFieldNumber = 41;
    private global::Envoy.Config.Cluster.V3.LoadBalancingPolicy loadBalancingPolicy_;
    /// <summary>
    /// If this field is set and is supported by the client, it will supersede the value of
    /// :ref:`lb_policy&lt;envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.LoadBalancingPolicy LoadBalancingPolicy {
      get { return loadBalancingPolicy_; }
      set {
        loadBalancingPolicy_ = value;
      }
    }

    /// <summary>Field number for the "lrs_server" field.</summary>
    public const int LrsServerFieldNumber = 42;
    private global::Envoy.Config.Core.V3.ConfigSource lrsServer_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// If present, tells the client where to send load reports via LRS. If not present, the
    /// client will fall back to a client-side default, which may be either (a) don't send any
    /// load reports or (b) send load reports for all clusters to a single default server
    /// (which may be configured in the bootstrap file).
    ///
    /// Note that if multiple clusters point to the same LRS server, the client may choose to
    /// create a separate stream for each cluster or it may choose to coalesce the data for
    /// multiple clusters onto a single stream. Either way, the client must make sure to send
    /// the data for any given cluster on no more than one stream.
    ///
    /// [#next-major-version: In the v3 API, we should consider restructuring this somehow,
    /// maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
    /// from the LRS stream here.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.ConfigSource LrsServer {
      get { return lrsServer_; }
      set {
        lrsServer_ = value;
      }
    }

    /// <summary>Field number for the "track_timeout_budgets" field.</summary>
    public const int TrackTimeoutBudgetsFieldNumber = 47;
    private bool trackTimeoutBudgets_;
    /// <summary>
    /// If track_timeout_budgets is true, the :ref:`timeout budget histograms
    /// &lt;config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
    /// request. These show what percentage of a request's per try and global timeout was used. A value
    /// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
    /// of 100 would indicate that the request took the entirety of the timeout given to it.
    ///
    /// .. attention::
    ///
    ///   This field has been deprecated in favor of `timeout_budgets`, part of
    ///   :ref:`track_cluster_stats &lt;envoy_v3_api_field_config.cluster.v3.Cluster.track_cluster_stats>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TrackTimeoutBudgets {
      get { return trackTimeoutBudgets_; }
      set {
        trackTimeoutBudgets_ = value;
      }
    }

    /// <summary>Field number for the "upstream_config" field.</summary>
    public const int UpstreamConfigFieldNumber = 48;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig upstreamConfig_;
    /// <summary>
    /// Optional customization and configuration of upstream connection pool, and upstream type.
    ///
    /// Currently this field only applies for HTTP traffic but is designed for eventual use for custom
    /// TCP upstreams.
    ///
    /// For HTTP traffic, Envoy will generally take downstream HTTP and send it upstream as upstream
    /// HTTP, using the http connection pool and the codec from `http2_protocol_options`
    ///
    /// For routes where CONNECT termination is configured, Envoy will take downstream CONNECT
    /// requests and forward the CONNECT payload upstream over raw TCP using the tcp connection pool.
    ///
    /// The default pool used is the generic connection pool which creates the HTTP upstream for most
    /// HTTP requests, and the TCP upstream if CONNECT termination is configured.
    ///
    /// If users desire custom connection pool or upstream behavior, for example terminating
    /// CONNECT only if a custom filter indicates it is appropriate, the custom factories
    /// can be registered and configured here.
    /// [#extension-category: envoy.upstreams]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig UpstreamConfig {
      get { return upstreamConfig_; }
      set {
        upstreamConfig_ = value;
      }
    }

    /// <summary>Field number for the "track_cluster_stats" field.</summary>
    public const int TrackClusterStatsFieldNumber = 49;
    private global::Envoy.Config.Cluster.V3.TrackClusterStats trackClusterStats_;
    /// <summary>
    /// Configuration to track optional cluster stats.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.TrackClusterStats TrackClusterStats {
      get { return trackClusterStats_; }
      set {
        trackClusterStats_ = value;
      }
    }

    /// <summary>Field number for the "preconnect_policy" field.</summary>
    public const int PreconnectPolicyFieldNumber = 50;
    private global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy preconnectPolicy_;
    /// <summary>
    /// Preconnect configuration for this cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy PreconnectPolicy {
      get { return preconnectPolicy_; }
      set {
        preconnectPolicy_ = value;
      }
    }

    /// <summary>Field number for the "connection_pool_per_downstream_connection" field.</summary>
    public const int ConnectionPoolPerDownstreamConnectionFieldNumber = 51;
    private bool connectionPoolPerDownstreamConnection_;
    /// <summary>
    /// If `connection_pool_per_downstream_connection` is true, the cluster will use a separate
    /// connection pool for every downstream connection
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ConnectionPoolPerDownstreamConnection {
      get { return connectionPoolPerDownstreamConnection_; }
      set {
        connectionPoolPerDownstreamConnection_ = value;
      }
    }

    private object clusterDiscoveryType_;
    /// <summary>Enum of possible cases for the "cluster_discovery_type" oneof.</summary>
    public enum ClusterDiscoveryTypeOneofCase {
      None = 0,
      Type = 2,
      ClusterType = 38,
    }
    private ClusterDiscoveryTypeOneofCase clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterDiscoveryTypeOneofCase ClusterDiscoveryTypeCase {
      get { return clusterDiscoveryTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClusterDiscoveryType() {
      clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
      clusterDiscoveryType_ = null;
    }

    private object lbConfig_;
    /// <summary>Enum of possible cases for the "lb_config" oneof.</summary>
    public enum LbConfigOneofCase {
      None = 0,
      RingHashLbConfig = 23,
      MaglevLbConfig = 52,
      OriginalDstLbConfig = 34,
      LeastRequestLbConfig = 37,
      RoundRobinLbConfig = 56,
    }
    private LbConfigOneofCase lbConfigCase_ = LbConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LbConfigOneofCase LbConfigCase {
      get { return lbConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLbConfig() {
      lbConfigCase_ = LbConfigOneofCase.None;
      lbConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!transportSocketMatches_.Equals(other.transportSocketMatches_)) return false;
      if (Name != other.Name) return false;
      if (AltStatName != other.AltStatName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(ClusterType, other.ClusterType)) return false;
      if (!object.Equals(EdsClusterConfig, other.EdsClusterConfig)) return false;
      if (!object.Equals(ConnectTimeout, other.ConnectTimeout)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (LbPolicy != other.LbPolicy) return false;
      if (!object.Equals(LoadAssignment, other.LoadAssignment)) return false;
      if(!healthChecks_.Equals(other.healthChecks_)) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      if (!object.Equals(CircuitBreakers, other.CircuitBreakers)) return false;
      if (!object.Equals(UpstreamHttpProtocolOptions, other.UpstreamHttpProtocolOptions)) return false;
      if (!object.Equals(CommonHttpProtocolOptions, other.CommonHttpProtocolOptions)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!TypedExtensionProtocolOptions.Equals(other.TypedExtensionProtocolOptions)) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (!object.Equals(DnsFailureRefreshRate, other.DnsFailureRefreshRate)) return false;
      if (RespectDnsTtl != other.RespectDnsTtl) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if(!dnsResolvers_.Equals(other.dnsResolvers_)) return false;
      if (UseTcpForDnsLookups != other.UseTcpForDnsLookups) return false;
      if (!object.Equals(DnsResolutionConfig, other.DnsResolutionConfig)) return false;
      if (!object.Equals(TypedDnsResolverConfig, other.TypedDnsResolverConfig)) return false;
      if (WaitForWarmOnInit != other.WaitForWarmOnInit) return false;
      if (!object.Equals(OutlierDetection, other.OutlierDetection)) return false;
      if (!object.Equals(CleanupInterval, other.CleanupInterval)) return false;
      if (!object.Equals(UpstreamBindConfig, other.UpstreamBindConfig)) return false;
      if (!object.Equals(LbSubsetConfig, other.LbSubsetConfig)) return false;
      if (!object.Equals(RingHashLbConfig, other.RingHashLbConfig)) return false;
      if (!object.Equals(MaglevLbConfig, other.MaglevLbConfig)) return false;
      if (!object.Equals(OriginalDstLbConfig, other.OriginalDstLbConfig)) return false;
      if (!object.Equals(LeastRequestLbConfig, other.LeastRequestLbConfig)) return false;
      if (!object.Equals(RoundRobinLbConfig, other.RoundRobinLbConfig)) return false;
      if (!object.Equals(CommonLbConfig, other.CommonLbConfig)) return false;
      if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (ProtocolSelection != other.ProtocolSelection) return false;
      if (!object.Equals(UpstreamConnectionOptions, other.UpstreamConnectionOptions)) return false;
      if (CloseConnectionsOnHostHealthFailure != other.CloseConnectionsOnHostHealthFailure) return false;
      if (IgnoreHealthOnHostRemoval != other.IgnoreHealthOnHostRemoval) return false;
      if(!filters_.Equals(other.filters_)) return false;
      if (!object.Equals(LoadBalancingPolicy, other.LoadBalancingPolicy)) return false;
      if (!object.Equals(LrsServer, other.LrsServer)) return false;
      if (TrackTimeoutBudgets != other.TrackTimeoutBudgets) return false;
      if (!object.Equals(UpstreamConfig, other.UpstreamConfig)) return false;
      if (!object.Equals(TrackClusterStats, other.TrackClusterStats)) return false;
      if (!object.Equals(PreconnectPolicy, other.PreconnectPolicy)) return false;
      if (ConnectionPoolPerDownstreamConnection != other.ConnectionPoolPerDownstreamConnection) return false;
      if (ClusterDiscoveryTypeCase != other.ClusterDiscoveryTypeCase) return false;
      if (LbConfigCase != other.LbConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= transportSocketMatches_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (AltStatName.Length != 0) hash ^= AltStatName.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) hash ^= Type.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) hash ^= ClusterType.GetHashCode();
      if (edsClusterConfig_ != null) hash ^= EdsClusterConfig.GetHashCode();
      if (connectTimeout_ != null) hash ^= ConnectTimeout.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (LbPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin) hash ^= LbPolicy.GetHashCode();
      if (loadAssignment_ != null) hash ^= LoadAssignment.GetHashCode();
      hash ^= healthChecks_.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (circuitBreakers_ != null) hash ^= CircuitBreakers.GetHashCode();
      if (upstreamHttpProtocolOptions_ != null) hash ^= UpstreamHttpProtocolOptions.GetHashCode();
      if (commonHttpProtocolOptions_ != null) hash ^= CommonHttpProtocolOptions.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      hash ^= TypedExtensionProtocolOptions.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (dnsFailureRefreshRate_ != null) hash ^= DnsFailureRefreshRate.GetHashCode();
      if (RespectDnsTtl != false) hash ^= RespectDnsTtl.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      hash ^= dnsResolvers_.GetHashCode();
      if (UseTcpForDnsLookups != false) hash ^= UseTcpForDnsLookups.GetHashCode();
      if (dnsResolutionConfig_ != null) hash ^= DnsResolutionConfig.GetHashCode();
      if (typedDnsResolverConfig_ != null) hash ^= TypedDnsResolverConfig.GetHashCode();
      if (waitForWarmOnInit_ != null) hash ^= WaitForWarmOnInit.GetHashCode();
      if (outlierDetection_ != null) hash ^= OutlierDetection.GetHashCode();
      if (cleanupInterval_ != null) hash ^= CleanupInterval.GetHashCode();
      if (upstreamBindConfig_ != null) hash ^= UpstreamBindConfig.GetHashCode();
      if (lbSubsetConfig_ != null) hash ^= LbSubsetConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) hash ^= RingHashLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) hash ^= MaglevLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) hash ^= OriginalDstLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) hash ^= LeastRequestLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) hash ^= RoundRobinLbConfig.GetHashCode();
      if (commonLbConfig_ != null) hash ^= CommonLbConfig.GetHashCode();
      if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (ProtocolSelection != global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) hash ^= ProtocolSelection.GetHashCode();
      if (upstreamConnectionOptions_ != null) hash ^= UpstreamConnectionOptions.GetHashCode();
      if (CloseConnectionsOnHostHealthFailure != false) hash ^= CloseConnectionsOnHostHealthFailure.GetHashCode();
      if (IgnoreHealthOnHostRemoval != false) hash ^= IgnoreHealthOnHostRemoval.GetHashCode();
      hash ^= filters_.GetHashCode();
      if (loadBalancingPolicy_ != null) hash ^= LoadBalancingPolicy.GetHashCode();
      if (lrsServer_ != null) hash ^= LrsServer.GetHashCode();
      if (TrackTimeoutBudgets != false) hash ^= TrackTimeoutBudgets.GetHashCode();
      if (upstreamConfig_ != null) hash ^= UpstreamConfig.GetHashCode();
      if (trackClusterStats_ != null) hash ^= TrackClusterStats.GetHashCode();
      if (preconnectPolicy_ != null) hash ^= PreconnectPolicy.GetHashCode();
      if (ConnectionPoolPerDownstreamConnection != false) hash ^= ConnectionPoolPerDownstreamConnection.GetHashCode();
      hash ^= (int) clusterDiscoveryTypeCase_;
      hash ^= (int) lbConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      healthChecks_.WriteTo(output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (IgnoreHealthOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(IgnoreHealthOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(OriginalDstLbConfig);
      }
      typedExtensionProtocolOptions_.WriteTo(output, _map_typedExtensionProtocolOptions_codec);
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        output.WriteRawTag(170, 2);
        output.WriteMessage(LeastRequestLbConfig);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(ClusterType);
      }
      if (RespectDnsTtl != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(RespectDnsTtl);
      }
      filters_.WriteTo(output, _repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(LrsServer);
      }
      transportSocketMatches_.WriteTo(output, _repeated_transportSocketMatches_codec);
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(232, 2);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        output.WriteRawTag(242, 2);
        output.WriteMessage(UpstreamHttpProtocolOptions);
      }
      if (TrackTimeoutBudgets != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(TrackTimeoutBudgets);
      }
      if (upstreamConfig_ != null) {
        output.WriteRawTag(130, 3);
        output.WriteMessage(UpstreamConfig);
      }
      if (trackClusterStats_ != null) {
        output.WriteRawTag(138, 3);
        output.WriteMessage(TrackClusterStats);
      }
      if (preconnectPolicy_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(PreconnectPolicy);
      }
      if (ConnectionPoolPerDownstreamConnection != false) {
        output.WriteRawTag(152, 3);
        output.WriteBool(ConnectionPoolPerDownstreamConnection);
      }
      if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) {
        output.WriteRawTag(162, 3);
        output.WriteMessage(MaglevLbConfig);
      }
      if (dnsResolutionConfig_ != null) {
        output.WriteRawTag(170, 3);
        output.WriteMessage(DnsResolutionConfig);
      }
      if (waitForWarmOnInit_ != null) {
        _single_waitForWarmOnInit_codec.WriteTagAndValue(output, WaitForWarmOnInit);
      }
      if (typedDnsResolverConfig_ != null) {
        output.WriteRawTag(186, 3);
        output.WriteMessage(TypedDnsResolverConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) {
        output.WriteRawTag(194, 3);
        output.WriteMessage(RoundRobinLbConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(ref output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      healthChecks_.WriteTo(ref output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(ref output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(ref output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (IgnoreHealthOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(IgnoreHealthOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(OriginalDstLbConfig);
      }
      typedExtensionProtocolOptions_.WriteTo(ref output, _map_typedExtensionProtocolOptions_codec);
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        output.WriteRawTag(170, 2);
        output.WriteMessage(LeastRequestLbConfig);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(ClusterType);
      }
      if (RespectDnsTtl != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(RespectDnsTtl);
      }
      filters_.WriteTo(ref output, _repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        output.WriteRawTag(210, 2);
        output.WriteMessage(LrsServer);
      }
      transportSocketMatches_.WriteTo(ref output, _repeated_transportSocketMatches_codec);
      if (dnsFailureRefreshRate_ != null) {
        output.WriteRawTag(226, 2);
        output.WriteMessage(DnsFailureRefreshRate);
      }
      if (UseTcpForDnsLookups != false) {
        output.WriteRawTag(232, 2);
        output.WriteBool(UseTcpForDnsLookups);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        output.WriteRawTag(242, 2);
        output.WriteMessage(UpstreamHttpProtocolOptions);
      }
      if (TrackTimeoutBudgets != false) {
        output.WriteRawTag(248, 2);
        output.WriteBool(TrackTimeoutBudgets);
      }
      if (upstreamConfig_ != null) {
        output.WriteRawTag(130, 3);
        output.WriteMessage(UpstreamConfig);
      }
      if (trackClusterStats_ != null) {
        output.WriteRawTag(138, 3);
        output.WriteMessage(TrackClusterStats);
      }
      if (preconnectPolicy_ != null) {
        output.WriteRawTag(146, 3);
        output.WriteMessage(PreconnectPolicy);
      }
      if (ConnectionPoolPerDownstreamConnection != false) {
        output.WriteRawTag(152, 3);
        output.WriteBool(ConnectionPoolPerDownstreamConnection);
      }
      if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) {
        output.WriteRawTag(162, 3);
        output.WriteMessage(MaglevLbConfig);
      }
      if (dnsResolutionConfig_ != null) {
        output.WriteRawTag(170, 3);
        output.WriteMessage(DnsResolutionConfig);
      }
      if (waitForWarmOnInit_ != null) {
        _single_waitForWarmOnInit_codec.WriteTagAndValue(ref output, WaitForWarmOnInit);
      }
      if (typedDnsResolverConfig_ != null) {
        output.WriteRawTag(186, 3);
        output.WriteMessage(TypedDnsResolverConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) {
        output.WriteRawTag(194, 3);
        output.WriteMessage(RoundRobinLbConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += transportSocketMatches_.CalculateSize(_repeated_transportSocketMatches_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (AltStatName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AltStatName);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ClusterType);
      }
      if (edsClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LbPolicy);
      }
      if (loadAssignment_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadAssignment);
      }
      size += healthChecks_.CalculateSize(_repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CircuitBreakers);
      }
      if (upstreamHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamHttpProtocolOptions);
      }
      if (commonHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonHttpProtocolOptions);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      size += typedExtensionProtocolOptions_.CalculateSize(_map_typedExtensionProtocolOptions_codec);
      if (dnsRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (dnsFailureRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsFailureRefreshRate);
      }
      if (RespectDnsTtl != false) {
        size += 2 + 1;
      }
      if (DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      size += dnsResolvers_.CalculateSize(_repeated_dnsResolvers_codec);
      if (UseTcpForDnsLookups != false) {
        size += 2 + 1;
      }
      if (dnsResolutionConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsResolutionConfig);
      }
      if (typedDnsResolverConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TypedDnsResolverConfig);
      }
      if (waitForWarmOnInit_ != null) {
        size += _single_waitForWarmOnInit_codec.CalculateSizeWithTag(WaitForWarmOnInit);
      }
      if (outlierDetection_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RingHashLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaglevLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OriginalDstLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LeastRequestLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RoundRobinLbConfig);
      }
      if (commonLbConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonLbConfig);
      }
      if (transportSocket_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
      }
      if (metadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolSelection);
      }
      if (upstreamConnectionOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        size += 2 + 1;
      }
      if (IgnoreHealthOnHostRemoval != false) {
        size += 2 + 1;
      }
      size += filters_.CalculateSize(_repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadBalancingPolicy);
      }
      if (lrsServer_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LrsServer);
      }
      if (TrackTimeoutBudgets != false) {
        size += 2 + 1;
      }
      if (upstreamConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamConfig);
      }
      if (trackClusterStats_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TrackClusterStats);
      }
      if (preconnectPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PreconnectPolicy);
      }
      if (ConnectionPoolPerDownstreamConnection != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      transportSocketMatches_.Add(other.transportSocketMatches_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.AltStatName.Length != 0) {
        AltStatName = other.AltStatName;
      }
      if (other.edsClusterConfig_ != null) {
        if (edsClusterConfig_ == null) {
          EdsClusterConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig();
        }
        EdsClusterConfig.MergeFrom(other.EdsClusterConfig);
      }
      if (other.connectTimeout_ != null) {
        if (connectTimeout_ == null) {
          ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectTimeout.MergeFrom(other.ConnectTimeout);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.LbPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy.RoundRobin) {
        LbPolicy = other.LbPolicy;
      }
      if (other.loadAssignment_ != null) {
        if (loadAssignment_ == null) {
          LoadAssignment = new global::Envoy.Config.Endpoint.V3.ClusterLoadAssignment();
        }
        LoadAssignment.MergeFrom(other.LoadAssignment);
      }
      healthChecks_.Add(other.healthChecks_);
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      if (other.circuitBreakers_ != null) {
        if (circuitBreakers_ == null) {
          CircuitBreakers = new global::Envoy.Config.Cluster.V3.CircuitBreakers();
        }
        CircuitBreakers.MergeFrom(other.CircuitBreakers);
      }
      if (other.upstreamHttpProtocolOptions_ != null) {
        if (upstreamHttpProtocolOptions_ == null) {
          UpstreamHttpProtocolOptions = new global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions();
        }
        UpstreamHttpProtocolOptions.MergeFrom(other.UpstreamHttpProtocolOptions);
      }
      if (other.commonHttpProtocolOptions_ != null) {
        if (commonHttpProtocolOptions_ == null) {
          CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
        }
        CommonHttpProtocolOptions.MergeFrom(other.CommonHttpProtocolOptions);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      typedExtensionProtocolOptions_.Add(other.typedExtensionProtocolOptions_);
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.dnsFailureRefreshRate_ != null) {
        if (dnsFailureRefreshRate_ == null) {
          DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
        }
        DnsFailureRefreshRate.MergeFrom(other.DnsFailureRefreshRate);
      }
      if (other.RespectDnsTtl != false) {
        RespectDnsTtl = other.RespectDnsTtl;
      }
      if (other.DnsLookupFamily != global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      dnsResolvers_.Add(other.dnsResolvers_);
      if (other.UseTcpForDnsLookups != false) {
        UseTcpForDnsLookups = other.UseTcpForDnsLookups;
      }
      if (other.dnsResolutionConfig_ != null) {
        if (dnsResolutionConfig_ == null) {
          DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
        }
        DnsResolutionConfig.MergeFrom(other.DnsResolutionConfig);
      }
      if (other.typedDnsResolverConfig_ != null) {
        if (typedDnsResolverConfig_ == null) {
          TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        TypedDnsResolverConfig.MergeFrom(other.TypedDnsResolverConfig);
      }
      if (other.waitForWarmOnInit_ != null) {
        if (waitForWarmOnInit_ == null || other.WaitForWarmOnInit != false) {
          WaitForWarmOnInit = other.WaitForWarmOnInit;
        }
      }
      if (other.outlierDetection_ != null) {
        if (outlierDetection_ == null) {
          OutlierDetection = new global::Envoy.Config.Cluster.V3.OutlierDetection();
        }
        OutlierDetection.MergeFrom(other.OutlierDetection);
      }
      if (other.cleanupInterval_ != null) {
        if (cleanupInterval_ == null) {
          CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        CleanupInterval.MergeFrom(other.CleanupInterval);
      }
      if (other.upstreamBindConfig_ != null) {
        if (upstreamBindConfig_ == null) {
          UpstreamBindConfig = new global::Envoy.Config.Core.V3.BindConfig();
        }
        UpstreamBindConfig.MergeFrom(other.UpstreamBindConfig);
      }
      if (other.lbSubsetConfig_ != null) {
        if (lbSubsetConfig_ == null) {
          LbSubsetConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig();
        }
        LbSubsetConfig.MergeFrom(other.LbSubsetConfig);
      }
      if (other.commonLbConfig_ != null) {
        if (commonLbConfig_ == null) {
          CommonLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig();
        }
        CommonLbConfig.MergeFrom(other.CommonLbConfig);
      }
      if (other.transportSocket_ != null) {
        if (transportSocket_ == null) {
          TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
        }
        TransportSocket.MergeFrom(other.TransportSocket);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Config.Core.V3.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.ProtocolSelection != global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        ProtocolSelection = other.ProtocolSelection;
      }
      if (other.upstreamConnectionOptions_ != null) {
        if (upstreamConnectionOptions_ == null) {
          UpstreamConnectionOptions = new global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions();
        }
        UpstreamConnectionOptions.MergeFrom(other.UpstreamConnectionOptions);
      }
      if (other.CloseConnectionsOnHostHealthFailure != false) {
        CloseConnectionsOnHostHealthFailure = other.CloseConnectionsOnHostHealthFailure;
      }
      if (other.IgnoreHealthOnHostRemoval != false) {
        IgnoreHealthOnHostRemoval = other.IgnoreHealthOnHostRemoval;
      }
      filters_.Add(other.filters_);
      if (other.loadBalancingPolicy_ != null) {
        if (loadBalancingPolicy_ == null) {
          LoadBalancingPolicy = new global::Envoy.Config.Cluster.V3.LoadBalancingPolicy();
        }
        LoadBalancingPolicy.MergeFrom(other.LoadBalancingPolicy);
      }
      if (other.lrsServer_ != null) {
        if (lrsServer_ == null) {
          LrsServer = new global::Envoy.Config.Core.V3.ConfigSource();
        }
        LrsServer.MergeFrom(other.LrsServer);
      }
      if (other.TrackTimeoutBudgets != false) {
        TrackTimeoutBudgets = other.TrackTimeoutBudgets;
      }
      if (other.upstreamConfig_ != null) {
        if (upstreamConfig_ == null) {
          UpstreamConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        UpstreamConfig.MergeFrom(other.UpstreamConfig);
      }
      if (other.trackClusterStats_ != null) {
        if (trackClusterStats_ == null) {
          TrackClusterStats = new global::Envoy.Config.Cluster.V3.TrackClusterStats();
        }
        TrackClusterStats.MergeFrom(other.TrackClusterStats);
      }
      if (other.preconnectPolicy_ != null) {
        if (preconnectPolicy_ == null) {
          PreconnectPolicy = new global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy();
        }
        PreconnectPolicy.MergeFrom(other.PreconnectPolicy);
      }
      if (other.ConnectionPoolPerDownstreamConnection != false) {
        ConnectionPoolPerDownstreamConnection = other.ConnectionPoolPerDownstreamConnection;
      }
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          if (ClusterType == null) {
            ClusterType = new global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType();
          }
          ClusterType.MergeFrom(other.ClusterType);
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          if (RingHashLbConfig == null) {
            RingHashLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig();
          }
          RingHashLbConfig.MergeFrom(other.RingHashLbConfig);
          break;
        case LbConfigOneofCase.MaglevLbConfig:
          if (MaglevLbConfig == null) {
            MaglevLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig();
          }
          MaglevLbConfig.MergeFrom(other.MaglevLbConfig);
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          if (OriginalDstLbConfig == null) {
            OriginalDstLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig();
          }
          OriginalDstLbConfig.MergeFrom(other.OriginalDstLbConfig);
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          if (LeastRequestLbConfig == null) {
            LeastRequestLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig();
          }
          LeastRequestLbConfig.MergeFrom(other.LeastRequestLbConfig);
          break;
        case LbConfigOneofCase.RoundRobinLbConfig:
          if (RoundRobinLbConfig == null) {
            RoundRobinLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig();
          }
          RoundRobinLbConfig.MergeFrom(other.RoundRobinLbConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            clusterDiscoveryType_ = input.ReadEnum();
            clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              EdsClusterConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(EdsClusterConfig);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectTimeout);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            LbPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              CircuitBreakers = new global::Envoy.Config.Cluster.V3.CircuitBreakers();
            }
            input.ReadMessage(CircuitBreakers);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 136: {
            DnsLookupFamily = (global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              OutlierDetection = new global::Envoy.Config.Cluster.V3.OutlierDetection();
            }
            input.ReadMessage(OutlierDetection);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(CleanupInterval);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              UpstreamBindConfig = new global::Envoy.Config.Core.V3.BindConfig();
            }
            input.ReadMessage(UpstreamBindConfig);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              LbSubsetConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(LbSubsetConfig);
            break;
          }
          case 186: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
            }
            input.ReadMessage(TransportSocket);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 208: {
            ProtocolSelection = (global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              CommonLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(CommonLbConfig);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              UpstreamConnectionOptions = new global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions();
            }
            input.ReadMessage(UpstreamConnectionOptions);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            IgnoreHealthOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              LoadAssignment = new global::Envoy.Config.Endpoint.V3.ClusterLoadAssignment();
            }
            input.ReadMessage(LoadAssignment);
            break;
          }
          case 274: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
              subBuilder.MergeFrom(OriginalDstLbConfig);
            }
            input.ReadMessage(subBuilder);
            OriginalDstLbConfig = subBuilder;
            break;
          }
          case 290: {
            typedExtensionProtocolOptions_.AddEntriesFrom(input, _map_typedExtensionProtocolOptions_codec);
            break;
          }
          case 298: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
              subBuilder.MergeFrom(LeastRequestLbConfig);
            }
            input.ReadMessage(subBuilder);
            LeastRequestLbConfig = subBuilder;
            break;
          }
          case 306: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType();
            if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
              subBuilder.MergeFrom(ClusterType);
            }
            input.ReadMessage(subBuilder);
            ClusterType = subBuilder;
            break;
          }
          case 312: {
            RespectDnsTtl = input.ReadBool();
            break;
          }
          case 322: {
            filters_.AddEntriesFrom(input, _repeated_filters_codec);
            break;
          }
          case 330: {
            if (loadBalancingPolicy_ == null) {
              LoadBalancingPolicy = new global::Envoy.Config.Cluster.V3.LoadBalancingPolicy();
            }
            input.ReadMessage(LoadBalancingPolicy);
            break;
          }
          case 338: {
            if (lrsServer_ == null) {
              LrsServer = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(LrsServer);
            break;
          }
          case 346: {
            transportSocketMatches_.AddEntriesFrom(input, _repeated_transportSocketMatches_codec);
            break;
          }
          case 354: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 360: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 370: {
            if (upstreamHttpProtocolOptions_ == null) {
              UpstreamHttpProtocolOptions = new global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions();
            }
            input.ReadMessage(UpstreamHttpProtocolOptions);
            break;
          }
          case 376: {
            TrackTimeoutBudgets = input.ReadBool();
            break;
          }
          case 386: {
            if (upstreamConfig_ == null) {
              UpstreamConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(UpstreamConfig);
            break;
          }
          case 394: {
            if (trackClusterStats_ == null) {
              TrackClusterStats = new global::Envoy.Config.Cluster.V3.TrackClusterStats();
            }
            input.ReadMessage(TrackClusterStats);
            break;
          }
          case 402: {
            if (preconnectPolicy_ == null) {
              PreconnectPolicy = new global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy();
            }
            input.ReadMessage(PreconnectPolicy);
            break;
          }
          case 408: {
            ConnectionPoolPerDownstreamConnection = input.ReadBool();
            break;
          }
          case 418: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) {
              subBuilder.MergeFrom(MaglevLbConfig);
            }
            input.ReadMessage(subBuilder);
            MaglevLbConfig = subBuilder;
            break;
          }
          case 426: {
            if (dnsResolutionConfig_ == null) {
              DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
            }
            input.ReadMessage(DnsResolutionConfig);
            break;
          }
          case 434: {
            bool? value = _single_waitForWarmOnInit_codec.Read(input);
            if (waitForWarmOnInit_ == null || value != false) {
              WaitForWarmOnInit = value;
            }
            break;
          }
          case 442: {
            if (typedDnsResolverConfig_ == null) {
              TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedDnsResolverConfig);
            break;
          }
          case 450: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) {
              subBuilder.MergeFrom(RoundRobinLbConfig);
            }
            input.ReadMessage(subBuilder);
            RoundRobinLbConfig = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            clusterDiscoveryType_ = input.ReadEnum();
            clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              EdsClusterConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(EdsClusterConfig);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectTimeout);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(ref input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            LbPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(ref input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(ref input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              CircuitBreakers = new global::Envoy.Config.Cluster.V3.CircuitBreakers();
            }
            input.ReadMessage(CircuitBreakers);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Config.Core.V3.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Config.Core.V3.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 136: {
            DnsLookupFamily = (global::Envoy.Config.Cluster.V3.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(ref input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              OutlierDetection = new global::Envoy.Config.Cluster.V3.OutlierDetection();
            }
            input.ReadMessage(OutlierDetection);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(CleanupInterval);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              UpstreamBindConfig = new global::Envoy.Config.Core.V3.BindConfig();
            }
            input.ReadMessage(UpstreamBindConfig);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              LbSubsetConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(LbSubsetConfig);
            break;
          }
          case 186: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
            }
            input.ReadMessage(TransportSocket);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 208: {
            ProtocolSelection = (global::Envoy.Config.Cluster.V3.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              CommonLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(CommonLbConfig);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Config.Core.V3.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              UpstreamConnectionOptions = new global::Envoy.Config.Cluster.V3.UpstreamConnectionOptions();
            }
            input.ReadMessage(UpstreamConnectionOptions);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            IgnoreHealthOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              LoadAssignment = new global::Envoy.Config.Endpoint.V3.ClusterLoadAssignment();
            }
            input.ReadMessage(LoadAssignment);
            break;
          }
          case 274: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.OriginalDstLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
              subBuilder.MergeFrom(OriginalDstLbConfig);
            }
            input.ReadMessage(subBuilder);
            OriginalDstLbConfig = subBuilder;
            break;
          }
          case 290: {
            typedExtensionProtocolOptions_.AddEntriesFrom(ref input, _map_typedExtensionProtocolOptions_codec);
            break;
          }
          case 298: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.LeastRequestLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
              subBuilder.MergeFrom(LeastRequestLbConfig);
            }
            input.ReadMessage(subBuilder);
            LeastRequestLbConfig = subBuilder;
            break;
          }
          case 306: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CustomClusterType();
            if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
              subBuilder.MergeFrom(ClusterType);
            }
            input.ReadMessage(subBuilder);
            ClusterType = subBuilder;
            break;
          }
          case 312: {
            RespectDnsTtl = input.ReadBool();
            break;
          }
          case 322: {
            filters_.AddEntriesFrom(ref input, _repeated_filters_codec);
            break;
          }
          case 330: {
            if (loadBalancingPolicy_ == null) {
              LoadBalancingPolicy = new global::Envoy.Config.Cluster.V3.LoadBalancingPolicy();
            }
            input.ReadMessage(LoadBalancingPolicy);
            break;
          }
          case 338: {
            if (lrsServer_ == null) {
              LrsServer = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            input.ReadMessage(LrsServer);
            break;
          }
          case 346: {
            transportSocketMatches_.AddEntriesFrom(ref input, _repeated_transportSocketMatches_codec);
            break;
          }
          case 354: {
            if (dnsFailureRefreshRate_ == null) {
              DnsFailureRefreshRate = new global::Envoy.Config.Cluster.V3.Cluster.Types.RefreshRate();
            }
            input.ReadMessage(DnsFailureRefreshRate);
            break;
          }
          case 360: {
            UseTcpForDnsLookups = input.ReadBool();
            break;
          }
          case 370: {
            if (upstreamHttpProtocolOptions_ == null) {
              UpstreamHttpProtocolOptions = new global::Envoy.Config.Core.V3.UpstreamHttpProtocolOptions();
            }
            input.ReadMessage(UpstreamHttpProtocolOptions);
            break;
          }
          case 376: {
            TrackTimeoutBudgets = input.ReadBool();
            break;
          }
          case 386: {
            if (upstreamConfig_ == null) {
              UpstreamConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(UpstreamConfig);
            break;
          }
          case 394: {
            if (trackClusterStats_ == null) {
              TrackClusterStats = new global::Envoy.Config.Cluster.V3.TrackClusterStats();
            }
            input.ReadMessage(TrackClusterStats);
            break;
          }
          case 402: {
            if (preconnectPolicy_ == null) {
              PreconnectPolicy = new global::Envoy.Config.Cluster.V3.Cluster.Types.PreconnectPolicy();
            }
            input.ReadMessage(PreconnectPolicy);
            break;
          }
          case 408: {
            ConnectionPoolPerDownstreamConnection = input.ReadBool();
            break;
          }
          case 418: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.MaglevLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.MaglevLbConfig) {
              subBuilder.MergeFrom(MaglevLbConfig);
            }
            input.ReadMessage(subBuilder);
            MaglevLbConfig = subBuilder;
            break;
          }
          case 426: {
            if (dnsResolutionConfig_ == null) {
              DnsResolutionConfig = new global::Envoy.Config.Core.V3.DnsResolutionConfig();
            }
            input.ReadMessage(DnsResolutionConfig);
            break;
          }
          case 434: {
            bool? value = _single_waitForWarmOnInit_codec.Read(ref input);
            if (waitForWarmOnInit_ == null || value != false) {
              WaitForWarmOnInit = value;
            }
            break;
          }
          case 442: {
            if (typedDnsResolverConfig_ == null) {
              TypedDnsResolverConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(TypedDnsResolverConfig);
            break;
          }
          case 450: {
            global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.RoundRobinLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RoundRobinLbConfig) {
              subBuilder.MergeFrom(RoundRobinLbConfig);
            }
            input.ReadMessage(subBuilder);
            RoundRobinLbConfig = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
      /// for an explanation on each type.
      /// </summary>
      public enum DiscoveryType {
        /// <summary>
        /// Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STATIC")] Static = 0,
        /// <summary>
        /// Refer to the :ref:`strict DNS discovery
        /// type&lt;arch_overview_service_discovery_types_strict_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STRICT_DNS")] StrictDns = 1,
        /// <summary>
        /// Refer to the :ref:`logical DNS discovery
        /// type&lt;arch_overview_service_discovery_types_logical_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LOGICAL_DNS")] LogicalDns = 2,
        /// <summary>
        /// Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("EDS")] Eds = 3,
        /// <summary>
        /// Refer to the :ref:`original destination discovery
        /// type&lt;arch_overview_service_discovery_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST")] OriginalDst = 4,
      }

      /// <summary>
      /// Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types>` architecture
      /// overview section for information on each type.
      /// </summary>
      public enum LbPolicy {
        /// <summary>
        /// Refer to the :ref:`round robin load balancing
        /// policy&lt;arch_overview_load_balancing_types_round_robin>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 0,
        /// <summary>
        /// Refer to the :ref:`least request load balancing
        /// policy&lt;arch_overview_load_balancing_types_least_request>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LEAST_REQUEST")] LeastRequest = 1,
        /// <summary>
        /// Refer to the :ref:`ring hash load balancing
        /// policy&lt;arch_overview_load_balancing_types_ring_hash>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RING_HASH")] RingHash = 2,
        /// <summary>
        /// Refer to the :ref:`random load balancing
        /// policy&lt;arch_overview_load_balancing_types_random>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RANDOM")] Random = 3,
        /// <summary>
        /// Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("MAGLEV")] Maglev = 5,
        /// <summary>
        /// This load balancer type must be specified if the configured cluster provides a cluster
        /// specific load balancer. Consult the configured cluster's documentation for whether to set
        /// this option or not.
        /// </summary>
        [pbr::OriginalName("CLUSTER_PROVIDED")] ClusterProvided = 6,
        /// <summary>
        /// Use the new :ref:`load_balancing_policy
        /// &lt;envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
        /// This has been deprecated in favor of using the :ref:`load_balancing_policy
        /// &lt;envoy_v3_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field without
        /// setting any value in :ref:`lb_policy&lt;envoy_v3_api_field_config.cluster.v3.Cluster.lb_policy>`.
        /// </summary>
        [pbr::OriginalName("LOAD_BALANCING_POLICY_CONFIG")] LoadBalancingPolicyConfig = 7,
      }

      /// <summary>
      /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
      /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
      /// only perform a lookup for addresses in the IPv6 family. If AUTO is
      /// specified, the DNS resolver will first perform a lookup for addresses in
      /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
      /// This is semantically equivalent to a non-existent V6_PREFERRED option.
      /// AUTO is a legacy name that is more opaque than
      /// necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
      /// If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
      /// IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
      /// target will only get v6 addresses if there were NO v4 addresses to return.
      /// If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
      /// and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
      /// upstream connections. Refer to :ref:`Happy Eyeballs Support &lt;arch_overview_happy_eyeballs>`
      /// for more information.
      /// For cluster types other than
      /// :ref:`STRICT_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
      /// :ref:`LOGICAL_DNS&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
      /// this setting is
      /// ignored.
      /// [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
      /// </summary>
      public enum DnsLookupFamily {
        [pbr::OriginalName("AUTO")] Auto = 0,
        [pbr::OriginalName("V4_ONLY")] V4Only = 1,
        [pbr::OriginalName("V6_ONLY")] V6Only = 2,
        [pbr::OriginalName("V4_PREFERRED")] V4Preferred = 3,
        [pbr::OriginalName("ALL")] All = 4,
      }

      public enum ClusterProtocolSelection {
        /// <summary>
        /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
        /// If :ref:`http2_protocol_options &lt;envoy_v3_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
        /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
        /// </summary>
        [pbr::OriginalName("USE_CONFIGURED_PROTOCOL")] UseConfiguredProtocol = 0,
        /// <summary>
        /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
        /// </summary>
        [pbr::OriginalName("USE_DOWNSTREAM_PROTOCOL")] UseDownstreamProtocol = 1,
      }

      /// <summary>
      /// TransportSocketMatch specifies what transport socket config will be used
      /// when the match conditions are satisfied.
      /// </summary>
      public sealed partial class TransportSocketMatch : pb::IMessage<TransportSocketMatch>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TransportSocketMatch> _parser = new pb::MessageParser<TransportSocketMatch>(() => new TransportSocketMatch());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TransportSocketMatch> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch(TransportSocketMatch other) : this() {
          name_ = other.name_;
          match_ = other.match_ != null ? other.match_.Clone() : null;
          transportSocket_ = other.transportSocket_ != null ? other.transportSocket_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TransportSocketMatch Clone() {
          return new TransportSocketMatch(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the match, used in stats generation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "match" field.</summary>
        public const int MatchFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct match_;
        /// <summary>
        /// Optional endpoint metadata match criteria.
        /// The connection to the endpoint with metadata matching what is set in this field
        /// will use the transport socket configuration specified here.
        /// The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
        /// against the values specified in this field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Struct Match {
          get { return match_; }
          set {
            match_ = value;
          }
        }

        /// <summary>Field number for the "transport_socket" field.</summary>
        public const int TransportSocketFieldNumber = 3;
        private global::Envoy.Config.Core.V3.TransportSocket transportSocket_;
        /// <summary>
        /// The configuration of the transport socket.
        /// [#extension-category: envoy.transport_sockets.upstream]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.TransportSocket TransportSocket {
          get { return transportSocket_; }
          set {
            transportSocket_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TransportSocketMatch);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TransportSocketMatch other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Match, other.Match)) return false;
          if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (match_ != null) hash ^= Match.GetHashCode();
          if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (match_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Match);
          }
          if (transportSocket_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TransportSocket);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (match_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Match);
          }
          if (transportSocket_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TransportSocket);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (match_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match);
          }
          if (transportSocket_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TransportSocketMatch other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.match_ != null) {
            if (match_ == null) {
              Match = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            Match.MergeFrom(other.Match);
          }
          if (other.transportSocket_ != null) {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
            }
            TransportSocket.MergeFrom(other.TransportSocket);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (match_ == null) {
                  Match = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Match);
                break;
              }
              case 26: {
                if (transportSocket_ == null) {
                  TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
                }
                input.ReadMessage(TransportSocket);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (match_ == null) {
                  Match = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Match);
                break;
              }
              case 26: {
                if (transportSocket_ == null) {
                  TransportSocket = new global::Envoy.Config.Core.V3.TransportSocket();
                }
                input.ReadMessage(TransportSocket);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Extended cluster type.
      /// </summary>
      public sealed partial class CustomClusterType : pb::IMessage<CustomClusterType>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CustomClusterType> _parser = new pb::MessageParser<CustomClusterType>(() => new CustomClusterType());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CustomClusterType> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType(CustomClusterType other) : this() {
          name_ = other.name_;
          typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CustomClusterType Clone() {
          return new CustomClusterType(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The type of the cluster to instantiate. The name must match a supported cluster type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
        /// <summary>
        /// Cluster specific configuration which depends on the cluster being instantiated.
        /// See the supported cluster for further documentation.
        /// [#extension-category: envoy.clusters]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return typedConfig_; }
          set {
            typedConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CustomClusterType);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CustomClusterType other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (typedConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CustomClusterType other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.typedConfig_ != null) {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            TypedConfig.MergeFrom(other.TypedConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Only valid when discovery type is EDS.
      /// </summary>
      public sealed partial class EdsClusterConfig : pb::IMessage<EdsClusterConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<EdsClusterConfig> _parser = new pb::MessageParser<EdsClusterConfig>(() => new EdsClusterConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EdsClusterConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig(EdsClusterConfig other) : this() {
          edsConfig_ = other.edsConfig_ != null ? other.edsConfig_.Clone() : null;
          serviceName_ = other.serviceName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EdsClusterConfig Clone() {
          return new EdsClusterConfig(this);
        }

        /// <summary>Field number for the "eds_config" field.</summary>
        public const int EdsConfigFieldNumber = 1;
        private global::Envoy.Config.Core.V3.ConfigSource edsConfig_;
        /// <summary>
        /// Configuration for the source of EDS updates for this Cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.ConfigSource EdsConfig {
          get { return edsConfig_; }
          set {
            edsConfig_ = value;
          }
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 2;
        private string serviceName_ = "";
        /// <summary>
        /// Optional alternative to cluster name to present to EDS. This does not
        /// have the same restrictions as cluster name, i.e. it may be arbitrary
        /// length. This may be a xdstp:// URL.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as EdsClusterConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EdsClusterConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EdsConfig, other.EdsConfig)) return false;
          if (ServiceName != other.ServiceName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (edsConfig_ != null) hash ^= EdsConfig.GetHashCode();
          if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (edsConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EdsClusterConfig other) {
          if (other == null) {
            return;
          }
          if (other.edsConfig_ != null) {
            if (edsConfig_ == null) {
              EdsConfig = new global::Envoy.Config.Core.V3.ConfigSource();
            }
            EdsConfig.MergeFrom(other.EdsConfig);
          }
          if (other.ServiceName.Length != 0) {
            ServiceName = other.ServiceName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  EdsConfig = new global::Envoy.Config.Core.V3.ConfigSource();
                }
                input.ReadMessage(EdsConfig);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  EdsConfig = new global::Envoy.Config.Core.V3.ConfigSource();
                }
                input.ReadMessage(EdsConfig);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Optionally divide the endpoints in this cluster into subsets defined by
      /// endpoint metadata and selected by route and weighted cluster metadata.
      /// [#next-free-field: 8]
      /// </summary>
      public sealed partial class LbSubsetConfig : pb::IMessage<LbSubsetConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LbSubsetConfig> _parser = new pb::MessageParser<LbSubsetConfig>(() => new LbSubsetConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LbSubsetConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig(LbSubsetConfig other) : this() {
          fallbackPolicy_ = other.fallbackPolicy_;
          defaultSubset_ = other.defaultSubset_ != null ? other.defaultSubset_.Clone() : null;
          subsetSelectors_ = other.subsetSelectors_.Clone();
          localityWeightAware_ = other.localityWeightAware_;
          scaleLocalityWeight_ = other.scaleLocalityWeight_;
          panicModeAny_ = other.panicModeAny_;
          listAsAny_ = other.listAsAny_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LbSubsetConfig Clone() {
          return new LbSubsetConfig(this);
        }

        /// <summary>Field number for the "fallback_policy" field.</summary>
        public const int FallbackPolicyFieldNumber = 1;
        private global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy fallbackPolicy_ = global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback;
        /// <summary>
        /// The behavior used when no endpoint subset matches the selected route's
        /// metadata. The value defaults to
        /// :ref:`NO_FALLBACK&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy FallbackPolicy {
          get { return fallbackPolicy_; }
          set {
            fallbackPolicy_ = value;
          }
        }

        /// <summary>Field number for the "default_subset" field.</summary>
        public const int DefaultSubsetFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct defaultSubset_;
        /// <summary>
        /// Specifies the default subset of endpoints used during fallback if
        /// fallback_policy is
        /// :ref:`DEFAULT_SUBSET&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
        /// Each field in default_subset is
        /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
        /// namespace. It is valid for no hosts to match, in which case the behavior
        /// is the same as a fallback_policy of
        /// :ref:`NO_FALLBACK&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Struct DefaultSubset {
          get { return defaultSubset_; }
          set {
            defaultSubset_ = value;
          }
        }

        /// <summary>Field number for the "subset_selectors" field.</summary>
        public const int SubsetSelectorsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> _repeated_subsetSelectors_codec
            = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> subsetSelectors_ = new pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector>();
        /// <summary>
        /// For each entry, LbEndpoint.Metadata's
        /// *envoy.lb* namespace is traversed and a subset is created for each unique
        /// combination of key and value. For example:
        ///
        /// .. code-block:: json
        ///
        ///   { "subset_selectors": [
        ///       { "keys": [ "version" ] },
        ///       { "keys": [ "stage", "hardware_type" ] }
        ///   ]}
        ///
        /// A subset is matched when the metadata from the selected route and
        /// weighted cluster contains the same keys and values as the subset's
        /// metadata. The same host may appear in multiple subsets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> SubsetSelectors {
          get { return subsetSelectors_; }
        }

        /// <summary>Field number for the "locality_weight_aware" field.</summary>
        public const int LocalityWeightAwareFieldNumber = 4;
        private bool localityWeightAware_;
        /// <summary>
        /// If true, routing to subsets will take into account the localities and locality weights of the
        /// endpoints when making the routing decision.
        ///
        /// There are some potential pitfalls associated with enabling this feature, as the resulting
        /// traffic split after applying both a subset match and locality weights might be undesirable.
        ///
        /// Consider for example a situation in which you have 50/50 split across two localities X/Y
        /// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
        /// host selected but Y having 100, then a lot more load is being dumped on the single host in X
        /// than originally anticipated in the load balancing assignment delivered via EDS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool LocalityWeightAware {
          get { return localityWeightAware_; }
          set {
            localityWeightAware_ = value;
          }
        }

        /// <summary>Field number for the "scale_locality_weight" field.</summary>
        public const int ScaleLocalityWeightFieldNumber = 5;
        private bool scaleLocalityWeight_;
        /// <summary>
        /// When used with locality_weight_aware, scales the weight of each locality by the ratio
        /// of hosts in the subset vs hosts in the original subset. This aims to even out the load
        /// going to an individual locality if said locality is disproportionately affected by the
        /// subset predicate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ScaleLocalityWeight {
          get { return scaleLocalityWeight_; }
          set {
            scaleLocalityWeight_ = value;
          }
        }

        /// <summary>Field number for the "panic_mode_any" field.</summary>
        public const int PanicModeAnyFieldNumber = 6;
        private bool panicModeAny_;
        /// <summary>
        /// If true, when a fallback policy is configured and its corresponding subset fails to find
        /// a host this will cause any host to be selected instead.
        ///
        /// This is useful when using the default subset as the fallback policy, given the default
        /// subset might become empty. With this option enabled, if that happens the LB will attempt
        /// to select a host from the entire cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool PanicModeAny {
          get { return panicModeAny_; }
          set {
            panicModeAny_ = value;
          }
        }

        /// <summary>Field number for the "list_as_any" field.</summary>
        public const int ListAsAnyFieldNumber = 7;
        private bool listAsAny_;
        /// <summary>
        /// If true, metadata specified for a metadata key will be matched against the corresponding
        /// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
        /// and any of the elements in the list matches the criteria.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ListAsAny {
          get { return listAsAny_; }
          set {
            listAsAny_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LbSubsetConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LbSubsetConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FallbackPolicy != other.FallbackPolicy) return false;
          if (!object.Equals(DefaultSubset, other.DefaultSubset)) return false;
          if(!subsetSelectors_.Equals(other.subsetSelectors_)) return false;
          if (LocalityWeightAware != other.LocalityWeightAware) return false;
          if (ScaleLocalityWeight != other.ScaleLocalityWeight) return false;
          if (PanicModeAny != other.PanicModeAny) return false;
          if (ListAsAny != other.ListAsAny) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) hash ^= FallbackPolicy.GetHashCode();
          if (defaultSubset_ != null) hash ^= DefaultSubset.GetHashCode();
          hash ^= subsetSelectors_.GetHashCode();
          if (LocalityWeightAware != false) hash ^= LocalityWeightAware.GetHashCode();
          if (ScaleLocalityWeight != false) hash ^= ScaleLocalityWeight.GetHashCode();
          if (PanicModeAny != false) hash ^= PanicModeAny.GetHashCode();
          if (ListAsAny != false) hash ^= ListAsAny.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(output, _repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            output.WriteRawTag(32);
            output.WriteBool(LocalityWeightAware);
          }
          if (ScaleLocalityWeight != false) {
            output.WriteRawTag(40);
            output.WriteBool(ScaleLocalityWeight);
          }
          if (PanicModeAny != false) {
            output.WriteRawTag(48);
            output.WriteBool(PanicModeAny);
          }
          if (ListAsAny != false) {
            output.WriteRawTag(56);
            output.WriteBool(ListAsAny);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(ref output, _repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            output.WriteRawTag(32);
            output.WriteBool(LocalityWeightAware);
          }
          if (ScaleLocalityWeight != false) {
            output.WriteRawTag(40);
            output.WriteBool(ScaleLocalityWeight);
          }
          if (PanicModeAny != false) {
            output.WriteRawTag(48);
            output.WriteBool(PanicModeAny);
          }
          if (ListAsAny != false) {
            output.WriteRawTag(56);
            output.WriteBool(ListAsAny);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultSubset);
          }
          size += subsetSelectors_.CalculateSize(_repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            size += 1 + 1;
          }
          if (ScaleLocalityWeight != false) {
            size += 1 + 1;
          }
          if (PanicModeAny != false) {
            size += 1 + 1;
          }
          if (ListAsAny != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LbSubsetConfig other) {
          if (other == null) {
            return;
          }
          if (other.FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            FallbackPolicy = other.FallbackPolicy;
          }
          if (other.defaultSubset_ != null) {
            if (defaultSubset_ == null) {
              DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            DefaultSubset.MergeFrom(other.DefaultSubset);
          }
          subsetSelectors_.Add(other.subsetSelectors_);
          if (other.LocalityWeightAware != false) {
            LocalityWeightAware = other.LocalityWeightAware;
          }
          if (other.ScaleLocalityWeight != false) {
            ScaleLocalityWeight = other.ScaleLocalityWeight;
          }
          if (other.PanicModeAny != false) {
            PanicModeAny = other.PanicModeAny;
          }
          if (other.ListAsAny != false) {
            ListAsAny = other.ListAsAny;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                FallbackPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(DefaultSubset);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(input, _repeated_subsetSelectors_codec);
                break;
              }
              case 32: {
                LocalityWeightAware = input.ReadBool();
                break;
              }
              case 40: {
                ScaleLocalityWeight = input.ReadBool();
                break;
              }
              case 48: {
                PanicModeAny = input.ReadBool();
                break;
              }
              case 56: {
                ListAsAny = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                FallbackPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(DefaultSubset);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(ref input, _repeated_subsetSelectors_codec);
                break;
              }
              case 32: {
                LocalityWeightAware = input.ReadBool();
                break;
              }
              case 40: {
                ScaleLocalityWeight = input.ReadBool();
                break;
              }
              case 48: {
                PanicModeAny = input.ReadBool();
                break;
              }
              case 56: {
                ListAsAny = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the LbSubsetConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// If NO_FALLBACK is selected, a result
          /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
          /// any cluster endpoint may be returned (subject to policy, health checks,
          /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
          /// endpoints matching the values from the default_subset field.
          /// </summary>
          public enum LbSubsetFallbackPolicy {
            [pbr::OriginalName("NO_FALLBACK")] NoFallback = 0,
            [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 1,
            [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 2,
          }

          /// <summary>
          /// Specifications for subsets.
          /// </summary>
          public sealed partial class LbSubsetSelector : pb::IMessage<LbSubsetSelector>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LbSubsetSelector> _parser = new pb::MessageParser<LbSubsetSelector>(() => new LbSubsetSelector());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<LbSubsetSelector> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector(LbSubsetSelector other) : this() {
              keys_ = other.keys_.Clone();
              singleHostPerSubset_ = other.singleHostPerSubset_;
              fallbackPolicy_ = other.fallbackPolicy_;
              fallbackKeysSubset_ = other.fallbackKeysSubset_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LbSubsetSelector Clone() {
              return new LbSubsetSelector(this);
            }

            /// <summary>Field number for the "keys" field.</summary>
            public const int KeysFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_keys_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of keys to match with the weighted cluster metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> Keys {
              get { return keys_; }
            }

            /// <summary>Field number for the "single_host_per_subset" field.</summary>
            public const int SingleHostPerSubsetFieldNumber = 4;
            private bool singleHostPerSubset_;
            /// <summary>
            /// Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
            /// choosing a host, but updating hosts is faster, especially for large numbers of hosts.
            ///
            /// If a match is found to a host, that host will be used regardless of priority levels, unless the host is unhealthy.
            ///
            /// Currently, this mode is only supported if `subset_selectors` has only one entry, and `keys` contains
            /// only one entry.
            ///
            /// When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in `keys`
            /// will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
            /// :ref:`lb_subsets_single_host_per_subset_duplicate&lt;config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
            /// present in the current configuration.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool SingleHostPerSubset {
              get { return singleHostPerSubset_; }
              set {
                singleHostPerSubset_ = value;
              }
            }

            /// <summary>Field number for the "fallback_policy" field.</summary>
            public const int FallbackPolicyFieldNumber = 2;
            private global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy fallbackPolicy_ = global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined;
            /// <summary>
            /// The behavior used when no endpoint subset matches the selected route's
            /// metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy FallbackPolicy {
              get { return fallbackPolicy_; }
              set {
                fallbackPolicy_ = value;
              }
            }

            /// <summary>Field number for the "fallback_keys_subset" field.</summary>
            public const int FallbackKeysSubsetFieldNumber = 3;
            private static readonly pb::FieldCodec<string> _repeated_fallbackKeysSubset_codec
                = pb::FieldCodec.ForString(26);
            private readonly pbc::RepeatedField<string> fallbackKeysSubset_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// Subset of
            /// :ref:`keys&lt;envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
            /// :ref:`KEYS_SUBSET&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
            /// fallback policy.
            /// It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
            /// For any other fallback policy the parameter is not used and should not be set.
            /// Only values also present in
            /// :ref:`keys&lt;envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
            /// `fallback_keys_subset` cannot be equal to `keys`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> FallbackKeysSubset {
              get { return fallbackKeysSubset_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as LbSubsetSelector);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(LbSubsetSelector other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!keys_.Equals(other.keys_)) return false;
              if (SingleHostPerSubset != other.SingleHostPerSubset) return false;
              if (FallbackPolicy != other.FallbackPolicy) return false;
              if(!fallbackKeysSubset_.Equals(other.fallbackKeysSubset_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= keys_.GetHashCode();
              if (SingleHostPerSubset != false) hash ^= SingleHostPerSubset.GetHashCode();
              if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) hash ^= FallbackPolicy.GetHashCode();
              hash ^= fallbackKeysSubset_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              keys_.WriteTo(output, _repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FallbackPolicy);
              }
              fallbackKeysSubset_.WriteTo(output, _repeated_fallbackKeysSubset_codec);
              if (SingleHostPerSubset != false) {
                output.WriteRawTag(32);
                output.WriteBool(SingleHostPerSubset);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              keys_.WriteTo(ref output, _repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FallbackPolicy);
              }
              fallbackKeysSubset_.WriteTo(ref output, _repeated_fallbackKeysSubset_codec);
              if (SingleHostPerSubset != false) {
                output.WriteRawTag(32);
                output.WriteBool(SingleHostPerSubset);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += keys_.CalculateSize(_repeated_keys_codec);
              if (SingleHostPerSubset != false) {
                size += 1 + 1;
              }
              if (FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
              }
              size += fallbackKeysSubset_.CalculateSize(_repeated_fallbackKeysSubset_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(LbSubsetSelector other) {
              if (other == null) {
                return;
              }
              keys_.Add(other.keys_);
              if (other.SingleHostPerSubset != false) {
                SingleHostPerSubset = other.SingleHostPerSubset;
              }
              if (other.FallbackPolicy != global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                FallbackPolicy = other.FallbackPolicy;
              }
              fallbackKeysSubset_.Add(other.fallbackKeysSubset_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(input, _repeated_keys_codec);
                    break;
                  }
                  case 16: {
                    FallbackPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    fallbackKeysSubset_.AddEntriesFrom(input, _repeated_fallbackKeysSubset_codec);
                    break;
                  }
                  case 32: {
                    SingleHostPerSubset = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(ref input, _repeated_keys_codec);
                    break;
                  }
                  case 16: {
                    FallbackPolicy = (global::Envoy.Config.Cluster.V3.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    fallbackKeysSubset_.AddEntriesFrom(ref input, _repeated_fallbackKeysSubset_codec);
                    break;
                  }
                  case 32: {
                    SingleHostPerSubset = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the LbSubsetSelector message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Allows to override top level fallback policy per selector.
              /// </summary>
              public enum LbSubsetSelectorFallbackPolicy {
                /// <summary>
                /// If NOT_DEFINED top level config fallback policy is used instead.
                /// </summary>
                [pbr::OriginalName("NOT_DEFINED")] NotDefined = 0,
                /// <summary>
                /// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
                /// </summary>
                [pbr::OriginalName("NO_FALLBACK")] NoFallback = 1,
                /// <summary>
                /// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
                /// (subject to policy, health checks, etc).
                /// </summary>
                [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 2,
                /// <summary>
                /// If DEFAULT_SUBSET is selected, load balancing is performed over the
                /// endpoints matching the values from the default_subset field.
                /// </summary>
                [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 3,
                /// <summary>
                /// If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
                /// keys reduced to
                /// :ref:`fallback_keys_subset&lt;envoy_v3_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
                /// It allows for a fallback to a different, less specific selector if some of the keys of
                /// the selector are considered optional.
                /// </summary>
                [pbr::OriginalName("KEYS_SUBSET")] KeysSubset = 4,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      /// Configuration for :ref:`slow start mode &lt;arch_overview_load_balancing_slow_start>`.
      /// </summary>
      public sealed partial class SlowStartConfig : pb::IMessage<SlowStartConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SlowStartConfig> _parser = new pb::MessageParser<SlowStartConfig>(() => new SlowStartConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SlowStartConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SlowStartConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SlowStartConfig(SlowStartConfig other) : this() {
          slowStartWindow_ = other.slowStartWindow_ != null ? other.slowStartWindow_.Clone() : null;
          aggression_ = other.aggression_ != null ? other.aggression_.Clone() : null;
          minWeightPercent_ = other.minWeightPercent_ != null ? other.minWeightPercent_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SlowStartConfig Clone() {
          return new SlowStartConfig(this);
        }

        /// <summary>Field number for the "slow_start_window" field.</summary>
        public const int SlowStartWindowFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration slowStartWindow_;
        /// <summary>
        /// Represents the size of slow start window.
        /// If set, the newly created host remains in slow start mode starting from its creation time
        /// for the duration of slow start window.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration SlowStartWindow {
          get { return slowStartWindow_; }
          set {
            slowStartWindow_ = value;
          }
        }

        /// <summary>Field number for the "aggression" field.</summary>
        public const int AggressionFieldNumber = 2;
        private global::Envoy.Config.Core.V3.RuntimeDouble aggression_;
        /// <summary>
        /// This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
        /// so that endpoint would get linearly increasing amount of traffic.
        /// When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
        /// The value of aggression parameter should be greater than 0.0.
        /// By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
        ///
        /// During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
        /// `new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))`,
        /// where `time_factor=(time_since_start_seconds / slow_start_time_seconds)`.
        ///
        /// As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
        /// Once host exits slow start, time_factor and aggression no longer affect its weight.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.RuntimeDouble Aggression {
          get { return aggression_; }
          set {
            aggression_ = value;
          }
        }

        /// <summary>Field number for the "min_weight_percent" field.</summary>
        public const int MinWeightPercentFieldNumber = 3;
        private global::Envoy.Type.V3.Percent minWeightPercent_;
        /// <summary>
        /// Configures the minimum percentage of origin weight that avoids too small new weight,
        /// which may cause endpoints in slow start mode receive no traffic in slow start window.
        /// If not specified, the default is 10%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.V3.Percent MinWeightPercent {
          get { return minWeightPercent_; }
          set {
            minWeightPercent_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SlowStartConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SlowStartConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(SlowStartWindow, other.SlowStartWindow)) return false;
          if (!object.Equals(Aggression, other.Aggression)) return false;
          if (!object.Equals(MinWeightPercent, other.MinWeightPercent)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (slowStartWindow_ != null) hash ^= SlowStartWindow.GetHashCode();
          if (aggression_ != null) hash ^= Aggression.GetHashCode();
          if (minWeightPercent_ != null) hash ^= MinWeightPercent.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (slowStartWindow_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(SlowStartWindow);
          }
          if (aggression_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Aggression);
          }
          if (minWeightPercent_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MinWeightPercent);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (slowStartWindow_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(SlowStartWindow);
          }
          if (aggression_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Aggression);
          }
          if (minWeightPercent_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MinWeightPercent);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (slowStartWindow_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SlowStartWindow);
          }
          if (aggression_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Aggression);
          }
          if (minWeightPercent_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinWeightPercent);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SlowStartConfig other) {
          if (other == null) {
            return;
          }
          if (other.slowStartWindow_ != null) {
            if (slowStartWindow_ == null) {
              SlowStartWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            SlowStartWindow.MergeFrom(other.SlowStartWindow);
          }
          if (other.aggression_ != null) {
            if (aggression_ == null) {
              Aggression = new global::Envoy.Config.Core.V3.RuntimeDouble();
            }
            Aggression.MergeFrom(other.Aggression);
          }
          if (other.minWeightPercent_ != null) {
            if (minWeightPercent_ == null) {
              MinWeightPercent = new global::Envoy.Type.V3.Percent();
            }
            MinWeightPercent.MergeFrom(other.MinWeightPercent);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (slowStartWindow_ == null) {
                  SlowStartWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(SlowStartWindow);
                break;
              }
              case 18: {
                if (aggression_ == null) {
                  Aggression = new global::Envoy.Config.Core.V3.RuntimeDouble();
                }
                input.ReadMessage(Aggression);
                break;
              }
              case 26: {
                if (minWeightPercent_ == null) {
                  MinWeightPercent = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(MinWeightPercent);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (slowStartWindow_ == null) {
                  SlowStartWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(SlowStartWindow);
                break;
              }
              case 18: {
                if (aggression_ == null) {
                  Aggression = new global::Envoy.Config.Core.V3.RuntimeDouble();
                }
                input.ReadMessage(Aggression);
                break;
              }
              case 26: {
                if (minWeightPercent_ == null) {
                  MinWeightPercent = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(MinWeightPercent);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specific configuration for the RoundRobin load balancing policy.
      /// </summary>
      public sealed partial class RoundRobinLbConfig : pb::IMessage<RoundRobinLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RoundRobinLbConfig> _parser = new pb::MessageParser<RoundRobinLbConfig>(() => new RoundRobinLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RoundRobinLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoundRobinLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoundRobinLbConfig(RoundRobinLbConfig other) : this() {
          slowStartConfig_ = other.slowStartConfig_ != null ? other.slowStartConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoundRobinLbConfig Clone() {
          return new RoundRobinLbConfig(this);
        }

        /// <summary>Field number for the "slow_start_config" field.</summary>
        public const int SlowStartConfigFieldNumber = 1;
        private global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig slowStartConfig_;
        /// <summary>
        /// Configuration for slow start mode.
        /// If this configuration is not set, slow start will not be not enabled.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig SlowStartConfig {
          get { return slowStartConfig_; }
          set {
            slowStartConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RoundRobinLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RoundRobinLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(SlowStartConfig, other.SlowStartConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (slowStartConfig_ != null) hash ^= SlowStartConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (slowStartConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(SlowStartConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (slowStartConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(SlowStartConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (slowStartConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SlowStartConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RoundRobinLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.slowStartConfig_ != null) {
            if (slowStartConfig_ == null) {
              SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
            }
            SlowStartConfig.MergeFrom(other.SlowStartConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (slowStartConfig_ == null) {
                  SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
                }
                input.ReadMessage(SlowStartConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (slowStartConfig_ == null) {
                  SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
                }
                input.ReadMessage(SlowStartConfig);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specific configuration for the LeastRequest load balancing policy.
      /// </summary>
      public sealed partial class LeastRequestLbConfig : pb::IMessage<LeastRequestLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LeastRequestLbConfig> _parser = new pb::MessageParser<LeastRequestLbConfig>(() => new LeastRequestLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LeastRequestLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig(LeastRequestLbConfig other) : this() {
          ChoiceCount = other.ChoiceCount;
          activeRequestBias_ = other.activeRequestBias_ != null ? other.activeRequestBias_.Clone() : null;
          slowStartConfig_ = other.slowStartConfig_ != null ? other.slowStartConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LeastRequestLbConfig Clone() {
          return new LeastRequestLbConfig(this);
        }

        /// <summary>Field number for the "choice_count" field.</summary>
        public const int ChoiceCountFieldNumber = 1;
        private static readonly pb::FieldCodec<uint?> _single_choiceCount_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
        private uint? choiceCount_;
        /// <summary>
        /// The number of random healthy hosts from which the host with the fewest active requests will
        /// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? ChoiceCount {
          get { return choiceCount_; }
          set {
            choiceCount_ = value;
          }
        }


        /// <summary>Field number for the "active_request_bias" field.</summary>
        public const int ActiveRequestBiasFieldNumber = 2;
        private global::Envoy.Config.Core.V3.RuntimeDouble activeRequestBias_;
        /// <summary>
        /// The following formula is used to calculate the dynamic weights when hosts have different load
        /// balancing weights:
        ///
        /// `weight = load_balancing_weight / (active_requests + 1)^active_request_bias`
        ///
        /// The larger the active request bias is, the more aggressively active requests will lower the
        /// effective weight when all host weights are not equal.
        ///
        /// `active_request_bias` must be greater than or equal to 0.0.
        ///
        /// When `active_request_bias == 0.0` the Least Request Load Balancer doesn't consider the number
        /// of active requests at the time it picks a host and behaves like the Round Robin Load
        /// Balancer.
        ///
        /// When `active_request_bias > 0.0` the Least Request Load Balancer scales the load balancing
        /// weight by the number of active requests at the time it does a pick.
        ///
        /// The value is cached for performance reasons and refreshed whenever one of the Load Balancer's
        /// host sets changes, e.g., whenever there is a host membership update or a host load balancing
        /// weight change.
        ///
        /// .. note::
        ///   This setting only takes effect if all host weights are not equal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.RuntimeDouble ActiveRequestBias {
          get { return activeRequestBias_; }
          set {
            activeRequestBias_ = value;
          }
        }

        /// <summary>Field number for the "slow_start_config" field.</summary>
        public const int SlowStartConfigFieldNumber = 3;
        private global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig slowStartConfig_;
        /// <summary>
        /// Configuration for slow start mode.
        /// If this configuration is not set, slow start will not be not enabled.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig SlowStartConfig {
          get { return slowStartConfig_; }
          set {
            slowStartConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LeastRequestLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LeastRequestLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ChoiceCount != other.ChoiceCount) return false;
          if (!object.Equals(ActiveRequestBias, other.ActiveRequestBias)) return false;
          if (!object.Equals(SlowStartConfig, other.SlowStartConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (choiceCount_ != null) hash ^= ChoiceCount.GetHashCode();
          if (activeRequestBias_ != null) hash ^= ActiveRequestBias.GetHashCode();
          if (slowStartConfig_ != null) hash ^= SlowStartConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (choiceCount_ != null) {
            _single_choiceCount_codec.WriteTagAndValue(output, ChoiceCount);
          }
          if (activeRequestBias_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ActiveRequestBias);
          }
          if (slowStartConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SlowStartConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (choiceCount_ != null) {
            _single_choiceCount_codec.WriteTagAndValue(ref output, ChoiceCount);
          }
          if (activeRequestBias_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ActiveRequestBias);
          }
          if (slowStartConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SlowStartConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (choiceCount_ != null) {
            size += _single_choiceCount_codec.CalculateSizeWithTag(ChoiceCount);
          }
          if (activeRequestBias_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ActiveRequestBias);
          }
          if (slowStartConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SlowStartConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LeastRequestLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.choiceCount_ != null) {
            if (choiceCount_ == null || other.ChoiceCount != 0) {
              ChoiceCount = other.ChoiceCount;
            }
          }
          if (other.activeRequestBias_ != null) {
            if (activeRequestBias_ == null) {
              ActiveRequestBias = new global::Envoy.Config.Core.V3.RuntimeDouble();
            }
            ActiveRequestBias.MergeFrom(other.ActiveRequestBias);
          }
          if (other.slowStartConfig_ != null) {
            if (slowStartConfig_ == null) {
              SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
            }
            SlowStartConfig.MergeFrom(other.SlowStartConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                uint? value = _single_choiceCount_codec.Read(input);
                if (choiceCount_ == null || value != 0) {
                  ChoiceCount = value;
                }
                break;
              }
              case 18: {
                if (activeRequestBias_ == null) {
                  ActiveRequestBias = new global::Envoy.Config.Core.V3.RuntimeDouble();
                }
                input.ReadMessage(ActiveRequestBias);
                break;
              }
              case 26: {
                if (slowStartConfig_ == null) {
                  SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
                }
                input.ReadMessage(SlowStartConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                uint? value = _single_choiceCount_codec.Read(ref input);
                if (choiceCount_ == null || value != 0) {
                  ChoiceCount = value;
                }
                break;
              }
              case 18: {
                if (activeRequestBias_ == null) {
                  ActiveRequestBias = new global::Envoy.Config.Core.V3.RuntimeDouble();
                }
                input.ReadMessage(ActiveRequestBias);
                break;
              }
              case 26: {
                if (slowStartConfig_ == null) {
                  SlowStartConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.SlowStartConfig();
                }
                input.ReadMessage(SlowStartConfig);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class RingHashLbConfig : pb::IMessage<RingHashLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RingHashLbConfig> _parser = new pb::MessageParser<RingHashLbConfig>(() => new RingHashLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RingHashLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig(RingHashLbConfig other) : this() {
          MinimumRingSize = other.MinimumRingSize;
          hashFunction_ = other.hashFunction_;
          MaximumRingSize = other.MaximumRingSize;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RingHashLbConfig Clone() {
          return new RingHashLbConfig(this);
        }

        /// <summary>Field number for the "minimum_ring_size" field.</summary>
        public const int MinimumRingSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_minimumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? minimumRingSize_;
        /// <summary>
        /// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
        /// provided host) the better the request distribution will reflect the desired weights. Defaults
        /// to 1024 entries, and limited to 8M entries. See also
        /// :ref:`maximum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong? MinimumRingSize {
          get { return minimumRingSize_; }
          set {
            minimumRingSize_ = value;
          }
        }


        /// <summary>Field number for the "hash_function" field.</summary>
        public const int HashFunctionFieldNumber = 3;
        private global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction hashFunction_ = global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash;
        /// <summary>
        /// The hash function used to hash hosts onto the ketama ring. The value defaults to
        /// :ref:`XX_HASH&lt;envoy_v3_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction HashFunction {
          get { return hashFunction_; }
          set {
            hashFunction_ = value;
          }
        }

        /// <summary>Field number for the "maximum_ring_size" field.</summary>
        public const int MaximumRingSizeFieldNumber = 4;
        private static readonly pb::FieldCodec<ulong?> _single_maximumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(34);
        private ulong? maximumRingSize_;
        /// <summary>
        /// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
        /// to further constrain resource use. See also
        /// :ref:`minimum_ring_size&lt;envoy_v3_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong? MaximumRingSize {
          get { return maximumRingSize_; }
          set {
            maximumRingSize_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RingHashLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RingHashLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinimumRingSize != other.MinimumRingSize) return false;
          if (HashFunction != other.HashFunction) return false;
          if (MaximumRingSize != other.MaximumRingSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (minimumRingSize_ != null) hash ^= MinimumRingSize.GetHashCode();
          if (HashFunction != global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) hash ^= HashFunction.GetHashCode();
          if (maximumRingSize_ != null) hash ^= MaximumRingSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(output, MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            _single_maximumRingSize_codec.WriteTagAndValue(output, MaximumRingSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(ref output, MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            _single_maximumRingSize_codec.WriteTagAndValue(ref output, MaximumRingSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (minimumRingSize_ != null) {
            size += _single_minimumRingSize_codec.CalculateSizeWithTag(MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            size += _single_maximumRingSize_codec.CalculateSizeWithTag(MaximumRingSize);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RingHashLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.minimumRingSize_ != null) {
            if (minimumRingSize_ == null || other.MinimumRingSize != 0UL) {
              MinimumRingSize = other.MinimumRingSize;
            }
          }
          if (other.HashFunction != global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            HashFunction = other.HashFunction;
          }
          if (other.maximumRingSize_ != null) {
            if (maximumRingSize_ == null || other.MaximumRingSize != 0UL) {
              MaximumRingSize = other.MaximumRingSize;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 24: {
                HashFunction = (global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction) input.ReadEnum();
                break;
              }
              case 34: {
                ulong? value = _single_maximumRingSize_codec.Read(input);
                if (maximumRingSize_ == null || value != 0UL) {
                  MaximumRingSize = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(ref input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 24: {
                HashFunction = (global::Envoy.Config.Cluster.V3.Cluster.Types.RingHashLbConfig.Types.HashFunction) input.ReadEnum();
                break;
              }
              case 34: {
                ulong? value = _single_maximumRingSize_codec.Read(ref input);
                if (maximumRingSize_ == null || value != 0UL) {
                  MaximumRingSize = value;
                }
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the RingHashLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// The hash function used to hash hosts onto the ketama ring.
          /// </summary>
          public enum HashFunction {
            /// <summary>
            /// Use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
            /// </summary>
            [pbr::OriginalName("XX_HASH")] XxHash = 0,
            /// <summary>
            /// Use `MurmurHash2 &lt;https://sites.google.com/site/murmurhash/>`_, this is compatible with
            /// std:hash&lt;string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
            /// on Linux and not macOS.
            /// </summary>
            [pbr::OriginalName("MURMUR_HASH_2")] MurmurHash2 = 1,
          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the :ref:`Maglev&lt;arch_overview_load_balancing_types_maglev>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class MaglevLbConfig : pb::IMessage<MaglevLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MaglevLbConfig> _parser = new pb::MessageParser<MaglevLbConfig>(() => new MaglevLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<MaglevLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaglevLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaglevLbConfig(MaglevLbConfig other) : this() {
          TableSize = other.TableSize;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaglevLbConfig Clone() {
          return new MaglevLbConfig(this);
        }

        /// <summary>Field number for the "table_size" field.</summary>
        public const int TableSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_tableSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? tableSize_;
        /// <summary>
        /// The table size for Maglev hashing. The Maglev aims for ‘minimal disruption’ rather than an absolute guarantee.
        /// Minimal disruption means that when the set of upstreams changes, a connection will likely be sent to the same
        /// upstream as it was before. Increasing the table size reduces the amount of disruption.
        /// The table size must be prime number limited to 5000011. If it is not specified, the default is 65537.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong? TableSize {
          get { return tableSize_; }
          set {
            tableSize_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as MaglevLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(MaglevLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TableSize != other.TableSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (tableSize_ != null) hash ^= TableSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (tableSize_ != null) {
            _single_tableSize_codec.WriteTagAndValue(output, TableSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (tableSize_ != null) {
            _single_tableSize_codec.WriteTagAndValue(ref output, TableSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (tableSize_ != null) {
            size += _single_tableSize_codec.CalculateSizeWithTag(TableSize);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(MaglevLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.tableSize_ != null) {
            if (tableSize_ == null || other.TableSize != 0UL) {
              TableSize = other.TableSize;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ulong? value = _single_tableSize_codec.Read(input);
                if (tableSize_ == null || value != 0UL) {
                  TableSize = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ulong? value = _single_tableSize_codec.Read(ref input);
                if (tableSize_ == null || value != 0UL) {
                  TableSize = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specific configuration for the
      /// :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class OriginalDstLbConfig : pb::IMessage<OriginalDstLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OriginalDstLbConfig> _parser = new pb::MessageParser<OriginalDstLbConfig>(() => new OriginalDstLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OriginalDstLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[9]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig(OriginalDstLbConfig other) : this() {
          useHttpHeader_ = other.useHttpHeader_;
          httpHeaderName_ = other.httpHeaderName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OriginalDstLbConfig Clone() {
          return new OriginalDstLbConfig(this);
        }

        /// <summary>Field number for the "use_http_header" field.</summary>
        public const int UseHttpHeaderFieldNumber = 1;
        private bool useHttpHeader_;
        /// <summary>
        /// When true, a HTTP header can be used to override the original dst address. The default header is
        /// :ref:`x-envoy-original-dst-host &lt;config_http_conn_man_headers_x-envoy-original-dst-host>`.
        ///
        /// .. attention::
        ///
        ///   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
        ///   route traffic to arbitrary hosts and/or ports, which may have serious security
        ///   consequences.
        ///
        /// .. note::
        ///
        ///   If the header appears multiple times only the first value is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool UseHttpHeader {
          get { return useHttpHeader_; }
          set {
            useHttpHeader_ = value;
          }
        }

        /// <summary>Field number for the "http_header_name" field.</summary>
        public const int HttpHeaderNameFieldNumber = 2;
        private string httpHeaderName_ = "";
        /// <summary>
        /// The http header to override destination address if :ref:`use_http_header &lt;envoy_v3_api_field_config.cluster.v3.Cluster.OriginalDstLbConfig.use_http_header>`.
        /// is set to true. If the value is empty, :ref:`x-envoy-original-dst-host &lt;config_http_conn_man_headers_x-envoy-original-dst-host>` will be used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string HttpHeaderName {
          get { return httpHeaderName_; }
          set {
            httpHeaderName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OriginalDstLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OriginalDstLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UseHttpHeader != other.UseHttpHeader) return false;
          if (HttpHeaderName != other.HttpHeaderName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UseHttpHeader != false) hash ^= UseHttpHeader.GetHashCode();
          if (HttpHeaderName.Length != 0) hash ^= HttpHeaderName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UseHttpHeader != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseHttpHeader);
          }
          if (HttpHeaderName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HttpHeaderName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UseHttpHeader != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseHttpHeader);
          }
          if (HttpHeaderName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(HttpHeaderName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UseHttpHeader != false) {
            size += 1 + 1;
          }
          if (HttpHeaderName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HttpHeaderName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OriginalDstLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.UseHttpHeader != false) {
            UseHttpHeader = other.UseHttpHeader;
          }
          if (other.HttpHeaderName.Length != 0) {
            HttpHeaderName = other.HttpHeaderName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UseHttpHeader = input.ReadBool();
                break;
              }
              case 18: {
                HttpHeaderName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                UseHttpHeader = input.ReadBool();
                break;
              }
              case 18: {
                HttpHeaderName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Common configuration for all load balancer implementations.
      /// [#next-free-field: 9]
      /// </summary>
      public sealed partial class CommonLbConfig : pb::IMessage<CommonLbConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<CommonLbConfig> _parser = new pb::MessageParser<CommonLbConfig>(() => new CommonLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<CommonLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[10]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig(CommonLbConfig other) : this() {
          healthyPanicThreshold_ = other.healthyPanicThreshold_ != null ? other.healthyPanicThreshold_.Clone() : null;
          updateMergeWindow_ = other.updateMergeWindow_ != null ? other.updateMergeWindow_.Clone() : null;
          ignoreNewHostsUntilFirstHc_ = other.ignoreNewHostsUntilFirstHc_;
          closeConnectionsOnHostSetChange_ = other.closeConnectionsOnHostSetChange_;
          consistentHashingLbConfig_ = other.consistentHashingLbConfig_ != null ? other.consistentHashingLbConfig_.Clone() : null;
          overrideHostStatus_ = other.overrideHostStatus_ != null ? other.overrideHostStatus_.Clone() : null;
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              ZoneAwareLbConfig = other.ZoneAwareLbConfig.Clone();
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              LocalityWeightedLbConfig = other.LocalityWeightedLbConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public CommonLbConfig Clone() {
          return new CommonLbConfig(this);
        }

        /// <summary>Field number for the "healthy_panic_threshold" field.</summary>
        public const int HealthyPanicThresholdFieldNumber = 1;
        private global::Envoy.Type.V3.Percent healthyPanicThreshold_;
        /// <summary>
        /// Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold>`.
        /// If not specified, the default is 50%.
        /// To disable panic mode, set to 0%.
        ///
        /// .. note::
        ///   The specified percent will be truncated to the nearest 1%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Type.V3.Percent HealthyPanicThreshold {
          get { return healthyPanicThreshold_; }
          set {
            healthyPanicThreshold_ = value;
          }
        }

        /// <summary>Field number for the "zone_aware_lb_config" field.</summary>
        public const int ZoneAwareLbConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig ZoneAwareLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig;
          }
        }

        /// <summary>Field number for the "locality_weighted_lb_config" field.</summary>
        public const int LocalityWeightedLbConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig LocalityWeightedLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig ? (global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig;
          }
        }

        /// <summary>Field number for the "update_merge_window" field.</summary>
        public const int UpdateMergeWindowFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration updateMergeWindow_;
        /// <summary>
        /// If set, all health check/weight/metadata updates that happen within this duration will be
        /// merged and delivered in one shot when the duration expires. The start of the duration is when
        /// the first update happens. This is useful for big clusters, with potentially noisy deploys
        /// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
        /// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
        /// cluster). Please always keep in mind that the use of sandbox technologies may change this
        /// behavior.
        ///
        /// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
        /// window to 0.
        ///
        /// Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
        /// because merging those updates isn't currently safe. See
        /// https://github.com/envoyproxy/envoy/pull/3941.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration UpdateMergeWindow {
          get { return updateMergeWindow_; }
          set {
            updateMergeWindow_ = value;
          }
        }

        /// <summary>Field number for the "ignore_new_hosts_until_first_hc" field.</summary>
        public const int IgnoreNewHostsUntilFirstHcFieldNumber = 5;
        private bool ignoreNewHostsUntilFirstHc_;
        /// <summary>
        /// If set to true, Envoy will :ref:`exclude &lt;arch_overview_load_balancing_excluded>` new hosts
        /// when computing load balancing weights until they have been health checked for the first time.
        /// This will have no effect unless active health checking is also configured.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IgnoreNewHostsUntilFirstHc {
          get { return ignoreNewHostsUntilFirstHc_; }
          set {
            ignoreNewHostsUntilFirstHc_ = value;
          }
        }

        /// <summary>Field number for the "close_connections_on_host_set_change" field.</summary>
        public const int CloseConnectionsOnHostSetChangeFieldNumber = 6;
        private bool closeConnectionsOnHostSetChange_;
        /// <summary>
        /// If set to `true`, the cluster manager will drain all existing
        /// connections to upstream hosts whenever hosts are added or removed from the cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CloseConnectionsOnHostSetChange {
          get { return closeConnectionsOnHostSetChange_; }
          set {
            closeConnectionsOnHostSetChange_ = value;
          }
        }

        /// <summary>Field number for the "consistent_hashing_lb_config" field.</summary>
        public const int ConsistentHashingLbConfigFieldNumber = 7;
        private global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig consistentHashingLbConfig_;
        /// <summary>
        /// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig ConsistentHashingLbConfig {
          get { return consistentHashingLbConfig_; }
          set {
            consistentHashingLbConfig_ = value;
          }
        }

        /// <summary>Field number for the "override_host_status" field.</summary>
        public const int OverrideHostStatusFieldNumber = 8;
        private global::Envoy.Config.Core.V3.HealthStatusSet overrideHostStatus_;
        /// <summary>
        /// This controls what hosts are considered valid when using
        /// :ref:`host overrides &lt;arch_overview_load_balancing_override_host>`, which is used by some
        /// filters to modify the load balancing decision.
        ///
        /// If this is unset then [UNKNOWN, HEALTHY, DEGRADED] will be applied by default. If this is
        /// set with an empty set of statuses then host overrides will be ignored by the load balancing.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.HealthStatusSet OverrideHostStatus {
          get { return overrideHostStatus_; }
          set {
            overrideHostStatus_ = value;
          }
        }

        private object localityConfigSpecifier_;
        /// <summary>Enum of possible cases for the "locality_config_specifier" oneof.</summary>
        public enum LocalityConfigSpecifierOneofCase {
          None = 0,
          ZoneAwareLbConfig = 2,
          LocalityWeightedLbConfig = 3,
        }
        private LocalityConfigSpecifierOneofCase localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocalityConfigSpecifierOneofCase LocalityConfigSpecifierCase {
          get { return localityConfigSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLocalityConfigSpecifier() {
          localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
          localityConfigSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as CommonLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(CommonLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(HealthyPanicThreshold, other.HealthyPanicThreshold)) return false;
          if (!object.Equals(ZoneAwareLbConfig, other.ZoneAwareLbConfig)) return false;
          if (!object.Equals(LocalityWeightedLbConfig, other.LocalityWeightedLbConfig)) return false;
          if (!object.Equals(UpdateMergeWindow, other.UpdateMergeWindow)) return false;
          if (IgnoreNewHostsUntilFirstHc != other.IgnoreNewHostsUntilFirstHc) return false;
          if (CloseConnectionsOnHostSetChange != other.CloseConnectionsOnHostSetChange) return false;
          if (!object.Equals(ConsistentHashingLbConfig, other.ConsistentHashingLbConfig)) return false;
          if (!object.Equals(OverrideHostStatus, other.OverrideHostStatus)) return false;
          if (LocalityConfigSpecifierCase != other.LocalityConfigSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (healthyPanicThreshold_ != null) hash ^= HealthyPanicThreshold.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) hash ^= ZoneAwareLbConfig.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) hash ^= LocalityWeightedLbConfig.GetHashCode();
          if (updateMergeWindow_ != null) hash ^= UpdateMergeWindow.GetHashCode();
          if (IgnoreNewHostsUntilFirstHc != false) hash ^= IgnoreNewHostsUntilFirstHc.GetHashCode();
          if (CloseConnectionsOnHostSetChange != false) hash ^= CloseConnectionsOnHostSetChange.GetHashCode();
          if (consistentHashingLbConfig_ != null) hash ^= ConsistentHashingLbConfig.GetHashCode();
          if (overrideHostStatus_ != null) hash ^= OverrideHostStatus.GetHashCode();
          hash ^= (int) localityConfigSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            output.WriteRawTag(40);
            output.WriteBool(IgnoreNewHostsUntilFirstHc);
          }
          if (CloseConnectionsOnHostSetChange != false) {
            output.WriteRawTag(48);
            output.WriteBool(CloseConnectionsOnHostSetChange);
          }
          if (consistentHashingLbConfig_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(ConsistentHashingLbConfig);
          }
          if (overrideHostStatus_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(OverrideHostStatus);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            output.WriteRawTag(40);
            output.WriteBool(IgnoreNewHostsUntilFirstHc);
          }
          if (CloseConnectionsOnHostSetChange != false) {
            output.WriteRawTag(48);
            output.WriteBool(CloseConnectionsOnHostSetChange);
          }
          if (consistentHashingLbConfig_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(ConsistentHashingLbConfig);
          }
          if (overrideHostStatus_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(OverrideHostStatus);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (healthyPanicThreshold_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            size += 1 + 1;
          }
          if (CloseConnectionsOnHostSetChange != false) {
            size += 1 + 1;
          }
          if (consistentHashingLbConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConsistentHashingLbConfig);
          }
          if (overrideHostStatus_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverrideHostStatus);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(CommonLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.healthyPanicThreshold_ != null) {
            if (healthyPanicThreshold_ == null) {
              HealthyPanicThreshold = new global::Envoy.Type.V3.Percent();
            }
            HealthyPanicThreshold.MergeFrom(other.HealthyPanicThreshold);
          }
          if (other.updateMergeWindow_ != null) {
            if (updateMergeWindow_ == null) {
              UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            UpdateMergeWindow.MergeFrom(other.UpdateMergeWindow);
          }
          if (other.IgnoreNewHostsUntilFirstHc != false) {
            IgnoreNewHostsUntilFirstHc = other.IgnoreNewHostsUntilFirstHc;
          }
          if (other.CloseConnectionsOnHostSetChange != false) {
            CloseConnectionsOnHostSetChange = other.CloseConnectionsOnHostSetChange;
          }
          if (other.consistentHashingLbConfig_ != null) {
            if (consistentHashingLbConfig_ == null) {
              ConsistentHashingLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
            }
            ConsistentHashingLbConfig.MergeFrom(other.ConsistentHashingLbConfig);
          }
          if (other.overrideHostStatus_ != null) {
            if (overrideHostStatus_ == null) {
              OverrideHostStatus = new global::Envoy.Config.Core.V3.HealthStatusSet();
            }
            OverrideHostStatus.MergeFrom(other.OverrideHostStatus);
          }
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              if (ZoneAwareLbConfig == null) {
                ZoneAwareLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
              }
              ZoneAwareLbConfig.MergeFrom(other.ZoneAwareLbConfig);
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              if (LocalityWeightedLbConfig == null) {
                LocalityWeightedLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
              }
              LocalityWeightedLbConfig.MergeFrom(other.LocalityWeightedLbConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  HealthyPanicThreshold = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(HealthyPanicThreshold);
                break;
              }
              case 18: {
                global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
              case 34: {
                if (updateMergeWindow_ == null) {
                  UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(UpdateMergeWindow);
                break;
              }
              case 40: {
                IgnoreNewHostsUntilFirstHc = input.ReadBool();
                break;
              }
              case 48: {
                CloseConnectionsOnHostSetChange = input.ReadBool();
                break;
              }
              case 58: {
                if (consistentHashingLbConfig_ == null) {
                  ConsistentHashingLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
                }
                input.ReadMessage(ConsistentHashingLbConfig);
                break;
              }
              case 66: {
                if (overrideHostStatus_ == null) {
                  OverrideHostStatus = new global::Envoy.Config.Core.V3.HealthStatusSet();
                }
                input.ReadMessage(OverrideHostStatus);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  HealthyPanicThreshold = new global::Envoy.Type.V3.Percent();
                }
                input.ReadMessage(HealthyPanicThreshold);
                break;
              }
              case 18: {
                global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
              case 34: {
                if (updateMergeWindow_ == null) {
                  UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(UpdateMergeWindow);
                break;
              }
              case 40: {
                IgnoreNewHostsUntilFirstHc = input.ReadBool();
                break;
              }
              case 48: {
                CloseConnectionsOnHostSetChange = input.ReadBool();
                break;
              }
              case 58: {
                if (consistentHashingLbConfig_ == null) {
                  ConsistentHashingLbConfig = new global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Types.ConsistentHashingLbConfig();
                }
                input.ReadMessage(ConsistentHashingLbConfig);
                break;
              }
              case 66: {
                if (overrideHostStatus_ == null) {
                  OverrideHostStatus = new global::Envoy.Config.Core.V3.HealthStatusSet();
                }
                input.ReadMessage(OverrideHostStatus);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the CommonLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Configuration for :ref:`zone aware routing
          /// &lt;arch_overview_load_balancing_zone_aware_routing>`.
          /// </summary>
          public sealed partial class ZoneAwareLbConfig : pb::IMessage<ZoneAwareLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ZoneAwareLbConfig> _parser = new pb::MessageParser<ZoneAwareLbConfig>(() => new ZoneAwareLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ZoneAwareLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig(ZoneAwareLbConfig other) : this() {
              routingEnabled_ = other.routingEnabled_ != null ? other.routingEnabled_.Clone() : null;
              MinClusterSize = other.MinClusterSize;
              failTrafficOnPanic_ = other.failTrafficOnPanic_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ZoneAwareLbConfig Clone() {
              return new ZoneAwareLbConfig(this);
            }

            /// <summary>Field number for the "routing_enabled" field.</summary>
            public const int RoutingEnabledFieldNumber = 1;
            private global::Envoy.Type.V3.Percent routingEnabled_;
            /// <summary>
            /// Configures percentage of requests that will be considered for zone aware routing
            /// if zone aware routing is configured. If not specified, the default is 100%.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.V3.Percent RoutingEnabled {
              get { return routingEnabled_; }
              set {
                routingEnabled_ = value;
              }
            }

            /// <summary>Field number for the "min_cluster_size" field.</summary>
            public const int MinClusterSizeFieldNumber = 2;
            private static readonly pb::FieldCodec<ulong?> _single_minClusterSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(18);
            private ulong? minClusterSize_;
            /// <summary>
            /// Configures minimum upstream cluster size required for zone aware routing
            /// If upstream cluster size is less than specified, zone aware routing is not performed
            /// even if zone aware routing is configured. If not specified, the default is 6.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ulong? MinClusterSize {
              get { return minClusterSize_; }
              set {
                minClusterSize_ = value;
              }
            }


            /// <summary>Field number for the "fail_traffic_on_panic" field.</summary>
            public const int FailTrafficOnPanicFieldNumber = 3;
            private bool failTrafficOnPanic_;
            /// <summary>
            /// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
            /// mode&lt;arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
            /// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
            /// failing service.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool FailTrafficOnPanic {
              get { return failTrafficOnPanic_; }
              set {
                failTrafficOnPanic_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ZoneAwareLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ZoneAwareLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(RoutingEnabled, other.RoutingEnabled)) return false;
              if (MinClusterSize != other.MinClusterSize) return false;
              if (FailTrafficOnPanic != other.FailTrafficOnPanic) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (routingEnabled_ != null) hash ^= RoutingEnabled.GetHashCode();
              if (minClusterSize_ != null) hash ^= MinClusterSize.GetHashCode();
              if (FailTrafficOnPanic != false) hash ^= FailTrafficOnPanic.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(output, MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                output.WriteRawTag(24);
                output.WriteBool(FailTrafficOnPanic);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(ref output, MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                output.WriteRawTag(24);
                output.WriteBool(FailTrafficOnPanic);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (routingEnabled_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                size += _single_minClusterSize_codec.CalculateSizeWithTag(MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ZoneAwareLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.routingEnabled_ != null) {
                if (routingEnabled_ == null) {
                  RoutingEnabled = new global::Envoy.Type.V3.Percent();
                }
                RoutingEnabled.MergeFrom(other.RoutingEnabled);
              }
              if (other.minClusterSize_ != null) {
                if (minClusterSize_ == null || other.MinClusterSize != 0UL) {
                  MinClusterSize = other.MinClusterSize;
                }
              }
              if (other.FailTrafficOnPanic != false) {
                FailTrafficOnPanic = other.FailTrafficOnPanic;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      RoutingEnabled = new global::Envoy.Type.V3.Percent();
                    }
                    input.ReadMessage(RoutingEnabled);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                  case 24: {
                    FailTrafficOnPanic = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      RoutingEnabled = new global::Envoy.Type.V3.Percent();
                    }
                    input.ReadMessage(RoutingEnabled);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(ref input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                  case 24: {
                    FailTrafficOnPanic = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Configuration for :ref:`locality weighted load balancing
          /// &lt;arch_overview_load_balancing_locality_weighted_lb>`
          /// </summary>
          public sealed partial class LocalityWeightedLbConfig : pb::IMessage<LocalityWeightedLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<LocalityWeightedLbConfig> _parser = new pb::MessageParser<LocalityWeightedLbConfig>(() => new LocalityWeightedLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<LocalityWeightedLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig(LocalityWeightedLbConfig other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public LocalityWeightedLbConfig Clone() {
              return new LocalityWeightedLbConfig(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as LocalityWeightedLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(LocalityWeightedLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(LocalityWeightedLbConfig other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
          /// </summary>
          public sealed partial class ConsistentHashingLbConfig : pb::IMessage<ConsistentHashingLbConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ConsistentHashingLbConfig> _parser = new pb::MessageParser<ConsistentHashingLbConfig>(() => new ConsistentHashingLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ConsistentHashingLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Cluster.V3.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig(ConsistentHashingLbConfig other) : this() {
              useHostnameForHashing_ = other.useHostnameForHashing_;
              HashBalanceFactor = other.HashBalanceFactor;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConsistentHashingLbConfig Clone() {
              return new ConsistentHashingLbConfig(this);
            }

            /// <summary>Field number for the "use_hostname_for_hashing" field.</summary>
            public const int UseHostnameForHashingFieldNumber = 1;
            private bool useHostnameForHashing_;
            /// <summary>
            /// If set to `true`, the cluster will use hostname instead of the resolved
            /// address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool UseHostnameForHashing {
              get { return useHostnameForHashing_; }
              set {
                useHostnameForHashing_ = value;
              }
            }

            /// <summary>Field number for the "hash_balance_factor" field.</summary>
            public const int HashBalanceFactorFieldNumber = 2;
            private static readonly pb::FieldCodec<uint?> _single_hashBalanceFactor_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
            private uint? hashBalanceFactor_;
            /// <summary>
            /// Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
            /// no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
            /// If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
            /// Minimum is 100.
            ///
            /// Applies to both Ring Hash and Maglev load balancers.
            ///
            /// This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
            /// `hash_balance_factor`, requests to any upstream host are capped at `hash_balance_factor/100` times the average number of requests
            /// across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
            /// is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
            /// the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
            /// cascading overflow effect when choosing the next host in the ring/table).
            ///
            /// If weights are specified on the hosts, they are respected.
            ///
            /// This is an O(N) algorithm, unlike other load balancers. Using a lower `hash_balance_factor` results in more hosts
            /// being probed, so use a higher value if you require better performance.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint? HashBalanceFactor {
              get { return hashBalanceFactor_; }
              set {
                hashBalanceFactor_ = value;
              }
            }


            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ConsistentHashingLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ConsistentHashingLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (UseHostnameForHashing != other.UseHostnameForHashing) return false;
              if (HashBalanceFactor != other.HashBalanceFactor) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (UseHostnameForHashing != false) hash ^= UseHostnameForHashing.GetHashCode();
              if (hashBalanceFactor_ != null) hash ^= HashBalanceFactor.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (UseHostnameForHashing != false) {
                output.WriteRawTag(8);
                output.WriteBool(UseHostnameForHashing);
              }
              if (hashBalanceFactor_ != null) {
                _single_hashBalanceFactor_codec.WriteTagAndValue(output, HashBalanceFactor);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (UseHostnameForHashing != false) {
                output.WriteRawTag(8);
                output.WriteBool(UseHostnameForHashing);
              }
              if (hashBalanceFactor_ != null) {
                _single_hashBalanceFactor_codec.WriteTagAndValue(ref output, HashBalanceFactor);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (UseHostnameForHashing != false) {
                size += 1 + 1;
              }
              if (hashBalanceFactor_ != null) {
                size += _single_hashBalanceFactor_codec.CalculateSizeWithTag(HashBalanceFactor);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ConsistentHashingLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.UseHostnameForHashing != false) {
                UseHostnameForHashing = other.UseHostnameForHashing;
              }
              if (other.hashBalanceFactor_ != null) {
                if (hashBalanceFactor_ == null || other.HashBalanceFactor != 0) {
                  HashBalanceFactor = other.HashBalanceFactor;
                }
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    UseHostnameForHashing = input.ReadBool();
                    break;
                  }
                  case 18: {
                    uint? value = _single_hashBalanceFactor_codec.Read(input);
                    if (hashBalanceFactor_ == null || value != 0) {
                      HashBalanceFactor = value;
                    }
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    UseHostnameForHashing = input.ReadBool();
                    break;
                  }
                  case 18: {
                    uint? value = _single_hashBalanceFactor_codec.Read(ref input);
                    if (hashBalanceFactor_ == null || value != 0) {
                      HashBalanceFactor = value;
                    }
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      public sealed partial class RefreshRate : pb::IMessage<RefreshRate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RefreshRate> _parser = new pb::MessageParser<RefreshRate>(() => new RefreshRate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RefreshRate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[11]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate(RefreshRate other) : this() {
          baseInterval_ = other.baseInterval_ != null ? other.baseInterval_.Clone() : null;
          maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RefreshRate Clone() {
          return new RefreshRate(this);
        }

        /// <summary>Field number for the "base_interval" field.</summary>
        public const int BaseIntervalFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration baseInterval_;
        /// <summary>
        /// Specifies the base interval between refreshes. This parameter is required and must be greater
        /// than zero and less than
        /// :ref:`max_interval &lt;envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration BaseInterval {
          get { return baseInterval_; }
          set {
            baseInterval_ = value;
          }
        }

        /// <summary>Field number for the "max_interval" field.</summary>
        public const int MaxIntervalFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
        /// <summary>
        /// Specifies the maximum interval between refreshes. This parameter is optional, but must be
        /// greater than or equal to the
        /// :ref:`base_interval &lt;envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
        /// is 10 times the :ref:`base_interval &lt;envoy_v3_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
          get { return maxInterval_; }
          set {
            maxInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RefreshRate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RefreshRate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BaseInterval, other.BaseInterval)) return false;
          if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (baseInterval_ != null) hash ^= BaseInterval.GetHashCode();
          if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (baseInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseInterval);
          }
          if (maxInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RefreshRate other) {
          if (other == null) {
            return;
          }
          if (other.baseInterval_ != null) {
            if (baseInterval_ == null) {
              BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BaseInterval.MergeFrom(other.BaseInterval);
          }
          if (other.maxInterval_ != null) {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterval.MergeFrom(other.MaxInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class PreconnectPolicy : pb::IMessage<PreconnectPolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PreconnectPolicy> _parser = new pb::MessageParser<PreconnectPolicy>(() => new PreconnectPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PreconnectPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.Cluster.Descriptor.NestedTypes[12]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PreconnectPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PreconnectPolicy(PreconnectPolicy other) : this() {
          PerUpstreamPreconnectRatio = other.PerUpstreamPreconnectRatio;
          PredictivePreconnectRatio = other.PredictivePreconnectRatio;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PreconnectPolicy Clone() {
          return new PreconnectPolicy(this);
        }

        /// <summary>Field number for the "per_upstream_preconnect_ratio" field.</summary>
        public const int PerUpstreamPreconnectRatioFieldNumber = 1;
        private static readonly pb::FieldCodec<double?> _single_perUpstreamPreconnectRatio_codec = pb::FieldCodec.ForStructWrapper<double>(10);
        private double? perUpstreamPreconnectRatio_;
        /// <summary>
        /// Indicates how many streams (rounded up) can be anticipated per-upstream for each
        /// incoming stream. This is useful for high-QPS or latency-sensitive services. Preconnecting
        /// will only be done if the upstream is healthy and the cluster has traffic.
        ///
        /// For example if this is 2, for an incoming HTTP/1.1 stream, 2 connections will be
        /// established, one for the new incoming stream, and one for a presumed follow-up stream. For
        /// HTTP/2, only one connection would be established by default as one connection can
        /// serve both the original and presumed follow-up stream.
        ///
        /// In steady state for non-multiplexed connections a value of 1.5 would mean if there were 100
        /// active streams, there would be 100 connections in use, and 50 connections preconnected.
        /// This might be a useful value for something like short lived single-use connections,
        /// for example proxying HTTP/1.1 if keep-alive were false and each stream resulted in connection
        /// termination. It would likely be overkill for long lived connections, such as TCP proxying SMTP
        /// or regular HTTP/1.1 with keep-alive. For long lived traffic, a value of 1.05 would be more
        /// reasonable, where for every 100 connections, 5 preconnected connections would be in the queue
        /// in case of unexpected disconnects where the connection could not be reused.
        ///
        /// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
        /// as needed to serve streams in flight. This means in steady state if a connection is torn down,
        /// a subsequent streams will pay an upstream-rtt latency penalty waiting for a new connection.
        ///
        /// This is limited somewhat arbitrarily to 3 because preconnecting too aggressively can
        /// harm latency more than the preconnecting helps.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double? PerUpstreamPreconnectRatio {
          get { return perUpstreamPreconnectRatio_; }
          set {
            perUpstreamPreconnectRatio_ = value;
          }
        }


        /// <summary>Field number for the "predictive_preconnect_ratio" field.</summary>
        public const int PredictivePreconnectRatioFieldNumber = 2;
        private static readonly pb::FieldCodec<double?> _single_predictivePreconnectRatio_codec = pb::FieldCodec.ForStructWrapper<double>(18);
        private double? predictivePreconnectRatio_;
        /// <summary>
        /// Indicates how many many streams (rounded up) can be anticipated across a cluster for each
        /// stream, useful for low QPS services. This is currently supported for a subset of
        /// deterministic non-hash-based load-balancing algorithms (weighted round robin, random).
        /// Unlike *per_upstream_preconnect_ratio* this preconnects across the upstream instances in a
        /// cluster, doing best effort predictions of what upstream would be picked next and
        /// pre-establishing a connection.
        ///
        /// Preconnecting will be limited to one preconnect per configured upstream in the cluster and will
        /// only be done if there are healthy upstreams and the cluster has traffic.
        ///
        /// For example if preconnecting is set to 2 for a round robin HTTP/2 cluster, on the first
        /// incoming stream, 2 connections will be preconnected - one to the first upstream for this
        /// cluster, one to the second on the assumption there will be a follow-up stream.
        ///
        /// If this value is not set, or set explicitly to one, Envoy will fetch as many connections
        /// as needed to serve streams in flight, so during warm up and in steady state if a connection
        /// is closed (and per_upstream_preconnect_ratio is not set), there will be a latency hit for
        /// connection establishment.
        ///
        /// If both this and preconnect_ratio are set, Envoy will make sure both predicted needs are met,
        /// basically preconnecting max(predictive-preconnect, per-upstream-preconnect), for each
        /// upstream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double? PredictivePreconnectRatio {
          get { return predictivePreconnectRatio_; }
          set {
            predictivePreconnectRatio_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PreconnectPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PreconnectPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(PerUpstreamPreconnectRatio, other.PerUpstreamPreconnectRatio)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(PredictivePreconnectRatio, other.PredictivePreconnectRatio)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (perUpstreamPreconnectRatio_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(PerUpstreamPreconnectRatio);
          if (predictivePreconnectRatio_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(PredictivePreconnectRatio);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (perUpstreamPreconnectRatio_ != null) {
            _single_perUpstreamPreconnectRatio_codec.WriteTagAndValue(output, PerUpstreamPreconnectRatio);
          }
          if (predictivePreconnectRatio_ != null) {
            _single_predictivePreconnectRatio_codec.WriteTagAndValue(output, PredictivePreconnectRatio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (perUpstreamPreconnectRatio_ != null) {
            _single_perUpstreamPreconnectRatio_codec.WriteTagAndValue(ref output, PerUpstreamPreconnectRatio);
          }
          if (predictivePreconnectRatio_ != null) {
            _single_predictivePreconnectRatio_codec.WriteTagAndValue(ref output, PredictivePreconnectRatio);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (perUpstreamPreconnectRatio_ != null) {
            size += _single_perUpstreamPreconnectRatio_codec.CalculateSizeWithTag(PerUpstreamPreconnectRatio);
          }
          if (predictivePreconnectRatio_ != null) {
            size += _single_predictivePreconnectRatio_codec.CalculateSizeWithTag(PredictivePreconnectRatio);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PreconnectPolicy other) {
          if (other == null) {
            return;
          }
          if (other.perUpstreamPreconnectRatio_ != null) {
            if (perUpstreamPreconnectRatio_ == null || other.PerUpstreamPreconnectRatio != 0D) {
              PerUpstreamPreconnectRatio = other.PerUpstreamPreconnectRatio;
            }
          }
          if (other.predictivePreconnectRatio_ != null) {
            if (predictivePreconnectRatio_ == null || other.PredictivePreconnectRatio != 0D) {
              PredictivePreconnectRatio = other.PredictivePreconnectRatio;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                double? value = _single_perUpstreamPreconnectRatio_codec.Read(input);
                if (perUpstreamPreconnectRatio_ == null || value != 0D) {
                  PerUpstreamPreconnectRatio = value;
                }
                break;
              }
              case 18: {
                double? value = _single_predictivePreconnectRatio_codec.Read(input);
                if (predictivePreconnectRatio_ == null || value != 0D) {
                  PredictivePreconnectRatio = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                double? value = _single_perUpstreamPreconnectRatio_codec.Read(ref input);
                if (perUpstreamPreconnectRatio_ == null || value != 0D) {
                  PerUpstreamPreconnectRatio = value;
                }
                break;
              }
              case 18: {
                double? value = _single_predictivePreconnectRatio_codec.Read(ref input);
                if (predictivePreconnectRatio_ == null || value != 0D) {
                  PredictivePreconnectRatio = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Extensible load balancing policy configuration.
  ///
  /// Every LB policy defined via this mechanism will be identified via a unique name using reverse
  /// DNS notation. If the policy needs configuration parameters, it must define a message for its
  /// own configuration, which will be stored in the config field. The name of the policy will tell
  /// clients which type of message they should expect to see in the config field.
  ///
  /// Note that there are cases where it is useful to be able to independently select LB policies
  /// for choosing a locality and for choosing an endpoint within that locality. For example, a
  /// given deployment may always use the same policy to choose the locality, but for choosing the
  /// endpoint within the locality, some clusters may use weighted-round-robin, while others may
  /// use some sort of session-based balancing.
  ///
  /// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
  /// child LB policy for each locality. For each request, the parent chooses the locality and then
  /// delegates to the child policy for that locality to choose the endpoint within the locality.
  ///
  /// To facilitate this, the config message for the top-level LB policy may include a field of
  /// type LoadBalancingPolicy that specifies the child policy.
  /// </summary>
  public sealed partial class LoadBalancingPolicy : pb::IMessage<LoadBalancingPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LoadBalancingPolicy> _parser = new pb::MessageParser<LoadBalancingPolicy>(() => new LoadBalancingPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LoadBalancingPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy(LoadBalancingPolicy other) : this() {
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancingPolicy Clone() {
      return new LoadBalancingPolicy(this);
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy> _repeated_policies_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy> policies_ = new pbc::RepeatedField<global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy>();
    /// <summary>
    /// Each client will iterate over the list in order and stop at the first policy that it
    /// supports. This provides a mechanism for starting to use new LB policies that are not yet
    /// supported by all clients.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Types.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancingPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LoadBalancingPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!policies_.Equals(other.policies_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= policies_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      policies_.WriteTo(output, _repeated_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      policies_.WriteTo(ref output, _repeated_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += policies_.CalculateSize(_repeated_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LoadBalancingPolicy other) {
      if (other == null) {
        return;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            policies_.AddEntriesFrom(input, _repeated_policies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            policies_.AddEntriesFrom(ref input, _repeated_policies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LoadBalancingPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class Policy : pb::IMessage<Policy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Policy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Cluster.V3.LoadBalancingPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy(Policy other) : this() {
          typedExtensionConfig_ = other.typedExtensionConfig_ != null ? other.typedExtensionConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy Clone() {
          return new Policy(this);
        }

        /// <summary>Field number for the "typed_extension_config" field.</summary>
        public const int TypedExtensionConfigFieldNumber = 4;
        private global::Envoy.Config.Core.V3.TypedExtensionConfig typedExtensionConfig_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.TypedExtensionConfig TypedExtensionConfig {
          get { return typedExtensionConfig_; }
          set {
            typedExtensionConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Policy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Policy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(TypedExtensionConfig, other.TypedExtensionConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typedExtensionConfig_ != null) hash ^= TypedExtensionConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typedExtensionConfig_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(TypedExtensionConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typedExtensionConfig_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(TypedExtensionConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typedExtensionConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedExtensionConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Policy other) {
          if (other == null) {
            return;
          }
          if (other.typedExtensionConfig_ != null) {
            if (typedExtensionConfig_ == null) {
              TypedExtensionConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            TypedExtensionConfig.MergeFrom(other.TypedExtensionConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 34: {
                if (typedExtensionConfig_ == null) {
                  TypedExtensionConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                }
                input.ReadMessage(TypedExtensionConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 34: {
                if (typedExtensionConfig_ == null) {
                  TypedExtensionConfig = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                }
                input.ReadMessage(TypedExtensionConfig);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// An extensible structure containing the address Envoy should bind to when
  /// establishing upstream connections.
  /// </summary>
  public sealed partial class UpstreamBindConfig : pb::IMessage<UpstreamBindConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamBindConfig> _parser = new pb::MessageParser<UpstreamBindConfig>(() => new UpstreamBindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamBindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig(UpstreamBindConfig other) : this() {
      sourceAddress_ = other.sourceAddress_ != null ? other.sourceAddress_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamBindConfig Clone() {
      return new UpstreamBindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Config.Core.V3.Address sourceAddress_;
    /// <summary>
    /// The address Envoy should bind to when establishing upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Address SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamBindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamBindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamBindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          SourceAddress = new global::Envoy.Config.Core.V3.Address();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Config.Core.V3.Address();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Config.Core.V3.Address();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UpstreamConnectionOptions : pb::IMessage<UpstreamConnectionOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpstreamConnectionOptions> _parser = new pb::MessageParser<UpstreamConnectionOptions>(() => new UpstreamConnectionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpstreamConnectionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions(UpstreamConnectionOptions other) : this() {
      tcpKeepalive_ = other.tcpKeepalive_ != null ? other.tcpKeepalive_.Clone() : null;
      setLocalInterfaceNameOnUpstreamConnections_ = other.setLocalInterfaceNameOnUpstreamConnections_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpstreamConnectionOptions Clone() {
      return new UpstreamConnectionOptions(this);
    }

    /// <summary>Field number for the "tcp_keepalive" field.</summary>
    public const int TcpKeepaliveFieldNumber = 1;
    private global::Envoy.Config.Core.V3.TcpKeepalive tcpKeepalive_;
    /// <summary>
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TcpKeepalive TcpKeepalive {
      get { return tcpKeepalive_; }
      set {
        tcpKeepalive_ = value;
      }
    }

    /// <summary>Field number for the "set_local_interface_name_on_upstream_connections" field.</summary>
    public const int SetLocalInterfaceNameOnUpstreamConnectionsFieldNumber = 2;
    private bool setLocalInterfaceNameOnUpstreamConnections_;
    /// <summary>
    /// If enabled, associates the interface name of the local address with the upstream connection.
    /// This can be used by extensions during processing of requests. The association mechanism is
    /// implementation specific. Defaults to false due to performance concerns.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetLocalInterfaceNameOnUpstreamConnections {
      get { return setLocalInterfaceNameOnUpstreamConnections_; }
      set {
        setLocalInterfaceNameOnUpstreamConnections_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpstreamConnectionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpstreamConnectionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TcpKeepalive, other.TcpKeepalive)) return false;
      if (SetLocalInterfaceNameOnUpstreamConnections != other.SetLocalInterfaceNameOnUpstreamConnections) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (tcpKeepalive_ != null) hash ^= TcpKeepalive.GetHashCode();
      if (SetLocalInterfaceNameOnUpstreamConnections != false) hash ^= SetLocalInterfaceNameOnUpstreamConnections.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (SetLocalInterfaceNameOnUpstreamConnections != false) {
        output.WriteRawTag(16);
        output.WriteBool(SetLocalInterfaceNameOnUpstreamConnections);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (SetLocalInterfaceNameOnUpstreamConnections != false) {
        output.WriteRawTag(16);
        output.WriteBool(SetLocalInterfaceNameOnUpstreamConnections);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (tcpKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpKeepalive);
      }
      if (SetLocalInterfaceNameOnUpstreamConnections != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpstreamConnectionOptions other) {
      if (other == null) {
        return;
      }
      if (other.tcpKeepalive_ != null) {
        if (tcpKeepalive_ == null) {
          TcpKeepalive = new global::Envoy.Config.Core.V3.TcpKeepalive();
        }
        TcpKeepalive.MergeFrom(other.TcpKeepalive);
      }
      if (other.SetLocalInterfaceNameOnUpstreamConnections != false) {
        SetLocalInterfaceNameOnUpstreamConnections = other.SetLocalInterfaceNameOnUpstreamConnections;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              TcpKeepalive = new global::Envoy.Config.Core.V3.TcpKeepalive();
            }
            input.ReadMessage(TcpKeepalive);
            break;
          }
          case 16: {
            SetLocalInterfaceNameOnUpstreamConnections = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              TcpKeepalive = new global::Envoy.Config.Core.V3.TcpKeepalive();
            }
            input.ReadMessage(TcpKeepalive);
            break;
          }
          case 16: {
            SetLocalInterfaceNameOnUpstreamConnections = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TrackClusterStats : pb::IMessage<TrackClusterStats>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TrackClusterStats> _parser = new pb::MessageParser<TrackClusterStats>(() => new TrackClusterStats());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TrackClusterStats> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Cluster.V3.ClusterReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackClusterStats() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackClusterStats(TrackClusterStats other) : this() {
      timeoutBudgets_ = other.timeoutBudgets_;
      requestResponseSizes_ = other.requestResponseSizes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrackClusterStats Clone() {
      return new TrackClusterStats(this);
    }

    /// <summary>Field number for the "timeout_budgets" field.</summary>
    public const int TimeoutBudgetsFieldNumber = 1;
    private bool timeoutBudgets_;
    /// <summary>
    /// If timeout_budgets is true, the :ref:`timeout budget histograms
    /// &lt;config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
    /// request. These show what percentage of a request's per try and global timeout was used. A value
    /// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
    /// of 100 would indicate that the request took the entirety of the timeout given to it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TimeoutBudgets {
      get { return timeoutBudgets_; }
      set {
        timeoutBudgets_ = value;
      }
    }

    /// <summary>Field number for the "request_response_sizes" field.</summary>
    public const int RequestResponseSizesFieldNumber = 2;
    private bool requestResponseSizes_;
    /// <summary>
    /// If request_response_sizes is true, then the :ref:`histograms
    /// &lt;config_cluster_manager_cluster_stats_request_response_sizes>`  tracking header and body sizes
    /// of requests and responses will be published.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RequestResponseSizes {
      get { return requestResponseSizes_; }
      set {
        requestResponseSizes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TrackClusterStats);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TrackClusterStats other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TimeoutBudgets != other.TimeoutBudgets) return false;
      if (RequestResponseSizes != other.RequestResponseSizes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TimeoutBudgets != false) hash ^= TimeoutBudgets.GetHashCode();
      if (RequestResponseSizes != false) hash ^= RequestResponseSizes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TimeoutBudgets != false) {
        output.WriteRawTag(8);
        output.WriteBool(TimeoutBudgets);
      }
      if (RequestResponseSizes != false) {
        output.WriteRawTag(16);
        output.WriteBool(RequestResponseSizes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TimeoutBudgets != false) {
        output.WriteRawTag(8);
        output.WriteBool(TimeoutBudgets);
      }
      if (RequestResponseSizes != false) {
        output.WriteRawTag(16);
        output.WriteBool(RequestResponseSizes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TimeoutBudgets != false) {
        size += 1 + 1;
      }
      if (RequestResponseSizes != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TrackClusterStats other) {
      if (other == null) {
        return;
      }
      if (other.TimeoutBudgets != false) {
        TimeoutBudgets = other.TimeoutBudgets;
      }
      if (other.RequestResponseSizes != false) {
        RequestResponseSizes = other.RequestResponseSizes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TimeoutBudgets = input.ReadBool();
            break;
          }
          case 16: {
            RequestResponseSizes = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TimeoutBudgets = input.ReadBool();
            break;
          }
          case 16: {
            RequestResponseSizes = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
