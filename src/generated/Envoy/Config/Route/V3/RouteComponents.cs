// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/route/v3/route_components.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Route.V3 {

  /// <summary>Holder for reflection information generated from envoy/config/route/v3/route_components.proto</summary>
  public static partial class RouteComponentsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/route/v3/route_components.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RouteComponentsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CixlbnZveS9jb25maWcvcm91dGUvdjMvcm91dGVfY29tcG9uZW50cy5wcm90",
            "bxIVZW52b3kuY29uZmlnLnJvdXRlLnYzGh9lbnZveS9jb25maWcvY29yZS92",
            "My9iYXNlLnByb3RvGiRlbnZveS9jb25maWcvY29yZS92My9leHRlbnNpb24u",
            "cHJvdG8aKWVudm95L2NvbmZpZy9jb3JlL3YzL3Byb3h5X3Byb3RvY29sLnBy",
            "b3RvGiRlbnZveS90eXBlL21hdGNoZXIvdjMvbWV0YWRhdGEucHJvdG8aIWVu",
            "dm95L3R5cGUvbWF0Y2hlci92My9yZWdleC5wcm90bxoiZW52b3kvdHlwZS9t",
            "YXRjaGVyL3YzL3N0cmluZy5wcm90bxolZW52b3kvdHlwZS9tZXRhZGF0YS92",
            "My9tZXRhZGF0YS5wcm90bxomZW52b3kvdHlwZS90cmFjaW5nL3YzL2N1c3Rv",
            "bV90YWcucHJvdG8aG2Vudm95L3R5cGUvdjMvcGVyY2VudC5wcm90bxoZZW52",
            "b3kvdHlwZS92My9yYW5nZS5wcm90bxoZZ29vZ2xlL3Byb3RvYnVmL2FueS5w",
            "cm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh5nb29nbGUv",
            "cHJvdG9idWYvd3JhcHBlcnMucHJvdG8aH3hkcy9hbm5vdGF0aW9ucy92My9z",
            "dGF0dXMucHJvdG8aIXhkcy90eXBlL21hdGNoZXIvdjMvbWF0Y2hlci5wcm90",
            "bxojZW52b3kvYW5ub3RhdGlvbnMvZGVwcmVjYXRpb24ucHJvdG8aHnVkcGEv",
            "YW5ub3RhdGlvbnMvbWlncmF0ZS5wcm90bxoddWRwYS9hbm5vdGF0aW9ucy9z",
            "dGF0dXMucHJvdG8aIXVkcGEvYW5ub3RhdGlvbnMvdmVyc2lvbmluZy5wcm90",
            "bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8ipgsKC1ZpcnR1YWxIb3N0EhUK",
            "BG5hbWUYASABKAlCB/pCBHICEAESIwoHZG9tYWlucxgCIAMoCUIS+kIPkgEM",
            "CAEiCHIGwAECyAEAEiwKBnJvdXRlcxgDIAMoCzIcLmVudm95LmNvbmZpZy5y",
            "b3V0ZS52My5Sb3V0ZRI3CgdtYXRjaGVyGBUgASgLMhwueGRzLnR5cGUubWF0",
            "Y2hlci52My5NYXRjaGVyQgjSxqThBgIIARJUCgtyZXF1aXJlX3RscxgEIAEo",
            "DjI1LmVudm95LmNvbmZpZy5yb3V0ZS52My5WaXJ0dWFsSG9zdC5UbHNSZXF1",
            "aXJlbWVudFR5cGVCCPpCBYIBAhABEj8KEHZpcnR1YWxfY2x1c3RlcnMYBSAD",
            "KAsyJS5lbnZveS5jb25maWcucm91dGUudjMuVmlydHVhbENsdXN0ZXISNQoL",
            "cmF0ZV9saW1pdHMYBiADKAsyIC5lbnZveS5jb25maWcucm91dGUudjMuUmF0",
            "ZUxpbWl0ElIKFnJlcXVlc3RfaGVhZGVyc190b19hZGQYByADKAsyJy5lbnZv",
            "eS5jb25maWcuY29yZS52My5IZWFkZXJWYWx1ZU9wdGlvbkIJ+kIGkgEDEOgH",
            "EjUKGXJlcXVlc3RfaGVhZGVyc190b19yZW1vdmUYDSADKAlCEvpCD5IBDCIK",
            "cggQAcABAcgBABJTChdyZXNwb25zZV9oZWFkZXJzX3RvX2FkZBgKIAMoCzIn",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLkhlYWRlclZhbHVlT3B0aW9uQgn6QgaS",
            "AQMQ6AcSNgoacmVzcG9uc2VfaGVhZGVyc190b19yZW1vdmUYCyADKAlCEvpC",
            "D5IBDCIKcggQAcABAcgBABI8CgRjb3JzGAggASgLMiEuZW52b3kuY29uZmln",
            "LnJvdXRlLnYzLkNvcnNQb2xpY3lCCxgBkseG2AQDMy4wEl0KF3R5cGVkX3Bl",
            "cl9maWx0ZXJfY29uZmlnGA8gAygLMjwuZW52b3kuY29uZmlnLnJvdXRlLnYz",
            "LlZpcnR1YWxIb3N0LlR5cGVkUGVyRmlsdGVyQ29uZmlnRW50cnkSJQodaW5j",
            "bHVkZV9yZXF1ZXN0X2F0dGVtcHRfY291bnQYDiABKAgSKQohaW5jbHVkZV9h",
            "dHRlbXB0X2NvdW50X2luX3Jlc3BvbnNlGBMgASgIEjgKDHJldHJ5X3BvbGlj",
            "eRgQIAEoCzIiLmVudm95LmNvbmZpZy5yb3V0ZS52My5SZXRyeVBvbGljeRI3",
            "ChlyZXRyeV9wb2xpY3lfdHlwZWRfY29uZmlnGBQgASgLMhQuZ29vZ2xlLnBy",
            "b3RvYnVmLkFueRI4CgxoZWRnZV9wb2xpY3kYESABKAsyIi5lbnZveS5jb25m",
            "aWcucm91dGUudjMuSGVkZ2VQb2xpY3kSRAoecGVyX3JlcXVlc3RfYnVmZmVy",
            "X2xpbWl0X2J5dGVzGBIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZh",
            "bHVlElcKF3JlcXVlc3RfbWlycm9yX3BvbGljaWVzGBYgAygLMjYuZW52b3ku",
            "Y29uZmlnLnJvdXRlLnYzLlJvdXRlQWN0aW9uLlJlcXVlc3RNaXJyb3JQb2xp",
            "Y3kaUQoZVHlwZWRQZXJGaWx0ZXJDb25maWdFbnRyeRILCgNrZXkYASABKAkS",
            "IwoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55OgI4ASI6ChJU",
            "bHNSZXF1aXJlbWVudFR5cGUSCAoETk9ORRAAEhEKDUVYVEVSTkFMX09OTFkQ",
            "ARIHCgNBTEwQAjolmsWIHiAKHmVudm95LmFwaS52Mi5yb3V0ZS5WaXJ0dWFs",
            "SG9zdEoECAkQCkoECAwQDVIRcGVyX2ZpbHRlcl9jb25maWciXAoMRmlsdGVy",
            "QWN0aW9uEiQKBmFjdGlvbhgBIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5Bbnk6",
            "JprFiB4hCh9lbnZveS5hcGkudjIucm91dGUuRmlsdGVyQWN0aW9uIpoJCgVS",
            "b3V0ZRIMCgRuYW1lGA4gASgJEjoKBW1hdGNoGAEgASgLMiEuZW52b3kuY29u",
            "ZmlnLnJvdXRlLnYzLlJvdXRlTWF0Y2hCCPpCBYoBAhABEjMKBXJvdXRlGAIg",
            "ASgLMiIuZW52b3kuY29uZmlnLnJvdXRlLnYzLlJvdXRlQWN0aW9uSAASOQoI",
            "cmVkaXJlY3QYAyABKAsyJS5lbnZveS5jb25maWcucm91dGUudjMuUmVkaXJl",
            "Y3RBY3Rpb25IABJGCg9kaXJlY3RfcmVzcG9uc2UYByABKAsyKy5lbnZveS5j",
            "b25maWcucm91dGUudjMuRGlyZWN0UmVzcG9uc2VBY3Rpb25IABI8Cg1maWx0",
            "ZXJfYWN0aW9uGBEgASgLMiMuZW52b3kuY29uZmlnLnJvdXRlLnYzLkZpbHRl",
            "ckFjdGlvbkgAEksKFW5vbl9mb3J3YXJkaW5nX2FjdGlvbhgSIAEoCzIqLmVu",
            "dm95LmNvbmZpZy5yb3V0ZS52My5Ob25Gb3J3YXJkaW5nQWN0aW9uSAASMAoI",
            "bWV0YWRhdGEYBCABKAsyHi5lbnZveS5jb25maWcuY29yZS52My5NZXRhZGF0",
            "YRIzCglkZWNvcmF0b3IYBSABKAsyIC5lbnZveS5jb25maWcucm91dGUudjMu",
            "RGVjb3JhdG9yElcKF3R5cGVkX3Blcl9maWx0ZXJfY29uZmlnGA0gAygLMjYu",
            "ZW52b3kuY29uZmlnLnJvdXRlLnYzLlJvdXRlLlR5cGVkUGVyRmlsdGVyQ29u",
            "ZmlnRW50cnkSUgoWcmVxdWVzdF9oZWFkZXJzX3RvX2FkZBgJIAMoCzInLmVu",
            "dm95LmNvbmZpZy5jb3JlLnYzLkhlYWRlclZhbHVlT3B0aW9uQgn6QgaSAQMQ",
            "6AcSNQoZcmVxdWVzdF9oZWFkZXJzX3RvX3JlbW92ZRgMIAMoCUIS+kIPkgEM",
            "IgpyCBABwAEByAEAElMKF3Jlc3BvbnNlX2hlYWRlcnNfdG9fYWRkGAogAygL",
            "MicuZW52b3kuY29uZmlnLmNvcmUudjMuSGVhZGVyVmFsdWVPcHRpb25CCfpC",
            "BpIBAxDoBxI2ChpyZXNwb25zZV9oZWFkZXJzX3RvX3JlbW92ZRgLIAMoCUIS",
            "+kIPkgEMIgpyCBABwAEByAEAEi8KB3RyYWNpbmcYDyABKAsyHi5lbnZveS5j",
            "b25maWcucm91dGUudjMuVHJhY2luZxJECh5wZXJfcmVxdWVzdF9idWZmZXJf",
            "bGltaXRfYnl0ZXMYECABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFs",
            "dWUSEwoLc3RhdF9wcmVmaXgYEyABKAkaUQoZVHlwZWRQZXJGaWx0ZXJDb25m",
            "aWdFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC5nb29nbGUu",
            "cHJvdG9idWYuQW55OgI4ATofmsWIHhoKGGVudm95LmFwaS52Mi5yb3V0ZS5S",
            "b3V0ZUINCgZhY3Rpb24SA/hCAUoECAYQB0oECAgQCVIRcGVyX2ZpbHRlcl9j",
            "b25maWci/wgKD1dlaWdodGVkQ2x1c3RlchJQCghjbHVzdGVycxgBIAMoCzI0",
            "LmVudm95LmNvbmZpZy5yb3V0ZS52My5XZWlnaHRlZENsdXN0ZXIuQ2x1c3Rl",
            "cldlaWdodEII+kIFkgECCAESPwoMdG90YWxfd2VpZ2h0GAMgASgLMhwuZ29v",
            "Z2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgsYAZLHhtgEAzMuMBIaChJydW50",
            "aW1lX2tleV9wcmVmaXgYAiABKAkSIgoLaGVhZGVyX25hbWUYBCABKAlCC/pC",
            "CHIGwAEByAEASAAa0wYKDUNsdXN0ZXJXZWlnaHQSJwoEbmFtZRgBIAEoCUIZ",
            "8pj+jwUTEhFjbHVzdGVyX3NwZWNpZmllchI8Cg5jbHVzdGVyX2hlYWRlchgM",
            "IAEoCUIk+kIIcgbAAQHIAQDymP6PBRMSEWNsdXN0ZXJfc3BlY2lmaWVyEiwK",
            "BndlaWdodBgCIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZRI2",
            "Cg5tZXRhZGF0YV9tYXRjaBgDIAEoCzIeLmVudm95LmNvbmZpZy5jb3JlLnYz",
            "Lk1ldGFkYXRhElIKFnJlcXVlc3RfaGVhZGVyc190b19hZGQYBCADKAsyJy5l",
            "bnZveS5jb25maWcuY29yZS52My5IZWFkZXJWYWx1ZU9wdGlvbkIJ+kIGkgED",
            "EOgHEjMKGXJlcXVlc3RfaGVhZGVyc190b19yZW1vdmUYCSADKAlCEPpCDZIB",
            "CiIIcgbAAQHIAQASUwoXcmVzcG9uc2VfaGVhZGVyc190b19hZGQYBSADKAsy",
            "Jy5lbnZveS5jb25maWcuY29yZS52My5IZWFkZXJWYWx1ZU9wdGlvbkIJ+kIG",
            "kgEDEOgHEjQKGnJlc3BvbnNlX2hlYWRlcnNfdG9fcmVtb3ZlGAYgAygJQhD6",
            "Qg2SAQoiCHIGwAEByAEAEm8KF3R5cGVkX3Blcl9maWx0ZXJfY29uZmlnGAog",
            "AygLMk4uZW52b3kuY29uZmlnLnJvdXRlLnYzLldlaWdodGVkQ2x1c3Rlci5D",
            "bHVzdGVyV2VpZ2h0LlR5cGVkUGVyRmlsdGVyQ29uZmlnRW50cnkSKwoUaG9z",
            "dF9yZXdyaXRlX2xpdGVyYWwYCyABKAlCC/pCCHIGwAECyAEASAAaUQoZVHlw",
            "ZWRQZXJGaWx0ZXJDb25maWdFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUY",
            "AiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55OgI4ATo3msWIHjIKMGVudm95",
            "LmFwaS52Mi5yb3V0ZS5XZWlnaHRlZENsdXN0ZXIuQ2x1c3RlcldlaWdodEIY",
            "ChZob3N0X3Jld3JpdGVfc3BlY2lmaWVySgQIBxAISgQICBAJUhFwZXJfZmls",
            "dGVyX2NvbmZpZzopmsWIHiQKImVudm95LmFwaS52Mi5yb3V0ZS5XZWlnaHRl",
            "ZENsdXN0ZXJCGAoWcmFuZG9tX3ZhbHVlX3NwZWNpZmllciJ2ChZDbHVzdGVy",
            "U3BlY2lmaWVyUGx1Z2luEkcKCWV4dGVuc2lvbhgBIAEoCzIqLmVudm95LmNv",
            "bmZpZy5jb3JlLnYzLlR5cGVkRXh0ZW5zaW9uQ29uZmlnQgj6QgWKAQIQARIT",
            "Cgtpc19vcHRpb25hbBgCIAEoCCKDCQoKUm91dGVNYXRjaBIQCgZwcmVmaXgY",
            "ASABKAlIABIOCgRwYXRoGAIgASgJSAASQwoKc2FmZV9yZWdleBgKIAEoCzIj",
            "LmVudm95LnR5cGUubWF0Y2hlci52My5SZWdleE1hdGNoZXJCCPpCBYoBAhAB",
            "SAASSwoPY29ubmVjdF9tYXRjaGVyGAwgASgLMjAuZW52b3kuY29uZmlnLnJv",
            "dXRlLnYzLlJvdXRlTWF0Y2guQ29ubmVjdE1hdGNoZXJIABI2ChVwYXRoX3Nl",
            "cGFyYXRlZF9wcmVmaXgYDiABKAlCFfpCEnIQMg5eW14/I10rW14/Iy9dJEgA",
            "EkcKEXBhdGhfbWF0Y2hfcG9saWN5GA8gASgLMiouZW52b3kuY29uZmlnLmNv",
            "cmUudjMuVHlwZWRFeHRlbnNpb25Db25maWdIABIyCg5jYXNlX3NlbnNpdGl2",
            "ZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSSAoQcnVudGlt",
            "ZV9mcmFjdGlvbhgJIAEoCzIuLmVudm95LmNvbmZpZy5jb3JlLnYzLlJ1bnRp",
            "bWVGcmFjdGlvbmFsUGVyY2VudBI1CgdoZWFkZXJzGAYgAygLMiQuZW52b3ku",
            "Y29uZmlnLnJvdXRlLnYzLkhlYWRlck1hdGNoZXISRgoQcXVlcnlfcGFyYW1l",
            "dGVycxgHIAMoCzIsLmVudm95LmNvbmZpZy5yb3V0ZS52My5RdWVyeVBhcmFt",
            "ZXRlck1hdGNoZXISRQoEZ3JwYxgIIAEoCzI3LmVudm95LmNvbmZpZy5yb3V0",
            "ZS52My5Sb3V0ZU1hdGNoLkdycGNSb3V0ZU1hdGNoT3B0aW9ucxJNCgt0bHNf",
            "Y29udGV4dBgLIAEoCzI4LmVudm95LmNvbmZpZy5yb3V0ZS52My5Sb3V0ZU1h",
            "dGNoLlRsc0NvbnRleHRNYXRjaE9wdGlvbnMSQAoQZHluYW1pY19tZXRhZGF0",
            "YRgNIAMoCzImLmVudm95LnR5cGUubWF0Y2hlci52My5NZXRhZGF0YU1hdGNo",
            "ZXIaUwoVR3JwY1JvdXRlTWF0Y2hPcHRpb25zOjqaxYgeNQozZW52b3kuYXBp",
            "LnYyLnJvdXRlLlJvdXRlTWF0Y2guR3JwY1JvdXRlTWF0Y2hPcHRpb25zGrMB",
            "ChZUbHNDb250ZXh0TWF0Y2hPcHRpb25zEi0KCXByZXNlbnRlZBgBIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSLQoJdmFsaWRhdGVkGAIgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZTo7msWIHjYKNGVudm95LmFw",
            "aS52Mi5yb3V0ZS5Sb3V0ZU1hdGNoLlRsc0NvbnRleHRNYXRjaE9wdGlvbnMa",
            "EAoOQ29ubmVjdE1hdGNoZXI6JJrFiB4fCh1lbnZveS5hcGkudjIucm91dGUu",
            "Um91dGVNYXRjaEIVCg5wYXRoX3NwZWNpZmllchID+EIBSgQIBRAGSgQIAxAE",
            "UgVyZWdleCKvBAoKQ29yc1BvbGljeRJHChlhbGxvd19vcmlnaW5fc3RyaW5n",
            "X21hdGNoGAsgAygLMiQuZW52b3kudHlwZS5tYXRjaGVyLnYzLlN0cmluZ01h",
            "dGNoZXISFQoNYWxsb3dfbWV0aG9kcxgCIAEoCRIVCg1hbGxvd19oZWFkZXJz",
            "GAMgASgJEhYKDmV4cG9zZV9oZWFkZXJzGAQgASgJEg8KB21heF9hZ2UYBSAB",
            "KAkSNQoRYWxsb3dfY3JlZGVudGlhbHMYBiABKAsyGi5nb29nbGUucHJvdG9i",
            "dWYuQm9vbFZhbHVlEkgKDmZpbHRlcl9lbmFibGVkGAkgASgLMi4uZW52b3ku",
            "Y29uZmlnLmNvcmUudjMuUnVudGltZUZyYWN0aW9uYWxQZXJjZW50SAASRgoO",
            "c2hhZG93X2VuYWJsZWQYCiABKAsyLi5lbnZveS5jb25maWcuY29yZS52My5S",
            "dW50aW1lRnJhY3Rpb25hbFBlcmNlbnQSQAocYWxsb3dfcHJpdmF0ZV9uZXR3",
            "b3JrX2FjY2VzcxgMIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWU6",
            "JJrFiB4fCh1lbnZveS5hcGkudjIucm91dGUuQ29yc1BvbGljeUITChFlbmFi",
            "bGVkX3NwZWNpZmllckoECAEQAkoECAgQCUoECAcQCFIMYWxsb3dfb3JpZ2lu",
            "UhJhbGxvd19vcmlnaW5fcmVnZXhSB2VuYWJsZWQi9SMKC1JvdXRlQWN0aW9u",
            "EhoKB2NsdXN0ZXIYASABKAlCB/pCBHICEAFIABInCg5jbHVzdGVyX2hlYWRl",
            "chgCIAEoCUIN+kIKcggQAcABAcgBAEgAEkMKEXdlaWdodGVkX2NsdXN0ZXJz",
            "GAMgASgLMiYuZW52b3kuY29uZmlnLnJvdXRlLnYzLldlaWdodGVkQ2x1c3Rl",
            "ckgAEiIKGGNsdXN0ZXJfc3BlY2lmaWVyX3BsdWdpbhglIAEoCUgAElgKH2lu",
            "bGluZV9jbHVzdGVyX3NwZWNpZmllcl9wbHVnaW4YJyABKAsyLS5lbnZveS5j",
            "b25maWcucm91dGUudjMuQ2x1c3RlclNwZWNpZmllclBsdWdpbkgAEnEKH2Ns",
            "dXN0ZXJfbm90X2ZvdW5kX3Jlc3BvbnNlX2NvZGUYFCABKA4yPi5lbnZveS5j",
            "b25maWcucm91dGUudjMuUm91dGVBY3Rpb24uQ2x1c3Rlck5vdEZvdW5kUmVz",
            "cG9uc2VDb2RlQgj6QgWCAQIQARI2Cg5tZXRhZGF0YV9tYXRjaBgEIAEoCzIe",
            "LmVudm95LmNvbmZpZy5jb3JlLnYzLk1ldGFkYXRhEiMKDnByZWZpeF9yZXdy",
            "aXRlGAUgASgJQgv6QghyBsABAsgBABJFCg1yZWdleF9yZXdyaXRlGCAgASgL",
            "Mi4uZW52b3kudHlwZS5tYXRjaGVyLnYzLlJlZ2V4TWF0Y2hBbmRTdWJzdGl0",
            "dXRlEkcKE3BhdGhfcmV3cml0ZV9wb2xpY3kYKSABKAsyKi5lbnZveS5jb25m",
            "aWcuY29yZS52My5UeXBlZEV4dGVuc2lvbkNvbmZpZxIrChRob3N0X3Jld3Jp",
            "dGVfbGl0ZXJhbBgGIAEoCUIL+kIIcgbAAQLIAQBIARI3ChFhdXRvX2hvc3Rf",
            "cmV3cml0ZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVIARIq",
            "ChNob3N0X3Jld3JpdGVfaGVhZGVyGB0gASgJQgv6QghyBsABAcgBAEgBElEK",
            "F2hvc3RfcmV3cml0ZV9wYXRoX3JlZ2V4GCMgASgLMi4uZW52b3kudHlwZS5t",
            "YXRjaGVyLnYzLlJlZ2V4TWF0Y2hBbmRTdWJzdGl0dXRlSAESHwoXYXBwZW5k",
            "X3hfZm9yd2FyZGVkX2hvc3QYJiABKAgSKgoHdGltZW91dBgIIAEoCzIZLmdv",
            "b2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIvCgxpZGxlX3RpbWVvdXQYGCABKAsy",
            "GS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SRQoRZWFybHlfZGF0YV9wb2xp",
            "Y3kYKCABKAsyKi5lbnZveS5jb25maWcuY29yZS52My5UeXBlZEV4dGVuc2lv",
            "bkNvbmZpZxI4CgxyZXRyeV9wb2xpY3kYCSABKAsyIi5lbnZveS5jb25maWcu",
            "cm91dGUudjMuUmV0cnlQb2xpY3kSNwoZcmV0cnlfcG9saWN5X3R5cGVkX2Nv",
            "bmZpZxghIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnkSVwoXcmVxdWVzdF9t",
            "aXJyb3JfcG9saWNpZXMYHiADKAsyNi5lbnZveS5jb25maWcucm91dGUudjMu",
            "Um91dGVBY3Rpb24uUmVxdWVzdE1pcnJvclBvbGljeRJBCghwcmlvcml0eRgL",
            "IAEoDjIlLmVudm95LmNvbmZpZy5jb3JlLnYzLlJvdXRpbmdQcmlvcml0eUII",
            "+kIFggECEAESNQoLcmF0ZV9saW1pdHMYDSADKAsyIC5lbnZveS5jb25maWcu",
            "cm91dGUudjMuUmF0ZUxpbWl0EkcKFmluY2x1ZGVfdmhfcmF0ZV9saW1pdHMY",
            "DiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlQgsYAZLHhtgEAzMu",
            "MBJCCgtoYXNoX3BvbGljeRgPIAMoCzItLmVudm95LmNvbmZpZy5yb3V0ZS52",
            "My5Sb3V0ZUFjdGlvbi5IYXNoUG9saWN5EjwKBGNvcnMYESABKAsyIS5lbnZv",
            "eS5jb25maWcucm91dGUudjMuQ29yc1BvbGljeUILGAGSx4bYBAMzLjASQAoQ",
            "bWF4X2dycGNfdGltZW91dBgXIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJh",
            "dGlvbkILGAGSx4bYBAMzLjASQwoTZ3JwY190aW1lb3V0X29mZnNldBgcIAEo",
            "CzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkILGAGSx4bYBAMzLjASSQoP",
            "dXBncmFkZV9jb25maWdzGBkgAygLMjAuZW52b3kuY29uZmlnLnJvdXRlLnYz",
            "LlJvdXRlQWN0aW9uLlVwZ3JhZGVDb25maWcSTwoYaW50ZXJuYWxfcmVkaXJl",
            "Y3RfcG9saWN5GCIgASgLMi0uZW52b3kuY29uZmlnLnJvdXRlLnYzLkludGVy",
            "bmFsUmVkaXJlY3RQb2xpY3kSaAoYaW50ZXJuYWxfcmVkaXJlY3RfYWN0aW9u",
            "GBogASgOMjkuZW52b3kuY29uZmlnLnJvdXRlLnYzLlJvdXRlQWN0aW9uLklu",
            "dGVybmFsUmVkaXJlY3RBY3Rpb25CCxgBkseG2AQDMy4wEkkKFm1heF9pbnRl",
            "cm5hbF9yZWRpcmVjdHMYHyABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMy",
            "VmFsdWVCCxgBkseG2AQDMy4wEjgKDGhlZGdlX3BvbGljeRgbIAEoCzIiLmVu",
            "dm95LmNvbmZpZy5yb3V0ZS52My5IZWRnZVBvbGljeRJRChNtYXhfc3RyZWFt",
            "X2R1cmF0aW9uGCQgASgLMjQuZW52b3kuY29uZmlnLnJvdXRlLnYzLlJvdXRl",
            "QWN0aW9uLk1heFN0cmVhbUR1cmF0aW9uGsoCChNSZXF1ZXN0TWlycm9yUG9s",
            "aWN5EioKB2NsdXN0ZXIYASABKAlCGfKY/o8FExIRY2x1c3Rlcl9zcGVjaWZp",
            "ZXISPAoOY2x1c3Rlcl9oZWFkZXIYBSABKAlCJPpCCHIGwAEByAEA8pj+jwUT",
            "EhFjbHVzdGVyX3NwZWNpZmllchJIChBydW50aW1lX2ZyYWN0aW9uGAMgASgL",
            "Mi4uZW52b3kuY29uZmlnLmNvcmUudjMuUnVudGltZUZyYWN0aW9uYWxQZXJj",
            "ZW50EjEKDXRyYWNlX3NhbXBsZWQYBCABKAsyGi5nb29nbGUucHJvdG9idWYu",
            "Qm9vbFZhbHVlOjmaxYgeNAoyZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0",
            "aW9uLlJlcXVlc3RNaXJyb3JQb2xpY3lKBAgCEANSC3J1bnRpbWVfa2V5GokJ",
            "CgpIYXNoUG9saWN5EkYKBmhlYWRlchgBIAEoCzI0LmVudm95LmNvbmZpZy5y",
            "b3V0ZS52My5Sb3V0ZUFjdGlvbi5IYXNoUG9saWN5LkhlYWRlckgAEkYKBmNv",
            "b2tpZRgCIAEoCzI0LmVudm95LmNvbmZpZy5yb3V0ZS52My5Sb3V0ZUFjdGlv",
            "bi5IYXNoUG9saWN5LkNvb2tpZUgAEmMKFWNvbm5lY3Rpb25fcHJvcGVydGll",
            "cxgDIAEoCzJCLmVudm95LmNvbmZpZy5yb3V0ZS52My5Sb3V0ZUFjdGlvbi5I",
            "YXNoUG9saWN5LkNvbm5lY3Rpb25Qcm9wZXJ0aWVzSAASVwoPcXVlcnlfcGFy",
            "YW1ldGVyGAUgASgLMjwuZW52b3kuY29uZmlnLnJvdXRlLnYzLlJvdXRlQWN0",
            "aW9uLkhhc2hQb2xpY3kuUXVlcnlQYXJhbWV0ZXJIABJRCgxmaWx0ZXJfc3Rh",
            "dGUYBiABKAsyOS5lbnZveS5jb25maWcucm91dGUudjMuUm91dGVBY3Rpb24u",
            "SGFzaFBvbGljeS5GaWx0ZXJTdGF0ZUgAEhAKCHRlcm1pbmFsGAQgASgIGqwB",
            "CgZIZWFkZXISIgoLaGVhZGVyX25hbWUYASABKAlCDfpCCnIIEAHAAQHIAQAS",
            "RQoNcmVnZXhfcmV3cml0ZRgCIAEoCzIuLmVudm95LnR5cGUubWF0Y2hlci52",
            "My5SZWdleE1hdGNoQW5kU3Vic3RpdHV0ZTo3msWIHjIKMGVudm95LmFwaS52",
            "Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5IYXNoUG9saWN5LkhlYWRlchqOAQoGQ29v",
            "a2llEhUKBG5hbWUYASABKAlCB/pCBHICEAESJgoDdHRsGAIgASgLMhkuZ29v",
            "Z2xlLnByb3RvYnVmLkR1cmF0aW9uEgwKBHBhdGgYAyABKAk6N5rFiB4yCjBl",
            "bnZveS5hcGkudjIucm91dGUuUm91dGVBY3Rpb24uSGFzaFBvbGljeS5Db29r",
            "aWUacAoUQ29ubmVjdGlvblByb3BlcnRpZXMSEQoJc291cmNlX2lwGAEgASgI",
            "OkWaxYgeQAo+ZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkhhc2hQ",
            "b2xpY3kuQ29ubmVjdGlvblByb3BlcnRpZXMaaAoOUXVlcnlQYXJhbWV0ZXIS",
            "FQoEbmFtZRgBIAEoCUIH+kIEcgIQATo/msWIHjoKOGVudm95LmFwaS52Mi5y",
            "b3V0ZS5Sb3V0ZUFjdGlvbi5IYXNoUG9saWN5LlF1ZXJ5UGFyYW1ldGVyGmEK",
            "C0ZpbHRlclN0YXRlEhQKA2tleRgBIAEoCUIH+kIEcgIQATo8msWIHjcKNWVu",
            "dm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5IYXNoUG9saWN5LkZpbHRl",
            "clN0YXRlOjCaxYgeKwopZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9u",
            "Lkhhc2hQb2xpY3lCFwoQcG9saWN5X3NwZWNpZmllchID+EIBGt0CCg1VcGdy",
            "YWRlQ29uZmlnEiMKDHVwZ3JhZGVfdHlwZRgBIAEoCUIN+kIKcggQAcABAsgB",
            "ABIrCgdlbmFibGVkGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1",
            "ZRJWCg5jb25uZWN0X2NvbmZpZxgDIAEoCzI+LmVudm95LmNvbmZpZy5yb3V0",
            "ZS52My5Sb3V0ZUFjdGlvbi5VcGdyYWRlQ29uZmlnLkNvbm5lY3RDb25maWca",
            "bQoNQ29ubmVjdENvbmZpZxJIChVwcm94eV9wcm90b2NvbF9jb25maWcYASAB",
            "KAsyKS5lbnZveS5jb25maWcuY29yZS52My5Qcm94eVByb3RvY29sQ29uZmln",
            "EhIKCmFsbG93X3Bvc3QYAiABKAg6M5rFiB4uCixlbnZveS5hcGkudjIucm91",
            "dGUuUm91dGVBY3Rpb24uVXBncmFkZUNvbmZpZxrGAQoRTWF4U3RyZWFtRHVy",
            "YXRpb24SNgoTbWF4X3N0cmVhbV9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbhI6ChdncnBjX3RpbWVvdXRfaGVhZGVyX21heBgC",
            "IAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhI9ChpncnBjX3RpbWVv",
            "dXRfaGVhZGVyX29mZnNldBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJh",
            "dGlvbiJgChtDbHVzdGVyTm90Rm91bmRSZXNwb25zZUNvZGUSFwoTU0VSVklD",
            "RV9VTkFWQUlMQUJMRRAAEg0KCU5PVF9GT1VORBABEhkKFUlOVEVSTkFMX1NF",
            "UlZFUl9FUlJPUhACIl4KFkludGVybmFsUmVkaXJlY3RBY3Rpb24SIgoeUEFT",
            "U19USFJPVUdIX0lOVEVSTkFMX1JFRElSRUNUEAASHAoYSEFORExFX0lOVEVS",
            "TkFMX1JFRElSRUNUEAEaAhgBOiWaxYgeIAoeZW52b3kuYXBpLnYyLnJvdXRl",
            "LlJvdXRlQWN0aW9uQhgKEWNsdXN0ZXJfc3BlY2lmaWVyEgP4QgFCGAoWaG9z",
            "dF9yZXdyaXRlX3NwZWNpZmllckoECAwQDUoECBIQE0oECBMQFEoECBAQEUoE",
            "CBYQF0oECBUQFkoECAoQC1IVcmVxdWVzdF9taXJyb3JfcG9saWN5ItsNCgtS",
            "ZXRyeVBvbGljeRIQCghyZXRyeV9vbhgBIAEoCRJGCgtudW1fcmV0cmllcxgC",
            "IAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZUIT8pj+jwUNCgtt",
            "YXhfcmV0cmllcxIyCg9wZXJfdHJ5X3RpbWVvdXQYAyABKAsyGS5nb29nbGUu",
            "cHJvdG9idWYuRHVyYXRpb24SNwoUcGVyX3RyeV9pZGxlX3RpbWVvdXQYDSAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SSAoOcmV0cnlfcHJpb3Jp",
            "dHkYBCABKAsyMC5lbnZveS5jb25maWcucm91dGUudjMuUmV0cnlQb2xpY3ku",
            "UmV0cnlQcmlvcml0eRJTChRyZXRyeV9ob3N0X3ByZWRpY2F0ZRgFIAMoCzI1",
            "LmVudm95LmNvbmZpZy5yb3V0ZS52My5SZXRyeVBvbGljeS5SZXRyeUhvc3RQ",
            "cmVkaWNhdGUSTAoYcmV0cnlfb3B0aW9uc19wcmVkaWNhdGVzGAwgAygLMiou",
            "ZW52b3kuY29uZmlnLmNvcmUudjMuVHlwZWRFeHRlbnNpb25Db25maWcSKQoh",
            "aG9zdF9zZWxlY3Rpb25fcmV0cnlfbWF4X2F0dGVtcHRzGAYgASgDEh4KFnJl",
            "dHJpYWJsZV9zdGF0dXNfY29kZXMYByADKA0SRwoOcmV0cnlfYmFja19vZmYY",
            "CCABKAsyLy5lbnZveS5jb25maWcucm91dGUudjMuUmV0cnlQb2xpY3kuUmV0",
            "cnlCYWNrT2ZmEl8KG3JhdGVfbGltaXRlZF9yZXRyeV9iYWNrX29mZhgLIAEo",
            "CzI6LmVudm95LmNvbmZpZy5yb3V0ZS52My5SZXRyeVBvbGljeS5SYXRlTGlt",
            "aXRlZFJldHJ5QmFja09mZhI/ChFyZXRyaWFibGVfaGVhZGVycxgJIAMoCzIk",
            "LmVudm95LmNvbmZpZy5yb3V0ZS52My5IZWFkZXJNYXRjaGVyEkcKGXJldHJp",
            "YWJsZV9yZXF1ZXN0X2hlYWRlcnMYCiADKAsyJC5lbnZveS5jb25maWcucm91",
            "dGUudjMuSGVhZGVyTWF0Y2hlchqmAQoNUmV0cnlQcmlvcml0eRIVCgRuYW1l",
            "GAEgASgJQgf6QgRyAhABEiwKDHR5cGVkX2NvbmZpZxgDIAEoCzIULmdvb2ds",
            "ZS5wcm90b2J1Zi5BbnlIADozmsWIHi4KLGVudm95LmFwaS52Mi5yb3V0ZS5S",
            "ZXRyeVBvbGljeS5SZXRyeVByaW9yaXR5Qg0KC2NvbmZpZ190eXBlSgQIAhAD",
            "UgZjb25maWcasAEKElJldHJ5SG9zdFByZWRpY2F0ZRIVCgRuYW1lGAEgASgJ",
            "Qgf6QgRyAhABEiwKDHR5cGVkX2NvbmZpZxgDIAEoCzIULmdvb2dsZS5wcm90",
            "b2J1Zi5BbnlIADo4msWIHjMKMWVudm95LmFwaS52Mi5yb3V0ZS5SZXRyeVBv",
            "bGljeS5SZXRyeUhvc3RQcmVkaWNhdGVCDQoLY29uZmlnX3R5cGVKBAgCEANS",
            "BmNvbmZpZxq7AQoMUmV0cnlCYWNrT2ZmEjwKDWJhc2VfaW50ZXJ2YWwYASAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCvpCB6oBBAgBKgASOQoM",
            "bWF4X2ludGVydmFsGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9u",
            "Qgj6QgWqAQIqADoymsWIHi0KK2Vudm95LmFwaS52Mi5yb3V0ZS5SZXRyeVBv",
            "bGljeS5SZXRyeUJhY2tPZmYaegoLUmVzZXRIZWFkZXISGwoEbmFtZRgBIAEo",
            "CUIN+kIKcggQAcABAcgBABJOCgZmb3JtYXQYAiABKA4yNC5lbnZveS5jb25m",
            "aWcucm91dGUudjMuUmV0cnlQb2xpY3kuUmVzZXRIZWFkZXJGb3JtYXRCCPpC",
            "BYIBAhABGqUBChdSYXRlTGltaXRlZFJldHJ5QmFja09mZhJPCg1yZXNldF9o",
            "ZWFkZXJzGAEgAygLMi4uZW52b3kuY29uZmlnLnJvdXRlLnYzLlJldHJ5UG9s",
            "aWN5LlJlc2V0SGVhZGVyQgj6QgWSAQIIARI5CgxtYXhfaW50ZXJ2YWwYAiAB",
            "KAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCPpCBaoBAioAIjQKEVJl",
            "c2V0SGVhZGVyRm9ybWF0EgsKB1NFQ09ORFMQABISCg5VTklYX1RJTUVTVEFN",
            "UBABOiWaxYgeIAoeZW52b3kuYXBpLnYyLnJvdXRlLlJldHJ5UG9saWN5ItwB",
            "CgtIZWRnZVBvbGljeRI/ChBpbml0aWFsX3JlcXVlc3RzGAEgASgLMhwuZ29v",
            "Z2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQgf6QgQqAigBEkMKGWFkZGl0aW9u",
            "YWxfcmVxdWVzdF9jaGFuY2UYAiABKAsyIC5lbnZveS50eXBlLnYzLkZyYWN0",
            "aW9uYWxQZXJjZW50EiAKGGhlZGdlX29uX3Blcl90cnlfdGltZW91dBgDIAEo",
            "CDolmsWIHiAKHmVudm95LmFwaS52Mi5yb3V0ZS5IZWRnZVBvbGljeSLhBAoO",
            "UmVkaXJlY3RBY3Rpb24SGAoOaHR0cHNfcmVkaXJlY3QYBCABKAhIABIZCg9z",
            "Y2hlbWVfcmVkaXJlY3QYByABKAlIABIiCg1ob3N0X3JlZGlyZWN0GAEgASgJ",
            "Qgv6QghyBsABAsgBABIVCg1wb3J0X3JlZGlyZWN0GAggASgNEiQKDXBhdGhf",
            "cmVkaXJlY3QYAiABKAlCC/pCCHIGwAECyAEASAESJQoOcHJlZml4X3Jld3Jp",
            "dGUYBSABKAlCC/pCCHIGwAECyAEASAESRwoNcmVnZXhfcmV3cml0ZRgJIAEo",
            "CzIuLmVudm95LnR5cGUubWF0Y2hlci52My5SZWdleE1hdGNoQW5kU3Vic3Rp",
            "dHV0ZUgBElsKDXJlc3BvbnNlX2NvZGUYAyABKA4yOi5lbnZveS5jb25maWcu",
            "cm91dGUudjMuUmVkaXJlY3RBY3Rpb24uUmVkaXJlY3RSZXNwb25zZUNvZGVC",
            "CPpCBYIBAhABEhMKC3N0cmlwX3F1ZXJ5GAYgASgIIncKFFJlZGlyZWN0UmVz",
            "cG9uc2VDb2RlEhUKEU1PVkVEX1BFUk1BTkVOVExZEAASCQoFRk9VTkQQARIN",
            "CglTRUVfT1RIRVIQAhIWChJURU1QT1JBUllfUkVESVJFQ1QQAxIWChJQRVJN",
            "QU5FTlRfUkVESVJFQ1QQBDoomsWIHiMKIWVudm95LmFwaS52Mi5yb3V0ZS5S",
            "ZWRpcmVjdEFjdGlvbkIaChhzY2hlbWVfcmV3cml0ZV9zcGVjaWZpZXJCGAoW",
            "cGF0aF9yZXdyaXRlX3NwZWNpZmllciKTAQoURGlyZWN0UmVzcG9uc2VBY3Rp",
            "b24SGwoGc3RhdHVzGAEgASgNQgv6QggqBhDYBCjIARIuCgRib2R5GAIgASgL",
            "MiAuZW52b3kuY29uZmlnLmNvcmUudjMuRGF0YVNvdXJjZToumsWIHikKJ2Vu",
            "dm95LmFwaS52Mi5yb3V0ZS5EaXJlY3RSZXNwb25zZUFjdGlvbiIVChNOb25G",
            "b3J3YXJkaW5nQWN0aW9uInsKCURlY29yYXRvchIaCglvcGVyYXRpb24YASAB",
            "KAlCB/pCBHICEAESLQoJcHJvcGFnYXRlGAIgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLkJvb2xWYWx1ZTojmsWIHh4KHGVudm95LmFwaS52Mi5yb3V0ZS5EZWNv",
            "cmF0b3IilQIKB1RyYWNpbmcSOQoPY2xpZW50X3NhbXBsaW5nGAEgASgLMiAu",
            "ZW52b3kudHlwZS52My5GcmFjdGlvbmFsUGVyY2VudBI5Cg9yYW5kb21fc2Ft",
            "cGxpbmcYAiABKAsyIC5lbnZveS50eXBlLnYzLkZyYWN0aW9uYWxQZXJjZW50",
            "EjoKEG92ZXJhbGxfc2FtcGxpbmcYAyABKAsyIC5lbnZveS50eXBlLnYzLkZy",
            "YWN0aW9uYWxQZXJjZW50EjUKC2N1c3RvbV90YWdzGAQgAygLMiAuZW52b3ku",
            "dHlwZS50cmFjaW5nLnYzLkN1c3RvbVRhZzohmsWIHhwKGmVudm95LmFwaS52",
            "Mi5yb3V0ZS5UcmFjaW5nIqUBCg5WaXJ0dWFsQ2x1c3RlchI1CgdoZWFkZXJz",
            "GAQgAygLMiQuZW52b3kuY29uZmlnLnJvdXRlLnYzLkhlYWRlck1hdGNoZXIS",
            "FQoEbmFtZRgCIAEoCUIH+kIEcgIQAToomsWIHiMKIWVudm95LmFwaS52Mi5y",
            "b3V0ZS5WaXJ0dWFsQ2x1c3RlckoECAEQAkoECAMQBFIHcGF0dGVyblIGbWV0",
            "aG9kIqsVCglSYXRlTGltaXQSNAoFc3RhZ2UYASABKAsyHC5nb29nbGUucHJv",
            "dG9idWYuVUludDMyVmFsdWVCB/pCBCoCGAoSEwoLZGlzYWJsZV9rZXkYAiAB",
            "KAkSQgoHYWN0aW9ucxgDIAMoCzInLmVudm95LmNvbmZpZy5yb3V0ZS52My5S",
            "YXRlTGltaXQuQWN0aW9uQgj6QgWSAQIIARI4CgVsaW1pdBgEIAEoCzIpLmVu",
            "dm95LmNvbmZpZy5yb3V0ZS52My5SYXRlTGltaXQuT3ZlcnJpZGUa2BEKBkFj",
            "dGlvbhJPCg5zb3VyY2VfY2x1c3RlchgBIAEoCzI1LmVudm95LmNvbmZpZy5y",
            "b3V0ZS52My5SYXRlTGltaXQuQWN0aW9uLlNvdXJjZUNsdXN0ZXJIABJZChNk",
            "ZXN0aW5hdGlvbl9jbHVzdGVyGAIgASgLMjouZW52b3kuY29uZmlnLnJvdXRl",
            "LnYzLlJhdGVMaW1pdC5BY3Rpb24uRGVzdGluYXRpb25DbHVzdGVySAASUQoP",
            "cmVxdWVzdF9oZWFkZXJzGAMgASgLMjYuZW52b3kuY29uZmlnLnJvdXRlLnYz",
            "LlJhdGVMaW1pdC5BY3Rpb24uUmVxdWVzdEhlYWRlcnNIABJPCg5yZW1vdGVf",
            "YWRkcmVzcxgEIAEoCzI1LmVudm95LmNvbmZpZy5yb3V0ZS52My5SYXRlTGlt",
            "aXQuQWN0aW9uLlJlbW90ZUFkZHJlc3NIABJJCgtnZW5lcmljX2tleRgFIAEo",
            "CzIyLmVudm95LmNvbmZpZy5yb3V0ZS52My5SYXRlTGltaXQuQWN0aW9uLkdl",
            "bmVyaWNLZXlIABJWChJoZWFkZXJfdmFsdWVfbWF0Y2gYBiABKAsyOC5lbnZv",
            "eS5jb25maWcucm91dGUudjMuUmF0ZUxpbWl0LkFjdGlvbi5IZWFkZXJWYWx1",
            "ZU1hdGNoSAASZgoQZHluYW1pY19tZXRhZGF0YRgHIAEoCzI3LmVudm95LmNv",
            "bmZpZy5yb3V0ZS52My5SYXRlTGltaXQuQWN0aW9uLkR5bmFtaWNNZXRhRGF0",
            "YUIRGAGSx4bYBAMzLjC47vLSBQFIABJECghtZXRhZGF0YRgIIAEoCzIwLmVu",
            "dm95LmNvbmZpZy5yb3V0ZS52My5SYXRlTGltaXQuQWN0aW9uLk1ldGFEYXRh",
            "SAASPwoJZXh0ZW5zaW9uGAkgASgLMiouZW52b3kuY29uZmlnLmNvcmUudjMu",
            "VHlwZWRFeHRlbnNpb25Db25maWdIABJcChVtYXNrZWRfcmVtb3RlX2FkZHJl",
            "c3MYCiABKAsyOy5lbnZveS5jb25maWcucm91dGUudjMuUmF0ZUxpbWl0LkFj",
            "dGlvbi5NYXNrZWRSZW1vdGVBZGRyZXNzSAAaSQoNU291cmNlQ2x1c3Rlcjo4",
            "msWIHjMKMWVudm95LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLlNv",
            "dXJjZUNsdXN0ZXIaUwoSRGVzdGluYXRpb25DbHVzdGVyOj2axYgeOAo2ZW52",
            "b3kuYXBpLnYyLnJvdXRlLlJhdGVMaW1pdC5BY3Rpb24uRGVzdGluYXRpb25D",
            "bHVzdGVyGqgBCg5SZXF1ZXN0SGVhZGVycxIiCgtoZWFkZXJfbmFtZRgBIAEo",
            "CUIN+kIKcggQAcABAcgBABIfCg5kZXNjcmlwdG9yX2tleRgCIAEoCUIH+kIE",
            "cgIQARIWCg5za2lwX2lmX2Fic2VudBgDIAEoCDo5msWIHjQKMmVudm95LmFw",
            "aS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLlJlcXVlc3RIZWFkZXJzGkkK",
            "DVJlbW90ZUFkZHJlc3M6OJrFiB4zCjFlbnZveS5hcGkudjIucm91dGUuUmF0",
            "ZUxpbWl0LkFjdGlvbi5SZW1vdGVBZGRyZXNzGpwBChNNYXNrZWRSZW1vdGVB",
            "ZGRyZXNzEkEKEnY0X3ByZWZpeF9tYXNrX2xlbhgBIAEoCzIcLmdvb2dsZS5w",
            "cm90b2J1Zi5VSW50MzJWYWx1ZUIH+kIEKgIYIBJCChJ2Nl9wcmVmaXhfbWFz",
            "a19sZW4YAiABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCPpC",
            "BSoDGIABGn4KCkdlbmVyaWNLZXkSIQoQZGVzY3JpcHRvcl92YWx1ZRgBIAEo",
            "CUIH+kIEcgIQARIWCg5kZXNjcmlwdG9yX2tleRgCIAEoCTo1msWIHjAKLmVu",
            "dm95LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLkdlbmVyaWNLZXka",
            "/QEKEEhlYWRlclZhbHVlTWF0Y2gSFgoOZGVzY3JpcHRvcl9rZXkYBCABKAkS",
            "IQoQZGVzY3JpcHRvcl92YWx1ZRgBIAEoCUIH+kIEcgIQARIwCgxleHBlY3Rf",
            "bWF0Y2gYAiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlEj8KB2hl",
            "YWRlcnMYAyADKAsyJC5lbnZveS5jb25maWcucm91dGUudjMuSGVhZGVyTWF0",
            "Y2hlckII+kIFkgECCAE6O5rFiB42CjRlbnZveS5hcGkudjIucm91dGUuUmF0",
            "ZUxpbWl0LkFjdGlvbi5IZWFkZXJWYWx1ZU1hdGNoGo4BCg9EeW5hbWljTWV0",
            "YURhdGESHwoOZGVzY3JpcHRvcl9rZXkYASABKAlCB/pCBHICEAESQwoMbWV0",
            "YWRhdGFfa2V5GAIgASgLMiMuZW52b3kudHlwZS5tZXRhZGF0YS52My5NZXRh",
            "ZGF0YUtleUII+kIFigECEAESFQoNZGVmYXVsdF92YWx1ZRgDIAEoCRqCAgoI",
            "TWV0YURhdGESHwoOZGVzY3JpcHRvcl9rZXkYASABKAlCB/pCBHICEAESQwoM",
            "bWV0YWRhdGFfa2V5GAIgASgLMiMuZW52b3kudHlwZS5tZXRhZGF0YS52My5N",
            "ZXRhZGF0YUtleUII+kIFigECEAESFQoNZGVmYXVsdF92YWx1ZRgDIAEoCRJR",
            "CgZzb3VyY2UYBCABKA4yNy5lbnZveS5jb25maWcucm91dGUudjMuUmF0ZUxp",
            "bWl0LkFjdGlvbi5NZXRhRGF0YS5Tb3VyY2VCCPpCBYIBAhABIiYKBlNvdXJj",
            "ZRILCgdEWU5BTUlDEAASDwoLUk9VVEVfRU5UUlkQAToqmsWIHiUKI2Vudm95",
            "LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uQhcKEGFjdGlvbl9zcGVj",
            "aWZpZXISA/hCARrUAQoIT3ZlcnJpZGUSVQoQZHluYW1pY19tZXRhZGF0YRgB",
            "IAEoCzI5LmVudm95LmNvbmZpZy5yb3V0ZS52My5SYXRlTGltaXQuT3ZlcnJp",
            "ZGUuRHluYW1pY01ldGFkYXRhSAAaVgoPRHluYW1pY01ldGFkYXRhEkMKDG1l",
            "dGFkYXRhX2tleRgBIAEoCzIjLmVudm95LnR5cGUubWV0YWRhdGEudjMuTWV0",
            "YWRhdGFLZXlCCPpCBYoBAhABQhkKEm92ZXJyaWRlX3NwZWNpZmllchID+EIB",
            "OiOaxYgeHgocZW52b3kuYXBpLnYyLnJvdXRlLlJhdGVMaW1pdCLMBAoNSGVh",
            "ZGVyTWF0Y2hlchIbCgRuYW1lGAEgASgJQg36QgpyCBABwAEByAEAEiIKC2V4",
            "YWN0X21hdGNoGAQgASgJQgsYAZLHhtgEAzMuMEgAEkwKEHNhZmVfcmVnZXhf",
            "bWF0Y2gYCyABKAsyIy5lbnZveS50eXBlLm1hdGNoZXIudjMuUmVnZXhNYXRj",
            "aGVyQgsYAZLHhtgEAzMuMEgAEjAKC3JhbmdlX21hdGNoGAYgASgLMhkuZW52",
            "b3kudHlwZS52My5JbnQ2NFJhbmdlSAASFwoNcHJlc2VudF9tYXRjaBgHIAEo",
            "CEgAEioKDHByZWZpeF9tYXRjaBgJIAEoCUISGAH6QgRyAhABkseG2AQDMy4w",
            "SAASKgoMc3VmZml4X21hdGNoGAogASgJQhIYAfpCBHICEAGSx4bYBAMzLjBI",
            "ABIsCg5jb250YWluc19tYXRjaBgMIAEoCUISGAH6QgRyAhABkseG2AQDMy4w",
            "SAASPAoMc3RyaW5nX21hdGNoGA0gASgLMiQuZW52b3kudHlwZS5tYXRjaGVy",
            "LnYzLlN0cmluZ01hdGNoZXJIABIUCgxpbnZlcnRfbWF0Y2gYCCABKAgSJQod",
            "dHJlYXRfbWlzc2luZ19oZWFkZXJfYXNfZW1wdHkYDiABKAg6J5rFiB4iCiBl",
            "bnZveS5hcGkudjIucm91dGUuSGVhZGVyTWF0Y2hlckIYChZoZWFkZXJfbWF0",
            "Y2hfc3BlY2lmaWVySgQIAhADSgQIAxAESgQIBRAGUgtyZWdleF9tYXRjaCKA",
            "AgoVUXVlcnlQYXJhbWV0ZXJNYXRjaGVyEhgKBG5hbWUYASABKAlCCvpCB3IF",
            "EAEogAgSRgoMc3RyaW5nX21hdGNoGAUgASgLMiQuZW52b3kudHlwZS5tYXRj",
            "aGVyLnYzLlN0cmluZ01hdGNoZXJCCPpCBYoBAhABSAASFwoNcHJlc2VudF9t",
            "YXRjaBgGIAEoCEgAOi+axYgeKgooZW52b3kuYXBpLnYyLnJvdXRlLlF1ZXJ5",
            "UGFyYW1ldGVyTWF0Y2hlckIhCh9xdWVyeV9wYXJhbWV0ZXJfbWF0Y2hfc3Bl",
            "Y2lmaWVySgQIAxAESgQIBBAFUgV2YWx1ZVIFcmVnZXgi5gEKFkludGVybmFs",
            "UmVkaXJlY3RQb2xpY3kSPAoWbWF4X2ludGVybmFsX3JlZGlyZWN0cxgBIAEo",
            "CzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZRIpChdyZWRpcmVjdF9y",
            "ZXNwb25zZV9jb2RlcxgCIAMoDUII+kIFkgECEAUSPgoKcHJlZGljYXRlcxgD",
            "IAMoCzIqLmVudm95LmNvbmZpZy5jb3JlLnYzLlR5cGVkRXh0ZW5zaW9uQ29u",
            "ZmlnEiMKG2FsbG93X2Nyb3NzX3NjaGVtZV9yZWRpcmVjdBgEIAEoCCJJCgxG",
            "aWx0ZXJDb25maWcSJAoGY29uZmlnGAEgASgLMhQuZ29vZ2xlLnByb3RvYnVm",
            "LkFueRITCgtpc19vcHRpb25hbBgCIAEoCEKLAQojaW8uZW52b3lwcm94eS5l",
            "bnZveS5jb25maWcucm91dGUudjNCFFJvdXRlQ29tcG9uZW50c1Byb3RvUAFa",
            "RGdpdGh1Yi5jb20vZW52b3lwcm94eS9nby1jb250cm9sLXBsYW5lL2Vudm95",
            "L2NvbmZpZy9yb3V0ZS92Mztyb3V0ZXYzuoDI0QYCEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Config.Core.V3.BaseReflection.Descriptor, global::Envoy.Config.Core.V3.ExtensionReflection.Descriptor, global::Envoy.Config.Core.V3.ProxyProtocolReflection.Descriptor, global::Envoy.Type.Matcher.V3.MetadataReflection.Descriptor, global::Envoy.Type.Matcher.V3.RegexReflection.Descriptor, global::Envoy.Type.Matcher.V3.StringReflection.Descriptor, global::Envoy.Type.Metadata.V3.MetadataReflection.Descriptor, global::Envoy.Type.Tracing.V3.CustomTagReflection.Descriptor, global::Envoy.Type.V3.PercentReflection.Descriptor, global::Envoy.Type.V3.RangeReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Xds.Annotations.V3.StatusReflection.Descriptor, global::Xds.Type.Matcher.V3.MatcherReflection.Descriptor, global::Envoy.Annotations.DeprecationReflection.Descriptor, global::Udpa.Annotations.MigrateReflection.Descriptor, global::Udpa.Annotations.StatusReflection.Descriptor, global::Udpa.Annotations.VersioningReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.VirtualHost), global::Envoy.Config.Route.V3.VirtualHost.Parser, new[]{ "Name", "Domains", "Routes", "Matcher", "RequireTls", "VirtualClusters", "RateLimits", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "Cors", "TypedPerFilterConfig", "IncludeRequestAttemptCount", "IncludeAttemptCountInResponse", "RetryPolicy", "RetryPolicyTypedConfig", "HedgePolicy", "PerRequestBufferLimitBytes", "RequestMirrorPolicies" }, null, new[]{ typeof(global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.FilterAction), global::Envoy.Config.Route.V3.FilterAction.Parser, new[]{ "Action" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.Route), global::Envoy.Config.Route.V3.Route.Parser, new[]{ "Name", "Match", "Route_", "Redirect", "DirectResponse", "FilterAction", "NonForwardingAction", "Metadata", "Decorator", "TypedPerFilterConfig", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "Tracing", "PerRequestBufferLimitBytes", "StatPrefix" }, new[]{ "Action" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.WeightedCluster), global::Envoy.Config.Route.V3.WeightedCluster.Parser, new[]{ "Clusters", "TotalWeight", "RuntimeKeyPrefix", "HeaderName" }, new[]{ "RandomValueSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight), global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight.Parser, new[]{ "Name", "ClusterHeader", "Weight", "MetadataMatch", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "TypedPerFilterConfig", "HostRewriteLiteral" }, new[]{ "HostRewriteSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.ClusterSpecifierPlugin), global::Envoy.Config.Route.V3.ClusterSpecifierPlugin.Parser, new[]{ "Extension", "IsOptional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteMatch), global::Envoy.Config.Route.V3.RouteMatch.Parser, new[]{ "Prefix", "Path", "SafeRegex", "ConnectMatcher", "PathSeparatedPrefix", "PathMatchPolicy", "CaseSensitive", "RuntimeFraction", "Headers", "QueryParameters", "Grpc", "TlsContext", "DynamicMetadata" }, new[]{ "PathSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions), global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions), global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions.Parser, new[]{ "Presented", "Validated" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher), global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher.Parser, null, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.CorsPolicy), global::Envoy.Config.Route.V3.CorsPolicy.Parser, new[]{ "AllowOriginStringMatch", "AllowMethods", "AllowHeaders", "ExposeHeaders", "MaxAge", "AllowCredentials", "FilterEnabled", "ShadowEnabled", "AllowPrivateNetworkAccess" }, new[]{ "EnabledSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction), global::Envoy.Config.Route.V3.RouteAction.Parser, new[]{ "Cluster", "ClusterHeader", "WeightedClusters", "ClusterSpecifierPlugin", "InlineClusterSpecifierPlugin", "ClusterNotFoundResponseCode", "MetadataMatch", "PrefixRewrite", "RegexRewrite", "PathRewritePolicy", "HostRewriteLiteral", "AutoHostRewrite", "HostRewriteHeader", "HostRewritePathRegex", "AppendXForwardedHost", "Timeout", "IdleTimeout", "EarlyDataPolicy", "RetryPolicy", "RetryPolicyTypedConfig", "RequestMirrorPolicies", "Priority", "RateLimits", "IncludeVhRateLimits", "HashPolicy", "Cors", "MaxGrpcTimeout", "GrpcTimeoutOffset", "UpgradeConfigs", "InternalRedirectPolicy", "InternalRedirectAction", "MaxInternalRedirects", "HedgePolicy", "MaxStreamDuration" }, new[]{ "ClusterSpecifier", "HostRewriteSpecifier" }, new[]{ typeof(global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode), typeof(global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy), global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy.Parser, new[]{ "Cluster", "ClusterHeader", "RuntimeFraction", "TraceSampled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Parser, new[]{ "Header", "Cookie", "ConnectionProperties", "QueryParameter", "FilterState", "Terminal" }, new[]{ "PolicySpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header.Parser, new[]{ "HeaderName", "RegexRewrite" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie.Parser, new[]{ "Name", "Ttl", "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties.Parser, new[]{ "SourceIp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter.Parser, new[]{ "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState), global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState.Parser, new[]{ "Key" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig), global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Parser, new[]{ "UpgradeType", "Enabled", "ConnectConfig" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig), global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig.Parser, new[]{ "ProxyProtocolConfig", "AllowPost" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration), global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration.Parser, new[]{ "MaxStreamDuration_", "GrpcTimeoutHeaderMax", "GrpcTimeoutHeaderOffset" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy), global::Envoy.Config.Route.V3.RetryPolicy.Parser, new[]{ "RetryOn", "NumRetries", "PerTryTimeout", "PerTryIdleTimeout", "RetryPriority", "RetryHostPredicate", "RetryOptionsPredicates", "HostSelectionRetryMaxAttempts", "RetriableStatusCodes", "RetryBackOff", "RateLimitedRetryBackOff", "RetriableHeaders", "RetriableRequestHeaders" }, null, new[]{ typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority), global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority.Parser, new[]{ "Name", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate), global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate.Parser, new[]{ "Name", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff), global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff.Parser, new[]{ "BaseInterval", "MaxInterval" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader), global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader.Parser, new[]{ "Name", "Format" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff), global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff.Parser, new[]{ "ResetHeaders", "MaxInterval" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.HedgePolicy), global::Envoy.Config.Route.V3.HedgePolicy.Parser, new[]{ "InitialRequests", "AdditionalRequestChance", "HedgeOnPerTryTimeout" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RedirectAction), global::Envoy.Config.Route.V3.RedirectAction.Parser, new[]{ "HttpsRedirect", "SchemeRedirect", "HostRedirect", "PortRedirect", "PathRedirect", "PrefixRewrite", "RegexRewrite", "ResponseCode", "StripQuery" }, new[]{ "SchemeRewriteSpecifier", "PathRewriteSpecifier" }, new[]{ typeof(global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.DirectResponseAction), global::Envoy.Config.Route.V3.DirectResponseAction.Parser, new[]{ "Status", "Body" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.NonForwardingAction), global::Envoy.Config.Route.V3.NonForwardingAction.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.Decorator), global::Envoy.Config.Route.V3.Decorator.Parser, new[]{ "Operation", "Propagate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.Tracing), global::Envoy.Config.Route.V3.Tracing.Parser, new[]{ "ClientSampling", "RandomSampling", "OverallSampling", "CustomTags" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.VirtualCluster), global::Envoy.Config.Route.V3.VirtualCluster.Parser, new[]{ "Headers", "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit), global::Envoy.Config.Route.V3.RateLimit.Parser, new[]{ "Stage", "DisableKey", "Actions", "Limit" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Parser, new[]{ "SourceCluster", "DestinationCluster", "RequestHeaders", "RemoteAddress", "GenericKey", "HeaderValueMatch", "DynamicMetadata", "Metadata", "Extension", "MaskedRemoteAddress" }, new[]{ "ActionSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders.Parser, new[]{ "HeaderName", "DescriptorKey", "SkipIfAbsent" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress.Parser, new[]{ "V4PrefixMaskLen", "V6PrefixMaskLen" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey.Parser, new[]{ "DescriptorValue", "DescriptorKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch.Parser, new[]{ "DescriptorKey", "DescriptorValue", "ExpectMatch", "Headers" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData.Parser, new[]{ "DescriptorKey", "MetadataKey", "DefaultValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData), global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Parser, new[]{ "DescriptorKey", "MetadataKey", "DefaultValue", "Source" }, null, new[]{ typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Override), global::Envoy.Config.Route.V3.RateLimit.Types.Override.Parser, new[]{ "DynamicMetadata" }, new[]{ "OverrideSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata), global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata.Parser, new[]{ "MetadataKey" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.HeaderMatcher), global::Envoy.Config.Route.V3.HeaderMatcher.Parser, new[]{ "Name", "ExactMatch", "SafeRegexMatch", "RangeMatch", "PresentMatch", "PrefixMatch", "SuffixMatch", "ContainsMatch", "StringMatch", "InvertMatch", "TreatMissingHeaderAsEmpty" }, new[]{ "HeaderMatchSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.QueryParameterMatcher), global::Envoy.Config.Route.V3.QueryParameterMatcher.Parser, new[]{ "Name", "StringMatch", "PresentMatch" }, new[]{ "QueryParameterMatchSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.InternalRedirectPolicy), global::Envoy.Config.Route.V3.InternalRedirectPolicy.Parser, new[]{ "MaxInternalRedirects", "RedirectResponseCodes", "Predicates", "AllowCrossSchemeRedirect" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Route.V3.FilterConfig), global::Envoy.Config.Route.V3.FilterConfig.Parser, new[]{ "Config", "IsOptional" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The top level element in the routing configuration is a virtual host. Each virtual host has
  /// a logical name as well as a set of domains that get routed to it based on the incoming request's
  /// host header. This allows a single listener to service multiple top level domain path trees. Once
  /// a virtual host is selected based on the domain, the routes are processed in order to see which
  /// upstream cluster to route to or whether to perform a redirect.
  /// [#next-free-field: 23]
  /// </summary>
  public sealed partial class VirtualHost : pb::IMessage<VirtualHost>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VirtualHost> _parser = new pb::MessageParser<VirtualHost>(() => new VirtualHost());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VirtualHost> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualHost() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualHost(VirtualHost other) : this() {
      name_ = other.name_;
      domains_ = other.domains_.Clone();
      routes_ = other.routes_.Clone();
      matcher_ = other.matcher_ != null ? other.matcher_.Clone() : null;
      requireTls_ = other.requireTls_;
      virtualClusters_ = other.virtualClusters_.Clone();
      rateLimits_ = other.rateLimits_.Clone();
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      cors_ = other.cors_ != null ? other.cors_.Clone() : null;
      typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
      includeRequestAttemptCount_ = other.includeRequestAttemptCount_;
      includeAttemptCountInResponse_ = other.includeAttemptCountInResponse_;
      retryPolicy_ = other.retryPolicy_ != null ? other.retryPolicy_.Clone() : null;
      retryPolicyTypedConfig_ = other.retryPolicyTypedConfig_ != null ? other.retryPolicyTypedConfig_.Clone() : null;
      hedgePolicy_ = other.hedgePolicy_ != null ? other.hedgePolicy_.Clone() : null;
      PerRequestBufferLimitBytes = other.PerRequestBufferLimitBytes;
      requestMirrorPolicies_ = other.requestMirrorPolicies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualHost Clone() {
      return new VirtualHost(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The logical name of the virtual host. This is used when emitting certain
    /// statistics but is not relevant for routing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domains" field.</summary>
    public const int DomainsFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_domains_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> domains_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of domains (host/authority header) that will be matched to this
    /// virtual host. Wildcard hosts are supported in the suffix or prefix form.
    ///
    /// Domain search order:
    ///  1. Exact domain names: ``www.foo.com``.
    ///  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
    ///  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
    ///  4. Special wildcard ``*`` matching any domain.
    ///
    /// .. note::
    ///
    ///   The wildcard will not match the empty string.
    ///   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
    ///   The longest wildcards match first.
    ///   Only a single virtual host in the entire route configuration can match on ``*``. A domain
    ///   must be unique across all virtual hosts or the config will fail to load.
    ///
    /// Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Domains {
      get { return domains_; }
    }

    /// <summary>Field number for the "routes" field.</summary>
    public const int RoutesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.Route> _repeated_routes_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Route.V3.Route.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.Route> routes_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.Route>();
    /// <summary>
    /// The list of routes that will be matched, in order, for incoming requests.
    /// The first route that matches will be used.
    /// Only one of this and ``matcher`` can be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.Route> Routes {
      get { return routes_; }
    }

    /// <summary>Field number for the "matcher" field.</summary>
    public const int MatcherFieldNumber = 21;
    private global::Xds.Type.Matcher.V3.Matcher matcher_;
    /// <summary>
    /// [#next-major-version: This should be included in a oneof with routes wrapped in a message.]
    /// The match tree to use when resolving route actions for incoming requests. Only one of this and ``routes``
    /// can be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Xds.Type.Matcher.V3.Matcher Matcher {
      get { return matcher_; }
      set {
        matcher_ = value;
      }
    }

    /// <summary>Field number for the "require_tls" field.</summary>
    public const int RequireTlsFieldNumber = 4;
    private global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType requireTls_ = global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None;
    /// <summary>
    /// Specifies the type of TLS enforcement the virtual host expects. If this option is not
    /// specified, there is no TLS requirement for the virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType RequireTls {
      get { return requireTls_; }
      set {
        requireTls_ = value;
      }
    }

    /// <summary>Field number for the "virtual_clusters" field.</summary>
    public const int VirtualClustersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.VirtualCluster> _repeated_virtualClusters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Route.V3.VirtualCluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.VirtualCluster> virtualClusters_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.VirtualCluster>();
    /// <summary>
    /// A list of virtual clusters defined for this virtual host. Virtual clusters
    /// are used for additional statistics gathering.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.VirtualCluster> VirtualClusters {
      get { return virtualClusters_; }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Config.Route.V3.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that will be applied to the
    /// virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each request
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
    /// enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "request_headers_to_remove" field.</summary>
    public const int RequestHeadersToRemoveFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each request
    /// handled by this virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequestHeadersToRemove {
      get { return requestHeadersToRemove_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each response
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
    /// enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// handled by this virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 8;
    private global::Envoy.Config.Route.V3.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the virtual host has a CORS policy. This field is ignored if related cors policy is
    /// found in the
    /// :ref:`VirtualHost.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`.
    ///
    /// .. attention::
    ///
    ///   This option has been deprecated. Please use
    ///   :ref:`VirtualHost.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`
    ///   to configure the CORS HTTP filter.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "typed_per_filter_config" field.</summary>
    public const int TypedPerFilterConfigFieldNumber = 15;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 122);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The per_filter_config field can be used to provide virtual host-specific configurations for filters.
    /// The key should match the :ref:`filter config name
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
    /// The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
    /// be used for the backwards compatibility. If there is no entry referred by the filter config name, the
    /// entry referred by the canonical filter name will be provided to the filters as fallback.
    ///
    /// Use of this field is filter specific;
    /// see the :ref:`HTTP filter documentation &lt;config_http_filters>` for if and how it is utilized.
    /// [#comment: An entry's value may be wrapped in a
    /// :ref:`FilterConfig&lt;envoy_v3_api_msg_config.route.v3.FilterConfig>`
    /// message to specify additional options.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
      get { return typedPerFilterConfig_; }
    }

    /// <summary>Field number for the "include_request_attempt_count" field.</summary>
    public const int IncludeRequestAttemptCountFieldNumber = 14;
    private bool includeRequestAttemptCount_;
    /// <summary>
    /// Decides whether the :ref:`x-envoy-attempt-count
    /// &lt;config_http_filters_router_x-envoy-attempt-count>` header should be included
    /// in the upstream request. Setting this option will cause it to override any existing header
    /// value, so in the case of two Envoys on the request path with this option enabled, the upstream
    /// will see the attempt count as perceived by the second Envoy. Defaults to false.
    /// This header is unaffected by the
    /// :ref:`suppress_envoy_headers
    /// &lt;envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
    ///
    /// [#next-major-version: rename to include_attempt_count_in_request.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeRequestAttemptCount {
      get { return includeRequestAttemptCount_; }
      set {
        includeRequestAttemptCount_ = value;
      }
    }

    /// <summary>Field number for the "include_attempt_count_in_response" field.</summary>
    public const int IncludeAttemptCountInResponseFieldNumber = 19;
    private bool includeAttemptCountInResponse_;
    /// <summary>
    /// Decides whether the :ref:`x-envoy-attempt-count
    /// &lt;config_http_filters_router_x-envoy-attempt-count>` header should be included
    /// in the downstream response. Setting this option will cause the router to override any existing header
    /// value, so in the case of two Envoys on the request path with this option enabled, the downstream
    /// will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
    /// This header is unaffected by the
    /// :ref:`suppress_envoy_headers
    /// &lt;envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeAttemptCountInResponse {
      get { return includeAttemptCountInResponse_; }
      set {
        includeAttemptCountInResponse_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 16;
    private global::Envoy.Config.Route.V3.RetryPolicy retryPolicy_;
    /// <summary>
    /// Indicates the retry policy for all routes in this virtual host. Note that setting a
    /// route level entry will take precedence over this config and it'll be treated
    /// independently (e.g.: values are not inherited).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RetryPolicy RetryPolicy {
      get { return retryPolicy_; }
      set {
        retryPolicy_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy_typed_config" field.</summary>
    public const int RetryPolicyTypedConfigFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Any retryPolicyTypedConfig_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// Specifies the configuration for retry policy extension. Note that setting a route level entry
    /// will take precedence over this config and it'll be treated independently (e.g.: values are not
    /// inherited). :ref:`Retry policy &lt;envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
    /// set if this field is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any RetryPolicyTypedConfig {
      get { return retryPolicyTypedConfig_; }
      set {
        retryPolicyTypedConfig_ = value;
      }
    }

    /// <summary>Field number for the "hedge_policy" field.</summary>
    public const int HedgePolicyFieldNumber = 17;
    private global::Envoy.Config.Route.V3.HedgePolicy hedgePolicy_;
    /// <summary>
    /// Indicates the hedge policy for all routes in this virtual host. Note that setting a
    /// route level entry will take precedence over this config and it'll be treated
    /// independently (e.g.: values are not inherited).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.HedgePolicy HedgePolicy {
      get { return hedgePolicy_; }
      set {
        hedgePolicy_ = value;
      }
    }

    /// <summary>Field number for the "per_request_buffer_limit_bytes" field.</summary>
    public const int PerRequestBufferLimitBytesFieldNumber = 18;
    private static readonly pb::FieldCodec<uint?> _single_perRequestBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(146);
    private uint? perRequestBufferLimitBytes_;
    /// <summary>
    /// The maximum bytes which will be buffered for retries and shadowing.
    /// If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
    /// value of this and the listener per_connection_buffer_limit_bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerRequestBufferLimitBytes {
      get { return perRequestBufferLimitBytes_; }
      set {
        perRequestBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "request_mirror_policies" field.</summary>
    public const int RequestMirrorPoliciesFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> _repeated_requestMirrorPolicies_codec
        = pb::FieldCodec.ForMessage(178, global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> requestMirrorPolicies_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy>();
    /// <summary>
    /// Specify a set of default request mirroring policies for every route under this virtual host.
    /// It takes precedence over the route config mirror policy entirely.
    /// That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> RequestMirrorPolicies {
      get { return requestMirrorPolicies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VirtualHost);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VirtualHost other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!domains_.Equals(other.domains_)) return false;
      if(!routes_.Equals(other.routes_)) return false;
      if (!object.Equals(Matcher, other.Matcher)) return false;
      if (RequireTls != other.RequireTls) return false;
      if(!virtualClusters_.Equals(other.virtualClusters_)) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
      if (IncludeRequestAttemptCount != other.IncludeRequestAttemptCount) return false;
      if (IncludeAttemptCountInResponse != other.IncludeAttemptCountInResponse) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(RetryPolicyTypedConfig, other.RetryPolicyTypedConfig)) return false;
      if (!object.Equals(HedgePolicy, other.HedgePolicy)) return false;
      if (PerRequestBufferLimitBytes != other.PerRequestBufferLimitBytes) return false;
      if(!requestMirrorPolicies_.Equals(other.requestMirrorPolicies_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= domains_.GetHashCode();
      hash ^= routes_.GetHashCode();
      if (matcher_ != null) hash ^= Matcher.GetHashCode();
      if (RequireTls != global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None) hash ^= RequireTls.GetHashCode();
      hash ^= virtualClusters_.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= requestHeadersToRemove_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      hash ^= TypedPerFilterConfig.GetHashCode();
      if (IncludeRequestAttemptCount != false) hash ^= IncludeRequestAttemptCount.GetHashCode();
      if (IncludeAttemptCountInResponse != false) hash ^= IncludeAttemptCountInResponse.GetHashCode();
      if (retryPolicy_ != null) hash ^= RetryPolicy.GetHashCode();
      if (retryPolicyTypedConfig_ != null) hash ^= RetryPolicyTypedConfig.GetHashCode();
      if (hedgePolicy_ != null) hash ^= HedgePolicy.GetHashCode();
      if (perRequestBufferLimitBytes_ != null) hash ^= PerRequestBufferLimitBytes.GetHashCode();
      hash ^= requestMirrorPolicies_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      domains_.WriteTo(output, _repeated_domains_codec);
      routes_.WriteTo(output, _repeated_routes_codec);
      if (RequireTls != global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RequireTls);
      }
      virtualClusters_.WriteTo(output, _repeated_virtualClusters_codec);
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      if (cors_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cors);
      }
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
      if (IncludeRequestAttemptCount != false) {
        output.WriteRawTag(112);
        output.WriteBool(IncludeRequestAttemptCount);
      }
      typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
      if (retryPolicy_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RetryPolicy);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (perRequestBufferLimitBytes_ != null) {
        _single_perRequestBufferLimitBytes_codec.WriteTagAndValue(output, PerRequestBufferLimitBytes);
      }
      if (IncludeAttemptCountInResponse != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(IncludeAttemptCountInResponse);
      }
      if (retryPolicyTypedConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(RetryPolicyTypedConfig);
      }
      if (matcher_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Matcher);
      }
      requestMirrorPolicies_.WriteTo(output, _repeated_requestMirrorPolicies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      domains_.WriteTo(ref output, _repeated_domains_codec);
      routes_.WriteTo(ref output, _repeated_routes_codec);
      if (RequireTls != global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RequireTls);
      }
      virtualClusters_.WriteTo(ref output, _repeated_virtualClusters_codec);
      rateLimits_.WriteTo(ref output, _repeated_rateLimits_codec);
      requestHeadersToAdd_.WriteTo(ref output, _repeated_requestHeadersToAdd_codec);
      if (cors_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cors);
      }
      responseHeadersToAdd_.WriteTo(ref output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(ref output, _repeated_responseHeadersToRemove_codec);
      requestHeadersToRemove_.WriteTo(ref output, _repeated_requestHeadersToRemove_codec);
      if (IncludeRequestAttemptCount != false) {
        output.WriteRawTag(112);
        output.WriteBool(IncludeRequestAttemptCount);
      }
      typedPerFilterConfig_.WriteTo(ref output, _map_typedPerFilterConfig_codec);
      if (retryPolicy_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RetryPolicy);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (perRequestBufferLimitBytes_ != null) {
        _single_perRequestBufferLimitBytes_codec.WriteTagAndValue(ref output, PerRequestBufferLimitBytes);
      }
      if (IncludeAttemptCountInResponse != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(IncludeAttemptCountInResponse);
      }
      if (retryPolicyTypedConfig_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(RetryPolicyTypedConfig);
      }
      if (matcher_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Matcher);
      }
      requestMirrorPolicies_.WriteTo(ref output, _repeated_requestMirrorPolicies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += domains_.CalculateSize(_repeated_domains_codec);
      size += routes_.CalculateSize(_repeated_routes_codec);
      if (matcher_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Matcher);
      }
      if (RequireTls != global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequireTls);
      }
      size += virtualClusters_.CalculateSize(_repeated_virtualClusters_codec);
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      if (cors_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
      if (IncludeRequestAttemptCount != false) {
        size += 1 + 1;
      }
      if (IncludeAttemptCountInResponse != false) {
        size += 2 + 1;
      }
      if (retryPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (retryPolicyTypedConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicyTypedConfig);
      }
      if (hedgePolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HedgePolicy);
      }
      if (perRequestBufferLimitBytes_ != null) {
        size += _single_perRequestBufferLimitBytes_codec.CalculateSizeWithTag(PerRequestBufferLimitBytes);
      }
      size += requestMirrorPolicies_.CalculateSize(_repeated_requestMirrorPolicies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VirtualHost other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      domains_.Add(other.domains_);
      routes_.Add(other.routes_);
      if (other.matcher_ != null) {
        if (matcher_ == null) {
          Matcher = new global::Xds.Type.Matcher.V3.Matcher();
        }
        Matcher.MergeFrom(other.Matcher);
      }
      if (other.RequireTls != global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType.None) {
        RequireTls = other.RequireTls;
      }
      virtualClusters_.Add(other.virtualClusters_);
      rateLimits_.Add(other.rateLimits_);
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      if (other.cors_ != null) {
        if (cors_ == null) {
          Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
      if (other.IncludeRequestAttemptCount != false) {
        IncludeRequestAttemptCount = other.IncludeRequestAttemptCount;
      }
      if (other.IncludeAttemptCountInResponse != false) {
        IncludeAttemptCountInResponse = other.IncludeAttemptCountInResponse;
      }
      if (other.retryPolicy_ != null) {
        if (retryPolicy_ == null) {
          RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
        }
        RetryPolicy.MergeFrom(other.RetryPolicy);
      }
      if (other.retryPolicyTypedConfig_ != null) {
        if (retryPolicyTypedConfig_ == null) {
          RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        RetryPolicyTypedConfig.MergeFrom(other.RetryPolicyTypedConfig);
      }
      if (other.hedgePolicy_ != null) {
        if (hedgePolicy_ == null) {
          HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
        }
        HedgePolicy.MergeFrom(other.HedgePolicy);
      }
      if (other.perRequestBufferLimitBytes_ != null) {
        if (perRequestBufferLimitBytes_ == null || other.PerRequestBufferLimitBytes != 0) {
          PerRequestBufferLimitBytes = other.PerRequestBufferLimitBytes;
        }
      }
      requestMirrorPolicies_.Add(other.requestMirrorPolicies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            domains_.AddEntriesFrom(input, _repeated_domains_codec);
            break;
          }
          case 26: {
            routes_.AddEntriesFrom(input, _repeated_routes_codec);
            break;
          }
          case 32: {
            RequireTls = (global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType) input.ReadEnum();
            break;
          }
          case 42: {
            virtualClusters_.AddEntriesFrom(input, _repeated_virtualClusters_codec);
            break;
          }
          case 50: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 58: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 66: {
            if (cors_ == null) {
              Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 106: {
            requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 112: {
            IncludeRequestAttemptCount = input.ReadBool();
            break;
          }
          case 122: {
            typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 130: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 138: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
          case 146: {
            uint? value = _single_perRequestBufferLimitBytes_codec.Read(input);
            if (perRequestBufferLimitBytes_ == null || value != 0) {
              PerRequestBufferLimitBytes = value;
            }
            break;
          }
          case 152: {
            IncludeAttemptCountInResponse = input.ReadBool();
            break;
          }
          case 162: {
            if (retryPolicyTypedConfig_ == null) {
              RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(RetryPolicyTypedConfig);
            break;
          }
          case 170: {
            if (matcher_ == null) {
              Matcher = new global::Xds.Type.Matcher.V3.Matcher();
            }
            input.ReadMessage(Matcher);
            break;
          }
          case 178: {
            requestMirrorPolicies_.AddEntriesFrom(input, _repeated_requestMirrorPolicies_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            domains_.AddEntriesFrom(ref input, _repeated_domains_codec);
            break;
          }
          case 26: {
            routes_.AddEntriesFrom(ref input, _repeated_routes_codec);
            break;
          }
          case 32: {
            RequireTls = (global::Envoy.Config.Route.V3.VirtualHost.Types.TlsRequirementType) input.ReadEnum();
            break;
          }
          case 42: {
            virtualClusters_.AddEntriesFrom(ref input, _repeated_virtualClusters_codec);
            break;
          }
          case 50: {
            rateLimits_.AddEntriesFrom(ref input, _repeated_rateLimits_codec);
            break;
          }
          case 58: {
            requestHeadersToAdd_.AddEntriesFrom(ref input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 66: {
            if (cors_ == null) {
              Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(ref input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(ref input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 106: {
            requestHeadersToRemove_.AddEntriesFrom(ref input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 112: {
            IncludeRequestAttemptCount = input.ReadBool();
            break;
          }
          case 122: {
            typedPerFilterConfig_.AddEntriesFrom(ref input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 130: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 138: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
          case 146: {
            uint? value = _single_perRequestBufferLimitBytes_codec.Read(ref input);
            if (perRequestBufferLimitBytes_ == null || value != 0) {
              PerRequestBufferLimitBytes = value;
            }
            break;
          }
          case 152: {
            IncludeAttemptCountInResponse = input.ReadBool();
            break;
          }
          case 162: {
            if (retryPolicyTypedConfig_ == null) {
              RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(RetryPolicyTypedConfig);
            break;
          }
          case 170: {
            if (matcher_ == null) {
              Matcher = new global::Xds.Type.Matcher.V3.Matcher();
            }
            input.ReadMessage(Matcher);
            break;
          }
          case 178: {
            requestMirrorPolicies_.AddEntriesFrom(ref input, _repeated_requestMirrorPolicies_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the VirtualHost message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum TlsRequirementType {
        /// <summary>
        /// No TLS requirement for the virtual host.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// External requests must use TLS. If a request is external and it is not
        /// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("EXTERNAL_ONLY")] ExternalOnly = 1,
        /// <summary>
        /// All requests must use TLS. If a request is not using TLS, a 301 redirect
        /// will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("ALL")] All = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A filter-defined action type.
  /// </summary>
  public sealed partial class FilterAction : pb::IMessage<FilterAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FilterAction> _parser = new pb::MessageParser<FilterAction>(() => new FilterAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FilterAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterAction(FilterAction other) : this() {
      action_ = other.action_ != null ? other.action_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterAction Clone() {
      return new FilterAction(this);
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Any action_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FilterAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FilterAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Action, other.Action)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (action_ != null) hash ^= Action.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (action_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Action);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (action_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Action);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (action_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Action);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FilterAction other) {
      if (other == null) {
        return;
      }
      if (other.action_ != null) {
        if (action_ == null) {
          Action = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        Action.MergeFrom(other.Action);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (action_ == null) {
              Action = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Action);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (action_ == null) {
              Action = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Action);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A route is both a specification of how to match a request as well as an indication of what to do
  /// next (e.g., redirect, forward, rewrite, etc.).
  ///
  /// .. attention::
  ///
  ///   Envoy supports routing on HTTP method via :ref:`header matching
  ///   &lt;envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
  /// [#next-free-field: 20]
  /// </summary>
  public sealed partial class Route : pb::IMessage<Route>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Route> _parser = new pb::MessageParser<Route>(() => new Route());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Route> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route(Route other) : this() {
      name_ = other.name_;
      match_ = other.match_ != null ? other.match_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      decorator_ = other.decorator_ != null ? other.decorator_.Clone() : null;
      typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      tracing_ = other.tracing_ != null ? other.tracing_.Clone() : null;
      PerRequestBufferLimitBytes = other.PerRequestBufferLimitBytes;
      statPrefix_ = other.statPrefix_;
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          Route_ = other.Route_.Clone();
          break;
        case ActionOneofCase.Redirect:
          Redirect = other.Redirect.Clone();
          break;
        case ActionOneofCase.DirectResponse:
          DirectResponse = other.DirectResponse.Clone();
          break;
        case ActionOneofCase.FilterAction:
          FilterAction = other.FilterAction.Clone();
          break;
        case ActionOneofCase.NonForwardingAction:
          NonForwardingAction = other.NonForwardingAction.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Route Clone() {
      return new Route(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 14;
    private string name_ = "";
    /// <summary>
    /// Name for the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "match" field.</summary>
    public const int MatchFieldNumber = 1;
    private global::Envoy.Config.Route.V3.RouteMatch match_;
    /// <summary>
    /// Route matching parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteMatch Match {
      get { return match_; }
      set {
        match_ = value;
      }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int Route_FieldNumber = 2;
    /// <summary>
    /// Route request to some upstream cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteAction Route_ {
      get { return actionCase_ == ActionOneofCase.Route_ ? (global::Envoy.Config.Route.V3.RouteAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Route_;
      }
    }

    /// <summary>Field number for the "redirect" field.</summary>
    public const int RedirectFieldNumber = 3;
    /// <summary>
    /// Return a redirect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RedirectAction Redirect {
      get { return actionCase_ == ActionOneofCase.Redirect ? (global::Envoy.Config.Route.V3.RedirectAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Redirect;
      }
    }

    /// <summary>Field number for the "direct_response" field.</summary>
    public const int DirectResponseFieldNumber = 7;
    /// <summary>
    /// Return an arbitrary HTTP response directly, without proxying.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.DirectResponseAction DirectResponse {
      get { return actionCase_ == ActionOneofCase.DirectResponse ? (global::Envoy.Config.Route.V3.DirectResponseAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.DirectResponse;
      }
    }

    /// <summary>Field number for the "filter_action" field.</summary>
    public const int FilterActionFieldNumber = 17;
    /// <summary>
    /// [#not-implemented-hide:]
    /// A filter-defined action (e.g., it could dynamically generate the RouteAction).
    /// [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
    /// implemented]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.FilterAction FilterAction {
      get { return actionCase_ == ActionOneofCase.FilterAction ? (global::Envoy.Config.Route.V3.FilterAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.FilterAction;
      }
    }

    /// <summary>Field number for the "non_forwarding_action" field.</summary>
    public const int NonForwardingActionFieldNumber = 18;
    /// <summary>
    /// [#not-implemented-hide:]
    /// An action used when the route will generate a response directly,
    /// without forwarding to an upstream host. This will be used in non-proxy
    /// xDS clients like the gRPC server. It could also be used in the future
    /// in Envoy for a filter that directly generates responses for requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.NonForwardingAction NonForwardingAction {
      get { return actionCase_ == ActionOneofCase.NonForwardingAction ? (global::Envoy.Config.Route.V3.NonForwardingAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.NonForwardingAction;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 4;
    private global::Envoy.Config.Core.V3.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information
    /// about the route. It can be used for configuration, stats, and logging.
    /// The metadata should go under the filter namespace that will need it.
    /// For instance, if the metadata is intended for the Router filter,
    /// the filter name should be specified as ``envoy.filters.http.router``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "decorator" field.</summary>
    public const int DecoratorFieldNumber = 5;
    private global::Envoy.Config.Route.V3.Decorator decorator_;
    /// <summary>
    /// Decorator for the matched route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.Decorator Decorator {
      get { return decorator_; }
      set {
        decorator_ = value;
      }
    }

    /// <summary>Field number for the "typed_per_filter_config" field.</summary>
    public const int TypedPerFilterConfigFieldNumber = 13;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 106);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The per_filter_config field can be used to provide route-specific configurations for filters.
    /// The key should match the :ref:`filter config name
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
    /// The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
    /// be used for the backwards compatibility. If there is no entry referred by the filter config name, the
    /// entry referred by the canonical filter name will be provided to the filters as fallback.
    ///
    /// Use of this field is filter specific;
    /// see the :ref:`HTTP filter documentation &lt;config_http_filters>` for if and how it is utilized.
    /// [#comment: An entry's value may be wrapped in a
    /// :ref:`FilterConfig&lt;envoy_v3_api_msg_config.route.v3.FilterConfig>`
    /// message to specify additional options.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
      get { return typedPerFilterConfig_; }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to requests matching this
    /// route. Headers specified at this level are applied before headers from the
    /// enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
    /// :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "request_headers_to_remove" field.</summary>
    public const int RequestHeadersToRemoveFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each request
    /// matching this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequestHeadersToRemove {
      get { return requestHeadersToRemove_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to responses to requests
    /// matching this route. Headers specified at this level are applied before
    /// headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
    /// :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on
    /// :ref:`custom request headers &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// to requests matching this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "tracing" field.</summary>
    public const int TracingFieldNumber = 15;
    private global::Envoy.Config.Route.V3.Tracing tracing_;
    /// <summary>
    /// Presence of the object defines whether the connection manager's tracing configuration
    /// is overridden by this route specific instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.Tracing Tracing {
      get { return tracing_; }
      set {
        tracing_ = value;
      }
    }

    /// <summary>Field number for the "per_request_buffer_limit_bytes" field.</summary>
    public const int PerRequestBufferLimitBytesFieldNumber = 16;
    private static readonly pb::FieldCodec<uint?> _single_perRequestBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(130);
    private uint? perRequestBufferLimitBytes_;
    /// <summary>
    /// The maximum bytes which will be buffered for retries and shadowing.
    /// If set, the bytes actually buffered will be the minimum value of this and the
    /// listener per_connection_buffer_limit_bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? PerRequestBufferLimitBytes {
      get { return perRequestBufferLimitBytes_; }
      set {
        perRequestBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 19;
    private string statPrefix_ = "";
    /// <summary>
    /// The human readable prefix to use when emitting statistics for this endpoint.
    /// The statistics are rooted at vhost.&lt;virtual host name>.route.&lt;stat_prefix>.
    /// This should be set for highly critical
    /// endpoints that one wishes to get per-route statistics on.
    /// If not set, endpoint statistics are not generated.
    ///
    /// The emitted statistics are the same as those documented for :ref:`virtual clusters &lt;config_http_filters_router_vcluster_stats>`.
    ///
    /// .. warning::
    ///
    ///    We do not recommend setting up a stat prefix for
    ///    every application endpoint. This is both not easily maintainable and
    ///    statistics use a non-trivial amount of memory(approximately 1KiB per route).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object action_;
    /// <summary>Enum of possible cases for the "action" oneof.</summary>
    public enum ActionOneofCase {
      None = 0,
      Route_ = 2,
      Redirect = 3,
      DirectResponse = 7,
      FilterAction = 17,
      NonForwardingAction = 18,
    }
    private ActionOneofCase actionCase_ = ActionOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ActionOneofCase ActionCase {
      get { return actionCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAction() {
      actionCase_ = ActionOneofCase.None;
      action_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Route);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Route other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Match, other.Match)) return false;
      if (!object.Equals(Route_, other.Route_)) return false;
      if (!object.Equals(Redirect, other.Redirect)) return false;
      if (!object.Equals(DirectResponse, other.DirectResponse)) return false;
      if (!object.Equals(FilterAction, other.FilterAction)) return false;
      if (!object.Equals(NonForwardingAction, other.NonForwardingAction)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Decorator, other.Decorator)) return false;
      if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if (!object.Equals(Tracing, other.Tracing)) return false;
      if (PerRequestBufferLimitBytes != other.PerRequestBufferLimitBytes) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if (ActionCase != other.ActionCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (match_ != null) hash ^= Match.GetHashCode();
      if (actionCase_ == ActionOneofCase.Route_) hash ^= Route_.GetHashCode();
      if (actionCase_ == ActionOneofCase.Redirect) hash ^= Redirect.GetHashCode();
      if (actionCase_ == ActionOneofCase.DirectResponse) hash ^= DirectResponse.GetHashCode();
      if (actionCase_ == ActionOneofCase.FilterAction) hash ^= FilterAction.GetHashCode();
      if (actionCase_ == ActionOneofCase.NonForwardingAction) hash ^= NonForwardingAction.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (decorator_ != null) hash ^= Decorator.GetHashCode();
      hash ^= TypedPerFilterConfig.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= requestHeadersToRemove_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      if (tracing_ != null) hash ^= Tracing.GetHashCode();
      if (perRequestBufferLimitBytes_ != null) hash ^= PerRequestBufferLimitBytes.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      hash ^= (int) actionCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (match_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        output.WriteRawTag(18);
        output.WriteMessage(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        output.WriteRawTag(26);
        output.WriteMessage(Redirect);
      }
      if (metadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Metadata);
      }
      if (decorator_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Decorator);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        output.WriteRawTag(58);
        output.WriteMessage(DirectResponse);
      }
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
      typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(Name);
      }
      if (tracing_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Tracing);
      }
      if (perRequestBufferLimitBytes_ != null) {
        _single_perRequestBufferLimitBytes_codec.WriteTagAndValue(output, PerRequestBufferLimitBytes);
      }
      if (actionCase_ == ActionOneofCase.FilterAction) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(FilterAction);
      }
      if (actionCase_ == ActionOneofCase.NonForwardingAction) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(NonForwardingAction);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(StatPrefix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (match_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        output.WriteRawTag(18);
        output.WriteMessage(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        output.WriteRawTag(26);
        output.WriteMessage(Redirect);
      }
      if (metadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Metadata);
      }
      if (decorator_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Decorator);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        output.WriteRawTag(58);
        output.WriteMessage(DirectResponse);
      }
      requestHeadersToAdd_.WriteTo(ref output, _repeated_requestHeadersToAdd_codec);
      responseHeadersToAdd_.WriteTo(ref output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(ref output, _repeated_responseHeadersToRemove_codec);
      requestHeadersToRemove_.WriteTo(ref output, _repeated_requestHeadersToRemove_codec);
      typedPerFilterConfig_.WriteTo(ref output, _map_typedPerFilterConfig_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(Name);
      }
      if (tracing_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Tracing);
      }
      if (perRequestBufferLimitBytes_ != null) {
        _single_perRequestBufferLimitBytes_codec.WriteTagAndValue(ref output, PerRequestBufferLimitBytes);
      }
      if (actionCase_ == ActionOneofCase.FilterAction) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(FilterAction);
      }
      if (actionCase_ == ActionOneofCase.NonForwardingAction) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(NonForwardingAction);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(StatPrefix);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (match_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Redirect);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DirectResponse);
      }
      if (actionCase_ == ActionOneofCase.FilterAction) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(FilterAction);
      }
      if (actionCase_ == ActionOneofCase.NonForwardingAction) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(NonForwardingAction);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (decorator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Decorator);
      }
      size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      if (tracing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tracing);
      }
      if (perRequestBufferLimitBytes_ != null) {
        size += _single_perRequestBufferLimitBytes_codec.CalculateSizeWithTag(PerRequestBufferLimitBytes);
      }
      if (StatPrefix.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Route other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.match_ != null) {
        if (match_ == null) {
          Match = new global::Envoy.Config.Route.V3.RouteMatch();
        }
        Match.MergeFrom(other.Match);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Config.Core.V3.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.decorator_ != null) {
        if (decorator_ == null) {
          Decorator = new global::Envoy.Config.Route.V3.Decorator();
        }
        Decorator.MergeFrom(other.Decorator);
      }
      typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      if (other.tracing_ != null) {
        if (tracing_ == null) {
          Tracing = new global::Envoy.Config.Route.V3.Tracing();
        }
        Tracing.MergeFrom(other.Tracing);
      }
      if (other.perRequestBufferLimitBytes_ != null) {
        if (perRequestBufferLimitBytes_ == null || other.PerRequestBufferLimitBytes != 0) {
          PerRequestBufferLimitBytes = other.PerRequestBufferLimitBytes;
        }
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          if (Route_ == null) {
            Route_ = new global::Envoy.Config.Route.V3.RouteAction();
          }
          Route_.MergeFrom(other.Route_);
          break;
        case ActionOneofCase.Redirect:
          if (Redirect == null) {
            Redirect = new global::Envoy.Config.Route.V3.RedirectAction();
          }
          Redirect.MergeFrom(other.Redirect);
          break;
        case ActionOneofCase.DirectResponse:
          if (DirectResponse == null) {
            DirectResponse = new global::Envoy.Config.Route.V3.DirectResponseAction();
          }
          DirectResponse.MergeFrom(other.DirectResponse);
          break;
        case ActionOneofCase.FilterAction:
          if (FilterAction == null) {
            FilterAction = new global::Envoy.Config.Route.V3.FilterAction();
          }
          FilterAction.MergeFrom(other.FilterAction);
          break;
        case ActionOneofCase.NonForwardingAction:
          if (NonForwardingAction == null) {
            NonForwardingAction = new global::Envoy.Config.Route.V3.NonForwardingAction();
          }
          NonForwardingAction.MergeFrom(other.NonForwardingAction);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (match_ == null) {
              Match = new global::Envoy.Config.Route.V3.RouteMatch();
            }
            input.ReadMessage(Match);
            break;
          }
          case 18: {
            global::Envoy.Config.Route.V3.RouteAction subBuilder = new global::Envoy.Config.Route.V3.RouteAction();
            if (actionCase_ == ActionOneofCase.Route_) {
              subBuilder.MergeFrom(Route_);
            }
            input.ReadMessage(subBuilder);
            Route_ = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Route.V3.RedirectAction subBuilder = new global::Envoy.Config.Route.V3.RedirectAction();
            if (actionCase_ == ActionOneofCase.Redirect) {
              subBuilder.MergeFrom(Redirect);
            }
            input.ReadMessage(subBuilder);
            Redirect = subBuilder;
            break;
          }
          case 34: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 42: {
            if (decorator_ == null) {
              Decorator = new global::Envoy.Config.Route.V3.Decorator();
            }
            input.ReadMessage(Decorator);
            break;
          }
          case 58: {
            global::Envoy.Config.Route.V3.DirectResponseAction subBuilder = new global::Envoy.Config.Route.V3.DirectResponseAction();
            if (actionCase_ == ActionOneofCase.DirectResponse) {
              subBuilder.MergeFrom(DirectResponse);
            }
            input.ReadMessage(subBuilder);
            DirectResponse = subBuilder;
            break;
          }
          case 74: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 98: {
            requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 106: {
            typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 114: {
            Name = input.ReadString();
            break;
          }
          case 122: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Config.Route.V3.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
          case 130: {
            uint? value = _single_perRequestBufferLimitBytes_codec.Read(input);
            if (perRequestBufferLimitBytes_ == null || value != 0) {
              PerRequestBufferLimitBytes = value;
            }
            break;
          }
          case 138: {
            global::Envoy.Config.Route.V3.FilterAction subBuilder = new global::Envoy.Config.Route.V3.FilterAction();
            if (actionCase_ == ActionOneofCase.FilterAction) {
              subBuilder.MergeFrom(FilterAction);
            }
            input.ReadMessage(subBuilder);
            FilterAction = subBuilder;
            break;
          }
          case 146: {
            global::Envoy.Config.Route.V3.NonForwardingAction subBuilder = new global::Envoy.Config.Route.V3.NonForwardingAction();
            if (actionCase_ == ActionOneofCase.NonForwardingAction) {
              subBuilder.MergeFrom(NonForwardingAction);
            }
            input.ReadMessage(subBuilder);
            NonForwardingAction = subBuilder;
            break;
          }
          case 154: {
            StatPrefix = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (match_ == null) {
              Match = new global::Envoy.Config.Route.V3.RouteMatch();
            }
            input.ReadMessage(Match);
            break;
          }
          case 18: {
            global::Envoy.Config.Route.V3.RouteAction subBuilder = new global::Envoy.Config.Route.V3.RouteAction();
            if (actionCase_ == ActionOneofCase.Route_) {
              subBuilder.MergeFrom(Route_);
            }
            input.ReadMessage(subBuilder);
            Route_ = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Config.Route.V3.RedirectAction subBuilder = new global::Envoy.Config.Route.V3.RedirectAction();
            if (actionCase_ == ActionOneofCase.Redirect) {
              subBuilder.MergeFrom(Redirect);
            }
            input.ReadMessage(subBuilder);
            Redirect = subBuilder;
            break;
          }
          case 34: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 42: {
            if (decorator_ == null) {
              Decorator = new global::Envoy.Config.Route.V3.Decorator();
            }
            input.ReadMessage(Decorator);
            break;
          }
          case 58: {
            global::Envoy.Config.Route.V3.DirectResponseAction subBuilder = new global::Envoy.Config.Route.V3.DirectResponseAction();
            if (actionCase_ == ActionOneofCase.DirectResponse) {
              subBuilder.MergeFrom(DirectResponse);
            }
            input.ReadMessage(subBuilder);
            DirectResponse = subBuilder;
            break;
          }
          case 74: {
            requestHeadersToAdd_.AddEntriesFrom(ref input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(ref input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(ref input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 98: {
            requestHeadersToRemove_.AddEntriesFrom(ref input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 106: {
            typedPerFilterConfig_.AddEntriesFrom(ref input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 114: {
            Name = input.ReadString();
            break;
          }
          case 122: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Config.Route.V3.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
          case 130: {
            uint? value = _single_perRequestBufferLimitBytes_codec.Read(ref input);
            if (perRequestBufferLimitBytes_ == null || value != 0) {
              PerRequestBufferLimitBytes = value;
            }
            break;
          }
          case 138: {
            global::Envoy.Config.Route.V3.FilterAction subBuilder = new global::Envoy.Config.Route.V3.FilterAction();
            if (actionCase_ == ActionOneofCase.FilterAction) {
              subBuilder.MergeFrom(FilterAction);
            }
            input.ReadMessage(subBuilder);
            FilterAction = subBuilder;
            break;
          }
          case 146: {
            global::Envoy.Config.Route.V3.NonForwardingAction subBuilder = new global::Envoy.Config.Route.V3.NonForwardingAction();
            if (actionCase_ == ActionOneofCase.NonForwardingAction) {
              subBuilder.MergeFrom(NonForwardingAction);
            }
            input.ReadMessage(subBuilder);
            NonForwardingAction = subBuilder;
            break;
          }
          case 154: {
            StatPrefix = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Compared to the :ref:`cluster &lt;envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
  /// single upstream cluster as the target of a request, the :ref:`weighted_clusters
  /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
  /// multiple upstream clusters along with weights that indicate the percentage of
  /// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
  /// weights.
  /// </summary>
  public sealed partial class WeightedCluster : pb::IMessage<WeightedCluster>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WeightedCluster> _parser = new pb::MessageParser<WeightedCluster>(() => new WeightedCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<WeightedCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedCluster(WeightedCluster other) : this() {
      clusters_ = other.clusters_.Clone();
      TotalWeight = other.TotalWeight;
      runtimeKeyPrefix_ = other.runtimeKeyPrefix_;
      switch (other.RandomValueSpecifierCase) {
        case RandomValueSpecifierOneofCase.HeaderName:
          HeaderName = other.HeaderName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedCluster Clone() {
      return new WeightedCluster(this);
    }

    /// <summary>Field number for the "clusters" field.</summary>
    public const int ClustersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight> _repeated_clusters_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight> clusters_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight>();
    /// <summary>
    /// Specifies one or more upstream clusters associated with the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.WeightedCluster.Types.ClusterWeight> Clusters {
      get { return clusters_; }
    }

    /// <summary>Field number for the "total_weight" field.</summary>
    public const int TotalWeightFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_totalWeight_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? totalWeight_;
    /// <summary>
    /// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
    /// value, if this is greater than 0.
    /// This field is now deprecated, and the client will use the sum of all
    /// cluster weights. It is up to the management server to supply the correct weights.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? TotalWeight {
      get { return totalWeight_; }
      set {
        totalWeight_ = value;
      }
    }


    /// <summary>Field number for the "runtime_key_prefix" field.</summary>
    public const int RuntimeKeyPrefixFieldNumber = 2;
    private string runtimeKeyPrefix_ = "";
    /// <summary>
    /// Specifies the runtime key prefix that should be used to construct the
    /// runtime keys associated with each cluster. When the ``runtime_key_prefix`` is
    /// specified, the router will look for weights associated with each upstream
    /// cluster under the key ``runtime_key_prefix`` + ``.`` + ``cluster[i].name`` where
    /// ``cluster[i]`` denotes an entry in the clusters array field. If the runtime
    /// key for the cluster does not exist, the value specified in the
    /// configuration file will be used as the default weight. See the :ref:`runtime documentation
    /// &lt;operations_runtime>` for how key names map to the underlying implementation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RuntimeKeyPrefix {
      get { return runtimeKeyPrefix_; }
      set {
        runtimeKeyPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "header_name" field.</summary>
    public const int HeaderNameFieldNumber = 4;
    /// <summary>
    /// Specifies the header name that is used to look up the random value passed in the request header.
    /// This is used to ensure consistent cluster picking across multiple proxy levels for weighted traffic.
    /// If header is not present or invalid, Envoy will fall back to use the internally generated random value.
    /// This header is expected to be single-valued header as we only want to have one selected value throughout
    /// the process for the consistency. And the value is a unsigned number between 0 and UINT64_MAX.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HeaderName {
      get { return randomValueSpecifierCase_ == RandomValueSpecifierOneofCase.HeaderName ? (string) randomValueSpecifier_ : ""; }
      set {
        randomValueSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        randomValueSpecifierCase_ = RandomValueSpecifierOneofCase.HeaderName;
      }
    }

    private object randomValueSpecifier_;
    /// <summary>Enum of possible cases for the "random_value_specifier" oneof.</summary>
    public enum RandomValueSpecifierOneofCase {
      None = 0,
      HeaderName = 4,
    }
    private RandomValueSpecifierOneofCase randomValueSpecifierCase_ = RandomValueSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RandomValueSpecifierOneofCase RandomValueSpecifierCase {
      get { return randomValueSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRandomValueSpecifier() {
      randomValueSpecifierCase_ = RandomValueSpecifierOneofCase.None;
      randomValueSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as WeightedCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(WeightedCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!clusters_.Equals(other.clusters_)) return false;
      if (TotalWeight != other.TotalWeight) return false;
      if (RuntimeKeyPrefix != other.RuntimeKeyPrefix) return false;
      if (HeaderName != other.HeaderName) return false;
      if (RandomValueSpecifierCase != other.RandomValueSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= clusters_.GetHashCode();
      if (totalWeight_ != null) hash ^= TotalWeight.GetHashCode();
      if (RuntimeKeyPrefix.Length != 0) hash ^= RuntimeKeyPrefix.GetHashCode();
      if (randomValueSpecifierCase_ == RandomValueSpecifierOneofCase.HeaderName) hash ^= HeaderName.GetHashCode();
      hash ^= (int) randomValueSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      clusters_.WriteTo(output, _repeated_clusters_codec);
      if (RuntimeKeyPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RuntimeKeyPrefix);
      }
      if (totalWeight_ != null) {
        _single_totalWeight_codec.WriteTagAndValue(output, TotalWeight);
      }
      if (randomValueSpecifierCase_ == RandomValueSpecifierOneofCase.HeaderName) {
        output.WriteRawTag(34);
        output.WriteString(HeaderName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      clusters_.WriteTo(ref output, _repeated_clusters_codec);
      if (RuntimeKeyPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RuntimeKeyPrefix);
      }
      if (totalWeight_ != null) {
        _single_totalWeight_codec.WriteTagAndValue(ref output, TotalWeight);
      }
      if (randomValueSpecifierCase_ == RandomValueSpecifierOneofCase.HeaderName) {
        output.WriteRawTag(34);
        output.WriteString(HeaderName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += clusters_.CalculateSize(_repeated_clusters_codec);
      if (totalWeight_ != null) {
        size += _single_totalWeight_codec.CalculateSizeWithTag(TotalWeight);
      }
      if (RuntimeKeyPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RuntimeKeyPrefix);
      }
      if (randomValueSpecifierCase_ == RandomValueSpecifierOneofCase.HeaderName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(WeightedCluster other) {
      if (other == null) {
        return;
      }
      clusters_.Add(other.clusters_);
      if (other.totalWeight_ != null) {
        if (totalWeight_ == null || other.TotalWeight != 0) {
          TotalWeight = other.TotalWeight;
        }
      }
      if (other.RuntimeKeyPrefix.Length != 0) {
        RuntimeKeyPrefix = other.RuntimeKeyPrefix;
      }
      switch (other.RandomValueSpecifierCase) {
        case RandomValueSpecifierOneofCase.HeaderName:
          HeaderName = other.HeaderName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            clusters_.AddEntriesFrom(input, _repeated_clusters_codec);
            break;
          }
          case 18: {
            RuntimeKeyPrefix = input.ReadString();
            break;
          }
          case 26: {
            uint? value = _single_totalWeight_codec.Read(input);
            if (totalWeight_ == null || value != 0) {
              TotalWeight = value;
            }
            break;
          }
          case 34: {
            HeaderName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            clusters_.AddEntriesFrom(ref input, _repeated_clusters_codec);
            break;
          }
          case 18: {
            RuntimeKeyPrefix = input.ReadString();
            break;
          }
          case 26: {
            uint? value = _single_totalWeight_codec.Read(ref input);
            if (totalWeight_ == null || value != 0) {
              TotalWeight = value;
            }
            break;
          }
          case 34: {
            HeaderName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the WeightedCluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// [#next-free-field: 13]
      /// </summary>
      public sealed partial class ClusterWeight : pb::IMessage<ClusterWeight>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ClusterWeight> _parser = new pb::MessageParser<ClusterWeight>(() => new ClusterWeight());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ClusterWeight> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.WeightedCluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClusterWeight() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClusterWeight(ClusterWeight other) : this() {
          name_ = other.name_;
          clusterHeader_ = other.clusterHeader_;
          Weight = other.Weight;
          metadataMatch_ = other.metadataMatch_ != null ? other.metadataMatch_.Clone() : null;
          requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
          requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
          responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
          responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
          typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
          switch (other.HostRewriteSpecifierCase) {
            case HostRewriteSpecifierOneofCase.HostRewriteLiteral:
              HostRewriteLiteral = other.HostRewriteLiteral;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClusterWeight Clone() {
          return new ClusterWeight(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Only one of ``name`` and ``cluster_header`` may be specified.
        /// [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
        /// Name of the upstream cluster. The cluster must exist in the
        /// :ref:`cluster manager configuration &lt;config_cluster_manager>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "cluster_header" field.</summary>
        public const int ClusterHeaderFieldNumber = 12;
        private string clusterHeader_ = "";
        /// <summary>
        /// Only one of ``name`` and ``cluster_header`` may be specified.
        /// [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1 }]
        /// Envoy will determine the cluster to route to by reading the value of the
        /// HTTP header named by cluster_header from the request headers. If the
        /// header is not found or the referenced cluster does not exist, Envoy will
        /// return a 404 response.
        ///
        /// .. attention::
        ///
        ///   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
        ///   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
        ///
        /// .. note::
        ///
        ///   If the header appears multiple times only the first value is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ClusterHeader {
          get { return clusterHeader_; }
          set {
            clusterHeader_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_weight_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? weight_;
        /// <summary>
        /// The weight of the cluster. This value is relative to the other clusters'
        /// weights. When a request matches the route, the choice of an upstream cluster
        /// is determined by its weight. The sum of weights across all
        /// entries in the clusters array must be greater than 0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint? Weight {
          get { return weight_; }
          set {
            weight_ = value;
          }
        }


        /// <summary>Field number for the "metadata_match" field.</summary>
        public const int MetadataMatchFieldNumber = 3;
        private global::Envoy.Config.Core.V3.Metadata metadataMatch_;
        /// <summary>
        /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
        /// the upstream cluster with metadata matching what is set in this field will be considered for
        /// load balancing. Note that this will be merged with what's provided in
        /// :ref:`RouteAction.metadata_match &lt;envoy_v3_api_field_config.route.v3.RouteAction.metadata_match>`, with
        /// values here taking precedence. The filter name should be specified as ``envoy.lb``.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.Metadata MetadataMatch {
          get { return metadataMatch_; }
          set {
            metadataMatch_ = value;
          }
        }

        /// <summary>Field number for the "request_headers_to_add" field.</summary>
        public const int RequestHeadersToAddFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_requestHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to requests when this cluster is selected
        /// through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
        /// :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> RequestHeadersToAdd {
          get { return requestHeadersToAdd_; }
        }

        /// <summary>Field number for the "request_headers_to_remove" field.</summary>
        public const int RequestHeadersToRemoveFieldNumber = 9;
        private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
            = pb::FieldCodec.ForString(74);
        private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies a list of HTTP headers that should be removed from each request when
        /// this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> RequestHeadersToRemove {
          get { return requestHeadersToRemove_; }
        }

        /// <summary>Field number for the "response_headers_to_add" field.</summary>
        public const int ResponseHeadersToAddFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.HeaderValueOption> _repeated_responseHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Core.V3.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to responses when this cluster is selected
        /// through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
        /// :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Core.V3.HeaderValueOption> ResponseHeadersToAdd {
          get { return responseHeadersToAdd_; }
        }

        /// <summary>Field number for the "response_headers_to_remove" field.</summary>
        public const int ResponseHeadersToRemoveFieldNumber = 6;
        private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
            = pb::FieldCodec.ForString(50);
        private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies a list of headers to be removed from responses when this cluster is selected
        /// through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> ResponseHeadersToRemove {
          get { return responseHeadersToRemove_; }
        }

        /// <summary>Field number for the "typed_per_filter_config" field.</summary>
        public const int TypedPerFilterConfigFieldNumber = 10;
        private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
            = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 82);
        private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
        /// <summary>
        /// The per_filter_config field can be used to provide weighted cluster-specific configurations
        /// for filters.
        /// The key should match the :ref:`filter config name
        /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
        /// The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
        /// be used for the backwards compatibility. If there is no entry referred by the filter config name, the
        /// entry referred by the canonical filter name will be provided to the filters as fallback.
        ///
        /// Use of this field is filter specific;
        /// see the :ref:`HTTP filter documentation &lt;config_http_filters>` for if and how it is utilized.
        /// [#comment: An entry's value may be wrapped in a
        /// :ref:`FilterConfig&lt;envoy_v3_api_msg_config.route.v3.FilterConfig>`
        /// message to specify additional options.]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
          get { return typedPerFilterConfig_; }
        }

        /// <summary>Field number for the "host_rewrite_literal" field.</summary>
        public const int HostRewriteLiteralFieldNumber = 11;
        /// <summary>
        /// Indicates that during forwarding, the host header will be swapped with
        /// this value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string HostRewriteLiteral {
          get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral ? (string) hostRewriteSpecifier_ : ""; }
          set {
            hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.HostRewriteLiteral;
          }
        }

        private object hostRewriteSpecifier_;
        /// <summary>Enum of possible cases for the "host_rewrite_specifier" oneof.</summary>
        public enum HostRewriteSpecifierOneofCase {
          None = 0,
          HostRewriteLiteral = 11,
        }
        private HostRewriteSpecifierOneofCase hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HostRewriteSpecifierOneofCase HostRewriteSpecifierCase {
          get { return hostRewriteSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearHostRewriteSpecifier() {
          hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
          hostRewriteSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ClusterWeight);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ClusterWeight other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (ClusterHeader != other.ClusterHeader) return false;
          if (Weight != other.Weight) return false;
          if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
          if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
          if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
          if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
          if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
          if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
          if (HostRewriteLiteral != other.HostRewriteLiteral) return false;
          if (HostRewriteSpecifierCase != other.HostRewriteSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (ClusterHeader.Length != 0) hash ^= ClusterHeader.GetHashCode();
          if (weight_ != null) hash ^= Weight.GetHashCode();
          if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
          hash ^= requestHeadersToAdd_.GetHashCode();
          hash ^= requestHeadersToRemove_.GetHashCode();
          hash ^= responseHeadersToAdd_.GetHashCode();
          hash ^= responseHeadersToRemove_.GetHashCode();
          hash ^= TypedPerFilterConfig.GetHashCode();
          if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) hash ^= HostRewriteLiteral.GetHashCode();
          hash ^= (int) hostRewriteSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (weight_ != null) {
            _single_weight_codec.WriteTagAndValue(output, Weight);
          }
          if (metadataMatch_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MetadataMatch);
          }
          requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
          responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
          responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
          requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
          typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
          if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
            output.WriteRawTag(90);
            output.WriteString(HostRewriteLiteral);
          }
          if (ClusterHeader.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(ClusterHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (weight_ != null) {
            _single_weight_codec.WriteTagAndValue(ref output, Weight);
          }
          if (metadataMatch_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MetadataMatch);
          }
          requestHeadersToAdd_.WriteTo(ref output, _repeated_requestHeadersToAdd_codec);
          responseHeadersToAdd_.WriteTo(ref output, _repeated_responseHeadersToAdd_codec);
          responseHeadersToRemove_.WriteTo(ref output, _repeated_responseHeadersToRemove_codec);
          requestHeadersToRemove_.WriteTo(ref output, _repeated_requestHeadersToRemove_codec);
          typedPerFilterConfig_.WriteTo(ref output, _map_typedPerFilterConfig_codec);
          if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
            output.WriteRawTag(90);
            output.WriteString(HostRewriteLiteral);
          }
          if (ClusterHeader.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(ClusterHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (ClusterHeader.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterHeader);
          }
          if (weight_ != null) {
            size += _single_weight_codec.CalculateSizeWithTag(Weight);
          }
          if (metadataMatch_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
          }
          size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
          size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
          size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
          size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
          size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
          if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRewriteLiteral);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ClusterWeight other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.ClusterHeader.Length != 0) {
            ClusterHeader = other.ClusterHeader;
          }
          if (other.weight_ != null) {
            if (weight_ == null || other.Weight != 0) {
              Weight = other.Weight;
            }
          }
          if (other.metadataMatch_ != null) {
            if (metadataMatch_ == null) {
              MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
            }
            MetadataMatch.MergeFrom(other.MetadataMatch);
          }
          requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
          requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
          responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
          responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
          typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
          switch (other.HostRewriteSpecifierCase) {
            case HostRewriteSpecifierOneofCase.HostRewriteLiteral:
              HostRewriteLiteral = other.HostRewriteLiteral;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                uint? value = _single_weight_codec.Read(input);
                if (weight_ == null || value != 0) {
                  Weight = value;
                }
                break;
              }
              case 26: {
                if (metadataMatch_ == null) {
                  MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
                }
                input.ReadMessage(MetadataMatch);
                break;
              }
              case 34: {
                requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
                break;
              }
              case 42: {
                responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
                break;
              }
              case 50: {
                responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
                break;
              }
              case 74: {
                requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
                break;
              }
              case 82: {
                typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
                break;
              }
              case 90: {
                HostRewriteLiteral = input.ReadString();
                break;
              }
              case 98: {
                ClusterHeader = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                uint? value = _single_weight_codec.Read(ref input);
                if (weight_ == null || value != 0) {
                  Weight = value;
                }
                break;
              }
              case 26: {
                if (metadataMatch_ == null) {
                  MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
                }
                input.ReadMessage(MetadataMatch);
                break;
              }
              case 34: {
                requestHeadersToAdd_.AddEntriesFrom(ref input, _repeated_requestHeadersToAdd_codec);
                break;
              }
              case 42: {
                responseHeadersToAdd_.AddEntriesFrom(ref input, _repeated_responseHeadersToAdd_codec);
                break;
              }
              case 50: {
                responseHeadersToRemove_.AddEntriesFrom(ref input, _repeated_responseHeadersToRemove_codec);
                break;
              }
              case 74: {
                requestHeadersToRemove_.AddEntriesFrom(ref input, _repeated_requestHeadersToRemove_codec);
                break;
              }
              case 82: {
                typedPerFilterConfig_.AddEntriesFrom(ref input, _map_typedPerFilterConfig_codec);
                break;
              }
              case 90: {
                HostRewriteLiteral = input.ReadString();
                break;
              }
              case 98: {
                ClusterHeader = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for a cluster specifier plugin.
  /// </summary>
  public sealed partial class ClusterSpecifierPlugin : pb::IMessage<ClusterSpecifierPlugin>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClusterSpecifierPlugin> _parser = new pb::MessageParser<ClusterSpecifierPlugin>(() => new ClusterSpecifierPlugin());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClusterSpecifierPlugin> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterSpecifierPlugin() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterSpecifierPlugin(ClusterSpecifierPlugin other) : this() {
      extension_ = other.extension_ != null ? other.extension_.Clone() : null;
      isOptional_ = other.isOptional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterSpecifierPlugin Clone() {
      return new ClusterSpecifierPlugin(this);
    }

    /// <summary>Field number for the "extension" field.</summary>
    public const int ExtensionFieldNumber = 1;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig extension_;
    /// <summary>
    /// The name of the plugin and its opaque configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig Extension {
      get { return extension_; }
      set {
        extension_ = value;
      }
    }

    /// <summary>Field number for the "is_optional" field.</summary>
    public const int IsOptionalFieldNumber = 2;
    private bool isOptional_;
    /// <summary>
    /// If is_optional is not set or is set to false and the plugin defined by this message is not a
    /// supported type, the containing resource is NACKed. If is_optional is set to true, the resource
    /// would not be NACKed for this reason. In this case, routes referencing this plugin's name would
    /// not be treated as an illegal configuration, but would result in a failure if the route is
    /// selected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsOptional {
      get { return isOptional_; }
      set {
        isOptional_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClusterSpecifierPlugin);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClusterSpecifierPlugin other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Extension, other.Extension)) return false;
      if (IsOptional != other.IsOptional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (extension_ != null) hash ^= Extension.GetHashCode();
      if (IsOptional != false) hash ^= IsOptional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (extension_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Extension);
      }
      if (IsOptional != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (extension_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Extension);
      }
      if (IsOptional != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (extension_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Extension);
      }
      if (IsOptional != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClusterSpecifierPlugin other) {
      if (other == null) {
        return;
      }
      if (other.extension_ != null) {
        if (extension_ == null) {
          Extension = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        Extension.MergeFrom(other.Extension);
      }
      if (other.IsOptional != false) {
        IsOptional = other.IsOptional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (extension_ == null) {
              Extension = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(Extension);
            break;
          }
          case 16: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (extension_ == null) {
              Extension = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(Extension);
            break;
          }
          case 16: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 16]
  /// </summary>
  public sealed partial class RouteMatch : pb::IMessage<RouteMatch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RouteMatch> _parser = new pb::MessageParser<RouteMatch>(() => new RouteMatch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RouteMatch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteMatch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteMatch(RouteMatch other) : this() {
      CaseSensitive = other.CaseSensitive;
      runtimeFraction_ = other.runtimeFraction_ != null ? other.runtimeFraction_.Clone() : null;
      headers_ = other.headers_.Clone();
      queryParameters_ = other.queryParameters_.Clone();
      grpc_ = other.grpc_ != null ? other.grpc_.Clone() : null;
      tlsContext_ = other.tlsContext_ != null ? other.tlsContext_.Clone() : null;
      dynamicMetadata_ = other.dynamicMetadata_.Clone();
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.SafeRegex:
          SafeRegex = other.SafeRegex.Clone();
          break;
        case PathSpecifierOneofCase.ConnectMatcher:
          ConnectMatcher = other.ConnectMatcher.Clone();
          break;
        case PathSpecifierOneofCase.PathSeparatedPrefix:
          PathSeparatedPrefix = other.PathSeparatedPrefix;
          break;
        case PathSpecifierOneofCase.PathMatchPolicy:
          PathMatchPolicy = other.PathMatchPolicy.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteMatch Clone() {
      return new RouteMatch(this);
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 1;
    /// <summary>
    /// If specified, the route is a prefix rule meaning that the prefix must
    /// match the beginning of the ``:path`` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Prefix {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Prefix ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Prefix;
      }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    /// <summary>
    /// If specified, the route is an exact path rule meaning that the path must
    /// exactly match the ``:path`` header once the query string is removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Path ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "safe_regex" field.</summary>
    public const int SafeRegexFieldNumber = 10;
    /// <summary>
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the ``:path`` header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the ``:path`` header matches the regex.
    ///
    /// [#next-major-version: In the v3 API we should redo how path specification works such
    /// that we utilize StringMatcher, and additionally have consistent options around whether we
    /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    /// to deprecate the existing options. We should even consider whether we want to do away with
    /// path_specifier entirely and just rely on a set of header matchers which can already match
    /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
    /// stripping. This needs more thought.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.RegexMatcher SafeRegex {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex ? (global::Envoy.Type.Matcher.V3.RegexMatcher) pathSpecifier_ : null; }
      set {
        pathSpecifier_ = value;
        pathSpecifierCase_ = value == null ? PathSpecifierOneofCase.None : PathSpecifierOneofCase.SafeRegex;
      }
    }

    /// <summary>Field number for the "connect_matcher" field.</summary>
    public const int ConnectMatcherFieldNumber = 12;
    /// <summary>
    /// If this is used as the matcher, the matcher will only match CONNECT requests.
    /// Note that this will not match HTTP/2 upgrade-style CONNECT requests
    /// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
    /// upgrades.
    /// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
    /// where Extended CONNECT requests may have a path, the path matchers will work if
    /// there is a path present.
    /// Note that CONNECT support is currently considered alpha in Envoy.
    /// [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher ConnectMatcher {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher ? (global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher) pathSpecifier_ : null; }
      set {
        pathSpecifier_ = value;
        pathSpecifierCase_ = value == null ? PathSpecifierOneofCase.None : PathSpecifierOneofCase.ConnectMatcher;
      }
    }

    /// <summary>Field number for the "path_separated_prefix" field.</summary>
    public const int PathSeparatedPrefixFieldNumber = 14;
    /// <summary>
    /// If specified, the route is a path-separated prefix rule meaning that the
    /// ``:path`` header (without the query string) must either exactly match the
    /// ``path_separated_prefix`` or have it as a prefix, followed by ``/``
    ///
    /// For example, ``/api/dev`` would match
    /// ``/api/dev``, ``/api/dev/``, ``/api/dev/v1``, and ``/api/dev?param=true``
    /// but would not match ``/api/developer``
    ///
    /// Expect the value to not contain ``?`` or ``#`` and not to end in ``/``
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PathSeparatedPrefix {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.PathSeparatedPrefix ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.PathSeparatedPrefix;
      }
    }

    /// <summary>Field number for the "path_match_policy" field.</summary>
    public const int PathMatchPolicyFieldNumber = 15;
    /// <summary>
    /// [#extension-category: envoy.path.match]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig PathMatchPolicy {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy ? (global::Envoy.Config.Core.V3.TypedExtensionConfig) pathSpecifier_ : null; }
      set {
        pathSpecifier_ = value;
        pathSpecifierCase_ = value == null ? PathSpecifierOneofCase.None : PathSpecifierOneofCase.PathMatchPolicy;
      }
    }

    /// <summary>Field number for the "case_sensitive" field.</summary>
    public const int CaseSensitiveFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_caseSensitive_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? caseSensitive_;
    /// <summary>
    /// Indicates that prefix/path matching should be case sensitive. The default
    /// is true. Ignored for safe_regex matching.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? CaseSensitive {
      get { return caseSensitive_; }
      set {
        caseSensitive_ = value;
      }
    }


    /// <summary>Field number for the "runtime_fraction" field.</summary>
    public const int RuntimeFractionFieldNumber = 9;
    private global::Envoy.Config.Core.V3.RuntimeFractionalPercent runtimeFraction_;
    /// <summary>
    /// Indicates that the route should additionally match on a runtime key. Every time the route
    /// is considered for a match, it must also fall under the percentage of matches indicated by
    /// this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
    /// number is &lt;= the value of the numerator N, or if the key is not present, the default
    /// value, the router continues to evaluate the remaining match criteria. A runtime_fraction
    /// route configuration can be used to roll out route changes in a gradual manner without full
    /// code/config deploys. Refer to the :ref:`traffic shifting
    /// &lt;config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
    ///
    /// .. note::
    ///
    ///    Parsing this field is implemented such that the runtime key's data may be represented
    ///    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
    ///    integer with the assumption that the value is an integral percentage out of 100. For
    ///    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
    ///    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RuntimeFractionalPercent RuntimeFraction {
      get { return runtimeFraction_; }
      set {
        runtimeFraction_ = value;
      }
    }

    /// <summary>Field number for the "headers" field.</summary>
    public const int HeadersFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.HeaderMatcher> _repeated_headers_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Config.Route.V3.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher>();
    /// <summary>
    /// Specifies a set of headers that the route should match on. The router will
    /// check the requests headers against all the specified headers in the route
    /// config. A match will happen if all the headers in the route are present in
    /// the request with the same values (or based on presence if the value field
    /// is not in the config).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> Headers {
      get { return headers_; }
    }

    /// <summary>Field number for the "query_parameters" field.</summary>
    public const int QueryParametersFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.QueryParameterMatcher> _repeated_queryParameters_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Config.Route.V3.QueryParameterMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.QueryParameterMatcher> queryParameters_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.QueryParameterMatcher>();
    /// <summary>
    /// Specifies a set of URL query parameters on which the route should
    /// match. The router will check the query string from the ``path`` header
    /// against all the specified query parameters. If the number of specified
    /// query parameters is nonzero, they all must match the ``path`` header's
    /// query string for a match to occur.
    ///
    /// .. note::
    ///
    ///    If query parameters are used to pass request message fields when
    ///    `grpc_json_transcoder &lt;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter>`_
    ///    is used, the transcoded message fields maybe different. The query parameters are
    ///    url encoded, but the message fields are not. For example, if a query
    ///    parameter is "foo%20bar", the message field will be "foo bar".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.QueryParameterMatcher> QueryParameters {
      get { return queryParameters_; }
    }

    /// <summary>Field number for the "grpc" field.</summary>
    public const int GrpcFieldNumber = 8;
    private global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions grpc_;
    /// <summary>
    /// If specified, only gRPC requests will be matched. The router will check
    /// that the content-type header has a application/grpc or one of the various
    /// application/grpc+ values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions Grpc {
      get { return grpc_; }
      set {
        grpc_ = value;
      }
    }

    /// <summary>Field number for the "tls_context" field.</summary>
    public const int TlsContextFieldNumber = 11;
    private global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions tlsContext_;
    /// <summary>
    /// If specified, the client tls context will be matched against the defined
    /// match options.
    ///
    /// [#next-major-version: unify with RBAC]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions TlsContext {
      get { return tlsContext_; }
      set {
        tlsContext_ = value;
      }
    }

    /// <summary>Field number for the "dynamic_metadata" field.</summary>
    public const int DynamicMetadataFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Type.Matcher.V3.MetadataMatcher> _repeated_dynamicMetadata_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Type.Matcher.V3.MetadataMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Type.Matcher.V3.MetadataMatcher> dynamicMetadata_ = new pbc::RepeatedField<global::Envoy.Type.Matcher.V3.MetadataMatcher>();
    /// <summary>
    /// Specifies a set of dynamic metadata matchers on which the route should match.
    /// The router will check the dynamic metadata against all the specified dynamic metadata matchers.
    /// If the number of specified dynamic metadata matchers is nonzero, they all must match the
    /// dynamic metadata for a match to occur.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Type.Matcher.V3.MetadataMatcher> DynamicMetadata {
      get { return dynamicMetadata_; }
    }

    private object pathSpecifier_;
    /// <summary>Enum of possible cases for the "path_specifier" oneof.</summary>
    public enum PathSpecifierOneofCase {
      None = 0,
      Prefix = 1,
      Path = 2,
      SafeRegex = 10,
      ConnectMatcher = 12,
      PathSeparatedPrefix = 14,
      PathMatchPolicy = 15,
    }
    private PathSpecifierOneofCase pathSpecifierCase_ = PathSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PathSpecifierOneofCase PathSpecifierCase {
      get { return pathSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPathSpecifier() {
      pathSpecifierCase_ = PathSpecifierOneofCase.None;
      pathSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RouteMatch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RouteMatch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Prefix != other.Prefix) return false;
      if (Path != other.Path) return false;
      if (!object.Equals(SafeRegex, other.SafeRegex)) return false;
      if (!object.Equals(ConnectMatcher, other.ConnectMatcher)) return false;
      if (PathSeparatedPrefix != other.PathSeparatedPrefix) return false;
      if (!object.Equals(PathMatchPolicy, other.PathMatchPolicy)) return false;
      if (CaseSensitive != other.CaseSensitive) return false;
      if (!object.Equals(RuntimeFraction, other.RuntimeFraction)) return false;
      if(!headers_.Equals(other.headers_)) return false;
      if(!queryParameters_.Equals(other.queryParameters_)) return false;
      if (!object.Equals(Grpc, other.Grpc)) return false;
      if (!object.Equals(TlsContext, other.TlsContext)) return false;
      if(!dynamicMetadata_.Equals(other.dynamicMetadata_)) return false;
      if (PathSpecifierCase != other.PathSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) hash ^= Prefix.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) hash ^= SafeRegex.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) hash ^= ConnectMatcher.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathSeparatedPrefix) hash ^= PathSeparatedPrefix.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) hash ^= PathMatchPolicy.GetHashCode();
      if (caseSensitive_ != null) hash ^= CaseSensitive.GetHashCode();
      if (runtimeFraction_ != null) hash ^= RuntimeFraction.GetHashCode();
      hash ^= headers_.GetHashCode();
      hash ^= queryParameters_.GetHashCode();
      if (grpc_ != null) hash ^= Grpc.GetHashCode();
      if (tlsContext_ != null) hash ^= TlsContext.GetHashCode();
      hash ^= dynamicMetadata_.GetHashCode();
      hash ^= (int) pathSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (caseSensitive_ != null) {
        _single_caseSensitive_codec.WriteTagAndValue(output, CaseSensitive);
      }
      headers_.WriteTo(output, _repeated_headers_codec);
      queryParameters_.WriteTo(output, _repeated_queryParameters_codec);
      if (grpc_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Grpc);
      }
      if (runtimeFraction_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RuntimeFraction);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
        output.WriteRawTag(82);
        output.WriteMessage(SafeRegex);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) {
        output.WriteRawTag(98);
        output.WriteMessage(ConnectMatcher);
      }
      dynamicMetadata_.WriteTo(output, _repeated_dynamicMetadata_codec);
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathSeparatedPrefix) {
        output.WriteRawTag(114);
        output.WriteString(PathSeparatedPrefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) {
        output.WriteRawTag(122);
        output.WriteMessage(PathMatchPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (caseSensitive_ != null) {
        _single_caseSensitive_codec.WriteTagAndValue(ref output, CaseSensitive);
      }
      headers_.WriteTo(ref output, _repeated_headers_codec);
      queryParameters_.WriteTo(ref output, _repeated_queryParameters_codec);
      if (grpc_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Grpc);
      }
      if (runtimeFraction_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RuntimeFraction);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
        output.WriteRawTag(82);
        output.WriteMessage(SafeRegex);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) {
        output.WriteRawTag(98);
        output.WriteMessage(ConnectMatcher);
      }
      dynamicMetadata_.WriteTo(ref output, _repeated_dynamicMetadata_codec);
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathSeparatedPrefix) {
        output.WriteRawTag(114);
        output.WriteString(PathSeparatedPrefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) {
        output.WriteRawTag(122);
        output.WriteMessage(PathMatchPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SafeRegex);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectMatcher);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathSeparatedPrefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathSeparatedPrefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PathMatchPolicy);
      }
      if (caseSensitive_ != null) {
        size += _single_caseSensitive_codec.CalculateSizeWithTag(CaseSensitive);
      }
      if (runtimeFraction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RuntimeFraction);
      }
      size += headers_.CalculateSize(_repeated_headers_codec);
      size += queryParameters_.CalculateSize(_repeated_queryParameters_codec);
      if (grpc_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Grpc);
      }
      if (tlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsContext);
      }
      size += dynamicMetadata_.CalculateSize(_repeated_dynamicMetadata_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RouteMatch other) {
      if (other == null) {
        return;
      }
      if (other.caseSensitive_ != null) {
        if (caseSensitive_ == null || other.CaseSensitive != false) {
          CaseSensitive = other.CaseSensitive;
        }
      }
      if (other.runtimeFraction_ != null) {
        if (runtimeFraction_ == null) {
          RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
        }
        RuntimeFraction.MergeFrom(other.RuntimeFraction);
      }
      headers_.Add(other.headers_);
      queryParameters_.Add(other.queryParameters_);
      if (other.grpc_ != null) {
        if (grpc_ == null) {
          Grpc = new global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions();
        }
        Grpc.MergeFrom(other.Grpc);
      }
      if (other.tlsContext_ != null) {
        if (tlsContext_ == null) {
          TlsContext = new global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions();
        }
        TlsContext.MergeFrom(other.TlsContext);
      }
      dynamicMetadata_.Add(other.dynamicMetadata_);
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.SafeRegex:
          if (SafeRegex == null) {
            SafeRegex = new global::Envoy.Type.Matcher.V3.RegexMatcher();
          }
          SafeRegex.MergeFrom(other.SafeRegex);
          break;
        case PathSpecifierOneofCase.ConnectMatcher:
          if (ConnectMatcher == null) {
            ConnectMatcher = new global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher();
          }
          ConnectMatcher.MergeFrom(other.ConnectMatcher);
          break;
        case PathSpecifierOneofCase.PathSeparatedPrefix:
          PathSeparatedPrefix = other.PathSeparatedPrefix;
          break;
        case PathSpecifierOneofCase.PathMatchPolicy:
          if (PathMatchPolicy == null) {
            PathMatchPolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
          }
          PathMatchPolicy.MergeFrom(other.PathMatchPolicy);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_caseSensitive_codec.Read(input);
            if (caseSensitive_ == null || value != false) {
              CaseSensitive = value;
            }
            break;
          }
          case 50: {
            headers_.AddEntriesFrom(input, _repeated_headers_codec);
            break;
          }
          case 58: {
            queryParameters_.AddEntriesFrom(input, _repeated_queryParameters_codec);
            break;
          }
          case 66: {
            if (grpc_ == null) {
              Grpc = new global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions();
            }
            input.ReadMessage(Grpc);
            break;
          }
          case 74: {
            if (runtimeFraction_ == null) {
              RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(RuntimeFraction);
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.V3.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatcher();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
              subBuilder.MergeFrom(SafeRegex);
            }
            input.ReadMessage(subBuilder);
            SafeRegex = subBuilder;
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              TlsContext = new global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions();
            }
            input.ReadMessage(TlsContext);
            break;
          }
          case 98: {
            global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher subBuilder = new global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) {
              subBuilder.MergeFrom(ConnectMatcher);
            }
            input.ReadMessage(subBuilder);
            ConnectMatcher = subBuilder;
            break;
          }
          case 106: {
            dynamicMetadata_.AddEntriesFrom(input, _repeated_dynamicMetadata_codec);
            break;
          }
          case 114: {
            PathSeparatedPrefix = input.ReadString();
            break;
          }
          case 122: {
            global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) {
              subBuilder.MergeFrom(PathMatchPolicy);
            }
            input.ReadMessage(subBuilder);
            PathMatchPolicy = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_caseSensitive_codec.Read(ref input);
            if (caseSensitive_ == null || value != false) {
              CaseSensitive = value;
            }
            break;
          }
          case 50: {
            headers_.AddEntriesFrom(ref input, _repeated_headers_codec);
            break;
          }
          case 58: {
            queryParameters_.AddEntriesFrom(ref input, _repeated_queryParameters_codec);
            break;
          }
          case 66: {
            if (grpc_ == null) {
              Grpc = new global::Envoy.Config.Route.V3.RouteMatch.Types.GrpcRouteMatchOptions();
            }
            input.ReadMessage(Grpc);
            break;
          }
          case 74: {
            if (runtimeFraction_ == null) {
              RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(RuntimeFraction);
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.V3.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatcher();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
              subBuilder.MergeFrom(SafeRegex);
            }
            input.ReadMessage(subBuilder);
            SafeRegex = subBuilder;
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              TlsContext = new global::Envoy.Config.Route.V3.RouteMatch.Types.TlsContextMatchOptions();
            }
            input.ReadMessage(TlsContext);
            break;
          }
          case 98: {
            global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher subBuilder = new global::Envoy.Config.Route.V3.RouteMatch.Types.ConnectMatcher();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.ConnectMatcher) {
              subBuilder.MergeFrom(ConnectMatcher);
            }
            input.ReadMessage(subBuilder);
            ConnectMatcher = subBuilder;
            break;
          }
          case 106: {
            dynamicMetadata_.AddEntriesFrom(ref input, _repeated_dynamicMetadata_codec);
            break;
          }
          case 114: {
            PathSeparatedPrefix = input.ReadString();
            break;
          }
          case 122: {
            global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.PathMatchPolicy) {
              subBuilder.MergeFrom(PathMatchPolicy);
            }
            input.ReadMessage(subBuilder);
            PathMatchPolicy = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RouteMatch message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public sealed partial class GrpcRouteMatchOptions : pb::IMessage<GrpcRouteMatchOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<GrpcRouteMatchOptions> _parser = new pb::MessageParser<GrpcRouteMatchOptions>(() => new GrpcRouteMatchOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<GrpcRouteMatchOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteMatch.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public GrpcRouteMatchOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public GrpcRouteMatchOptions(GrpcRouteMatchOptions other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public GrpcRouteMatchOptions Clone() {
          return new GrpcRouteMatchOptions(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as GrpcRouteMatchOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(GrpcRouteMatchOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(GrpcRouteMatchOptions other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

      public sealed partial class TlsContextMatchOptions : pb::IMessage<TlsContextMatchOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<TlsContextMatchOptions> _parser = new pb::MessageParser<TlsContextMatchOptions>(() => new TlsContextMatchOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<TlsContextMatchOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteMatch.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TlsContextMatchOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TlsContextMatchOptions(TlsContextMatchOptions other) : this() {
          Presented = other.Presented;
          Validated = other.Validated;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TlsContextMatchOptions Clone() {
          return new TlsContextMatchOptions(this);
        }

        /// <summary>Field number for the "presented" field.</summary>
        public const int PresentedFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_presented_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? presented_;
        /// <summary>
        /// If specified, the route will match against whether or not a certificate is presented.
        /// If not specified, certificate presentation status (true or false) will not be considered when route matching.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? Presented {
          get { return presented_; }
          set {
            presented_ = value;
          }
        }


        /// <summary>Field number for the "validated" field.</summary>
        public const int ValidatedFieldNumber = 2;
        private static readonly pb::FieldCodec<bool?> _single_validated_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
        private bool? validated_;
        /// <summary>
        /// If specified, the route will match against whether or not a certificate is validated.
        /// If not specified, certificate validation status (true or false) will not be considered when route matching.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? Validated {
          get { return validated_; }
          set {
            validated_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as TlsContextMatchOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(TlsContextMatchOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Presented != other.Presented) return false;
          if (Validated != other.Validated) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (presented_ != null) hash ^= Presented.GetHashCode();
          if (validated_ != null) hash ^= Validated.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (presented_ != null) {
            _single_presented_codec.WriteTagAndValue(output, Presented);
          }
          if (validated_ != null) {
            _single_validated_codec.WriteTagAndValue(output, Validated);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (presented_ != null) {
            _single_presented_codec.WriteTagAndValue(ref output, Presented);
          }
          if (validated_ != null) {
            _single_validated_codec.WriteTagAndValue(ref output, Validated);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (presented_ != null) {
            size += _single_presented_codec.CalculateSizeWithTag(Presented);
          }
          if (validated_ != null) {
            size += _single_validated_codec.CalculateSizeWithTag(Validated);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(TlsContextMatchOptions other) {
          if (other == null) {
            return;
          }
          if (other.presented_ != null) {
            if (presented_ == null || other.Presented != false) {
              Presented = other.Presented;
            }
          }
          if (other.validated_ != null) {
            if (validated_ == null || other.Validated != false) {
              Validated = other.Validated;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_presented_codec.Read(input);
                if (presented_ == null || value != false) {
                  Presented = value;
                }
                break;
              }
              case 18: {
                bool? value = _single_validated_codec.Read(input);
                if (validated_ == null || value != false) {
                  Validated = value;
                }
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                bool? value = _single_presented_codec.Read(ref input);
                if (presented_ == null || value != false) {
                  Presented = value;
                }
                break;
              }
              case 18: {
                bool? value = _single_validated_codec.Read(ref input);
                if (validated_ == null || value != false) {
                  Validated = value;
                }
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// An extensible message for matching CONNECT requests.
      /// </summary>
      public sealed partial class ConnectMatcher : pb::IMessage<ConnectMatcher>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ConnectMatcher> _parser = new pb::MessageParser<ConnectMatcher>(() => new ConnectMatcher());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ConnectMatcher> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteMatch.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectMatcher() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectMatcher(ConnectMatcher other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectMatcher Clone() {
          return new ConnectMatcher(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ConnectMatcher);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ConnectMatcher other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ConnectMatcher other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Cors policy configuration.
  ///
  /// .. attention::
  ///
  ///   This message has been deprecated. Please use
  ///   :ref:`CorsPolicy in filter extension &lt;envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
  ///   as as alternative.
  ///
  /// [#next-free-field: 13]
  /// </summary>
  public sealed partial class CorsPolicy : pb::IMessage<CorsPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CorsPolicy> _parser = new pb::MessageParser<CorsPolicy>(() => new CorsPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CorsPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CorsPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CorsPolicy(CorsPolicy other) : this() {
      allowOriginStringMatch_ = other.allowOriginStringMatch_.Clone();
      allowMethods_ = other.allowMethods_;
      allowHeaders_ = other.allowHeaders_;
      exposeHeaders_ = other.exposeHeaders_;
      maxAge_ = other.maxAge_;
      AllowCredentials = other.AllowCredentials;
      shadowEnabled_ = other.shadowEnabled_ != null ? other.shadowEnabled_.Clone() : null;
      AllowPrivateNetworkAccess = other.AllowPrivateNetworkAccess;
      switch (other.EnabledSpecifierCase) {
        case EnabledSpecifierOneofCase.FilterEnabled:
          FilterEnabled = other.FilterEnabled.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CorsPolicy Clone() {
      return new CorsPolicy(this);
    }

    /// <summary>Field number for the "allow_origin_string_match" field.</summary>
    public const int AllowOriginStringMatchFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Envoy.Type.Matcher.V3.StringMatcher> _repeated_allowOriginStringMatch_codec
        = pb::FieldCodec.ForMessage(90, global::Envoy.Type.Matcher.V3.StringMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher> allowOriginStringMatch_ = new pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher>();
    /// <summary>
    /// Specifies string patterns that match allowed origins. An origin is allowed if any of the
    /// string matchers match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Type.Matcher.V3.StringMatcher> AllowOriginStringMatch {
      get { return allowOriginStringMatch_; }
    }

    /// <summary>Field number for the "allow_methods" field.</summary>
    public const int AllowMethodsFieldNumber = 2;
    private string allowMethods_ = "";
    /// <summary>
    /// Specifies the content for the ``access-control-allow-methods`` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AllowMethods {
      get { return allowMethods_; }
      set {
        allowMethods_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_headers" field.</summary>
    public const int AllowHeadersFieldNumber = 3;
    private string allowHeaders_ = "";
    /// <summary>
    /// Specifies the content for the ``access-control-allow-headers`` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AllowHeaders {
      get { return allowHeaders_; }
      set {
        allowHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "expose_headers" field.</summary>
    public const int ExposeHeadersFieldNumber = 4;
    private string exposeHeaders_ = "";
    /// <summary>
    /// Specifies the content for the ``access-control-expose-headers`` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExposeHeaders {
      get { return exposeHeaders_; }
      set {
        exposeHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_age" field.</summary>
    public const int MaxAgeFieldNumber = 5;
    private string maxAge_ = "";
    /// <summary>
    /// Specifies the content for the ``access-control-max-age`` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MaxAge {
      get { return maxAge_; }
      set {
        maxAge_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_credentials" field.</summary>
    public const int AllowCredentialsFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_allowCredentials_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? allowCredentials_;
    /// <summary>
    /// Specifies whether the resource allows credentials.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AllowCredentials {
      get { return allowCredentials_; }
      set {
        allowCredentials_ = value;
      }
    }


    /// <summary>Field number for the "filter_enabled" field.</summary>
    public const int FilterEnabledFieldNumber = 9;
    /// <summary>
    /// Specifies the % of requests for which the CORS filter is enabled.
    ///
    /// If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
    /// filter will be enabled for 100% of the requests.
    ///
    /// If :ref:`runtime_key &lt;envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
    /// specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RuntimeFractionalPercent FilterEnabled {
      get { return enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled ? (global::Envoy.Config.Core.V3.RuntimeFractionalPercent) enabledSpecifier_ : null; }
      set {
        enabledSpecifier_ = value;
        enabledSpecifierCase_ = value == null ? EnabledSpecifierOneofCase.None : EnabledSpecifierOneofCase.FilterEnabled;
      }
    }

    /// <summary>Field number for the "shadow_enabled" field.</summary>
    public const int ShadowEnabledFieldNumber = 10;
    private global::Envoy.Config.Core.V3.RuntimeFractionalPercent shadowEnabled_;
    /// <summary>
    /// Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
    /// enforced.
    ///
    /// This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
    /// fields have to explicitly disable the filter in order for this setting to take effect.
    ///
    /// If :ref:`runtime_key &lt;envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
    /// Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
    /// and track the request's ``Origin`` to determine if it's valid but will not enforce any policies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RuntimeFractionalPercent ShadowEnabled {
      get { return shadowEnabled_; }
      set {
        shadowEnabled_ = value;
      }
    }

    /// <summary>Field number for the "allow_private_network_access" field.</summary>
    public const int AllowPrivateNetworkAccessFieldNumber = 12;
    private static readonly pb::FieldCodec<bool?> _single_allowPrivateNetworkAccess_codec = pb::FieldCodec.ForStructWrapper<bool>(98);
    private bool? allowPrivateNetworkAccess_;
    /// <summary>
    /// Specify whether allow requests whose target server's IP address is more private than that from
    /// which the request initiator was fetched.
    ///
    /// More details refer to https://developer.chrome.com/blog/private-network-access-preflight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AllowPrivateNetworkAccess {
      get { return allowPrivateNetworkAccess_; }
      set {
        allowPrivateNetworkAccess_ = value;
      }
    }


    private object enabledSpecifier_;
    /// <summary>Enum of possible cases for the "enabled_specifier" oneof.</summary>
    public enum EnabledSpecifierOneofCase {
      None = 0,
      FilterEnabled = 9,
    }
    private EnabledSpecifierOneofCase enabledSpecifierCase_ = EnabledSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnabledSpecifierOneofCase EnabledSpecifierCase {
      get { return enabledSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnabledSpecifier() {
      enabledSpecifierCase_ = EnabledSpecifierOneofCase.None;
      enabledSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CorsPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CorsPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!allowOriginStringMatch_.Equals(other.allowOriginStringMatch_)) return false;
      if (AllowMethods != other.AllowMethods) return false;
      if (AllowHeaders != other.AllowHeaders) return false;
      if (ExposeHeaders != other.ExposeHeaders) return false;
      if (MaxAge != other.MaxAge) return false;
      if (AllowCredentials != other.AllowCredentials) return false;
      if (!object.Equals(FilterEnabled, other.FilterEnabled)) return false;
      if (!object.Equals(ShadowEnabled, other.ShadowEnabled)) return false;
      if (AllowPrivateNetworkAccess != other.AllowPrivateNetworkAccess) return false;
      if (EnabledSpecifierCase != other.EnabledSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= allowOriginStringMatch_.GetHashCode();
      if (AllowMethods.Length != 0) hash ^= AllowMethods.GetHashCode();
      if (AllowHeaders.Length != 0) hash ^= AllowHeaders.GetHashCode();
      if (ExposeHeaders.Length != 0) hash ^= ExposeHeaders.GetHashCode();
      if (MaxAge.Length != 0) hash ^= MaxAge.GetHashCode();
      if (allowCredentials_ != null) hash ^= AllowCredentials.GetHashCode();
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) hash ^= FilterEnabled.GetHashCode();
      if (shadowEnabled_ != null) hash ^= ShadowEnabled.GetHashCode();
      if (allowPrivateNetworkAccess_ != null) hash ^= AllowPrivateNetworkAccess.GetHashCode();
      hash ^= (int) enabledSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AllowMethods.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(MaxAge);
      }
      if (allowCredentials_ != null) {
        _single_allowCredentials_codec.WriteTagAndValue(output, AllowCredentials);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
        output.WriteRawTag(74);
        output.WriteMessage(FilterEnabled);
      }
      if (shadowEnabled_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShadowEnabled);
      }
      allowOriginStringMatch_.WriteTo(output, _repeated_allowOriginStringMatch_codec);
      if (allowPrivateNetworkAccess_ != null) {
        _single_allowPrivateNetworkAccess_codec.WriteTagAndValue(output, AllowPrivateNetworkAccess);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AllowMethods.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(MaxAge);
      }
      if (allowCredentials_ != null) {
        _single_allowCredentials_codec.WriteTagAndValue(ref output, AllowCredentials);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
        output.WriteRawTag(74);
        output.WriteMessage(FilterEnabled);
      }
      if (shadowEnabled_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShadowEnabled);
      }
      allowOriginStringMatch_.WriteTo(ref output, _repeated_allowOriginStringMatch_codec);
      if (allowPrivateNetworkAccess_ != null) {
        _single_allowPrivateNetworkAccess_codec.WriteTagAndValue(ref output, AllowPrivateNetworkAccess);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += allowOriginStringMatch_.CalculateSize(_repeated_allowOriginStringMatch_codec);
      if (AllowMethods.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MaxAge);
      }
      if (allowCredentials_ != null) {
        size += _single_allowCredentials_codec.CalculateSizeWithTag(AllowCredentials);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilterEnabled);
      }
      if (shadowEnabled_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ShadowEnabled);
      }
      if (allowPrivateNetworkAccess_ != null) {
        size += _single_allowPrivateNetworkAccess_codec.CalculateSizeWithTag(AllowPrivateNetworkAccess);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CorsPolicy other) {
      if (other == null) {
        return;
      }
      allowOriginStringMatch_.Add(other.allowOriginStringMatch_);
      if (other.AllowMethods.Length != 0) {
        AllowMethods = other.AllowMethods;
      }
      if (other.AllowHeaders.Length != 0) {
        AllowHeaders = other.AllowHeaders;
      }
      if (other.ExposeHeaders.Length != 0) {
        ExposeHeaders = other.ExposeHeaders;
      }
      if (other.MaxAge.Length != 0) {
        MaxAge = other.MaxAge;
      }
      if (other.allowCredentials_ != null) {
        if (allowCredentials_ == null || other.AllowCredentials != false) {
          AllowCredentials = other.AllowCredentials;
        }
      }
      if (other.shadowEnabled_ != null) {
        if (shadowEnabled_ == null) {
          ShadowEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
        }
        ShadowEnabled.MergeFrom(other.ShadowEnabled);
      }
      if (other.allowPrivateNetworkAccess_ != null) {
        if (allowPrivateNetworkAccess_ == null || other.AllowPrivateNetworkAccess != false) {
          AllowPrivateNetworkAccess = other.AllowPrivateNetworkAccess;
        }
      }
      switch (other.EnabledSpecifierCase) {
        case EnabledSpecifierOneofCase.FilterEnabled:
          if (FilterEnabled == null) {
            FilterEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
          }
          FilterEnabled.MergeFrom(other.FilterEnabled);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            AllowMethods = input.ReadString();
            break;
          }
          case 26: {
            AllowHeaders = input.ReadString();
            break;
          }
          case 34: {
            ExposeHeaders = input.ReadString();
            break;
          }
          case 42: {
            MaxAge = input.ReadString();
            break;
          }
          case 50: {
            bool? value = _single_allowCredentials_codec.Read(input);
            if (allowCredentials_ == null || value != false) {
              AllowCredentials = value;
            }
            break;
          }
          case 74: {
            global::Envoy.Config.Core.V3.RuntimeFractionalPercent subBuilder = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
              subBuilder.MergeFrom(FilterEnabled);
            }
            input.ReadMessage(subBuilder);
            FilterEnabled = subBuilder;
            break;
          }
          case 82: {
            if (shadowEnabled_ == null) {
              ShadowEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(ShadowEnabled);
            break;
          }
          case 90: {
            allowOriginStringMatch_.AddEntriesFrom(input, _repeated_allowOriginStringMatch_codec);
            break;
          }
          case 98: {
            bool? value = _single_allowPrivateNetworkAccess_codec.Read(input);
            if (allowPrivateNetworkAccess_ == null || value != false) {
              AllowPrivateNetworkAccess = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            AllowMethods = input.ReadString();
            break;
          }
          case 26: {
            AllowHeaders = input.ReadString();
            break;
          }
          case 34: {
            ExposeHeaders = input.ReadString();
            break;
          }
          case 42: {
            MaxAge = input.ReadString();
            break;
          }
          case 50: {
            bool? value = _single_allowCredentials_codec.Read(ref input);
            if (allowCredentials_ == null || value != false) {
              AllowCredentials = value;
            }
            break;
          }
          case 74: {
            global::Envoy.Config.Core.V3.RuntimeFractionalPercent subBuilder = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
              subBuilder.MergeFrom(FilterEnabled);
            }
            input.ReadMessage(subBuilder);
            FilterEnabled = subBuilder;
            break;
          }
          case 82: {
            if (shadowEnabled_ == null) {
              ShadowEnabled = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            input.ReadMessage(ShadowEnabled);
            break;
          }
          case 90: {
            allowOriginStringMatch_.AddEntriesFrom(ref input, _repeated_allowOriginStringMatch_codec);
            break;
          }
          case 98: {
            bool? value = _single_allowPrivateNetworkAccess_codec.Read(ref input);
            if (allowPrivateNetworkAccess_ == null || value != false) {
              AllowPrivateNetworkAccess = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 42]
  /// </summary>
  public sealed partial class RouteAction : pb::IMessage<RouteAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RouteAction> _parser = new pb::MessageParser<RouteAction>(() => new RouteAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RouteAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteAction(RouteAction other) : this() {
      clusterNotFoundResponseCode_ = other.clusterNotFoundResponseCode_;
      metadataMatch_ = other.metadataMatch_ != null ? other.metadataMatch_.Clone() : null;
      prefixRewrite_ = other.prefixRewrite_;
      regexRewrite_ = other.regexRewrite_ != null ? other.regexRewrite_.Clone() : null;
      pathRewritePolicy_ = other.pathRewritePolicy_ != null ? other.pathRewritePolicy_.Clone() : null;
      appendXForwardedHost_ = other.appendXForwardedHost_;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      earlyDataPolicy_ = other.earlyDataPolicy_ != null ? other.earlyDataPolicy_.Clone() : null;
      retryPolicy_ = other.retryPolicy_ != null ? other.retryPolicy_.Clone() : null;
      retryPolicyTypedConfig_ = other.retryPolicyTypedConfig_ != null ? other.retryPolicyTypedConfig_.Clone() : null;
      requestMirrorPolicies_ = other.requestMirrorPolicies_.Clone();
      priority_ = other.priority_;
      rateLimits_ = other.rateLimits_.Clone();
      IncludeVhRateLimits = other.IncludeVhRateLimits;
      hashPolicy_ = other.hashPolicy_.Clone();
      cors_ = other.cors_ != null ? other.cors_.Clone() : null;
      maxGrpcTimeout_ = other.maxGrpcTimeout_ != null ? other.maxGrpcTimeout_.Clone() : null;
      grpcTimeoutOffset_ = other.grpcTimeoutOffset_ != null ? other.grpcTimeoutOffset_.Clone() : null;
      upgradeConfigs_ = other.upgradeConfigs_.Clone();
      internalRedirectPolicy_ = other.internalRedirectPolicy_ != null ? other.internalRedirectPolicy_.Clone() : null;
      internalRedirectAction_ = other.internalRedirectAction_;
      MaxInternalRedirects = other.MaxInternalRedirects;
      hedgePolicy_ = other.hedgePolicy_ != null ? other.hedgePolicy_.Clone() : null;
      maxStreamDuration_ = other.maxStreamDuration_ != null ? other.maxStreamDuration_.Clone() : null;
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          WeightedClusters = other.WeightedClusters.Clone();
          break;
        case ClusterSpecifierOneofCase.ClusterSpecifierPlugin:
          ClusterSpecifierPlugin = other.ClusterSpecifierPlugin;
          break;
        case ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin:
          InlineClusterSpecifierPlugin = other.InlineClusterSpecifierPlugin.Clone();
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewriteLiteral:
          HostRewriteLiteral = other.HostRewriteLiteral;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.HostRewriteHeader:
          HostRewriteHeader = other.HostRewriteHeader;
          break;
        case HostRewriteSpecifierOneofCase.HostRewritePathRegex:
          HostRewritePathRegex = other.HostRewritePathRegex.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteAction Clone() {
      return new RouteAction(this);
    }

    /// <summary>Field number for the "cluster" field.</summary>
    public const int ClusterFieldNumber = 1;
    /// <summary>
    /// Indicates the upstream cluster to which the request should be routed
    /// to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Cluster {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.Cluster;
      }
    }

    /// <summary>Field number for the "cluster_header" field.</summary>
    public const int ClusterHeaderFieldNumber = 2;
    /// <summary>
    /// Envoy will determine the cluster to route to by reading the value of the
    /// HTTP header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist, Envoy will
    /// return a 404 response.
    ///
    /// .. attention::
    ///
    ///   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
    ///   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
    ///
    /// .. note::
    ///
    ///   If the header appears multiple times only the first value is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ClusterHeader {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.ClusterHeader;
      }
    }

    /// <summary>Field number for the "weighted_clusters" field.</summary>
    public const int WeightedClustersFieldNumber = 3;
    /// <summary>
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster. See
    /// :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split>`
    /// for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.WeightedCluster WeightedClusters {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters ? (global::Envoy.Config.Route.V3.WeightedCluster) clusterSpecifier_ : null; }
      set {
        clusterSpecifier_ = value;
        clusterSpecifierCase_ = value == null ? ClusterSpecifierOneofCase.None : ClusterSpecifierOneofCase.WeightedClusters;
      }
    }

    /// <summary>Field number for the "cluster_specifier_plugin" field.</summary>
    public const int ClusterSpecifierPluginFieldNumber = 37;
    /// <summary>
    /// Name of the cluster specifier plugin to use to determine the cluster for requests on this route.
    /// The cluster specifier plugin name must be defined in the associated
    /// :ref:`cluster specifier plugins &lt;envoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins>`
    /// in the :ref:`name &lt;envoy_v3_api_field_config.core.v3.TypedExtensionConfig.name>` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ClusterSpecifierPlugin {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterSpecifierPlugin ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.ClusterSpecifierPlugin;
      }
    }

    /// <summary>Field number for the "inline_cluster_specifier_plugin" field.</summary>
    public const int InlineClusterSpecifierPluginFieldNumber = 39;
    /// <summary>
    /// Custom cluster specifier plugin configuration to use to determine the cluster for requests
    /// on this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.ClusterSpecifierPlugin InlineClusterSpecifierPlugin {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin ? (global::Envoy.Config.Route.V3.ClusterSpecifierPlugin) clusterSpecifier_ : null; }
      set {
        clusterSpecifier_ = value;
        clusterSpecifierCase_ = value == null ? ClusterSpecifierOneofCase.None : ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin;
      }
    }

    /// <summary>Field number for the "cluster_not_found_response_code" field.</summary>
    public const int ClusterNotFoundResponseCodeFieldNumber = 20;
    private global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode clusterNotFoundResponseCode_ = global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable;
    /// <summary>
    /// The HTTP status code to use when configured cluster is not found.
    /// The default response code is 503 Service Unavailable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode ClusterNotFoundResponseCode {
      get { return clusterNotFoundResponseCode_; }
      set {
        clusterNotFoundResponseCode_ = value;
      }
    }

    /// <summary>Field number for the "metadata_match" field.</summary>
    public const int MetadataMatchFieldNumber = 4;
    private global::Envoy.Config.Core.V3.Metadata metadataMatch_;
    /// <summary>
    /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
    /// in the upstream cluster with metadata matching what's set in this field will be considered
    /// for load balancing. If using :ref:`weighted_clusters
    /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
    /// provided there taking precedence. The filter name should be specified as ``envoy.lb``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.Metadata MetadataMatch {
      get { return metadataMatch_; }
      set {
        metadataMatch_ = value;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    private string prefixRewrite_ = "";
    /// <summary>
    /// Indicates that during forwarding, the matched prefix (or path) should be
    /// swapped with this value. This option allows application URLs to be rooted
    /// at a different path from those exposed at the reverse proxy layer. The router filter will
    /// place the original path before rewrite into the :ref:`x-envoy-original-path
    /// &lt;config_http_filters_router_x-envoy-original-path>` header.
    ///
    /// Only one of :ref:`regex_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`
    /// :ref:`path_rewrite_policy &lt;envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`,
    /// or :ref:`prefix_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>` may be specified.
    ///
    /// .. attention::
    ///
    ///   Pay careful attention to the use of trailing slashes in the
    ///   :ref:`route's match &lt;envoy_v3_api_field_config.route.v3.Route.match>` prefix value.
    ///   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
    ///   rewriting ``/prefix`` to ``/`` and ``/prefix/etc`` to ``/etc`` cannot be done in a single
    ///   :ref:`Route &lt;envoy_v3_api_msg_config.route.v3.Route>`, as shown by the below config entries:
    ///
    ///   .. code-block:: yaml
    ///
    ///     - match:
    ///         prefix: "/prefix/"
    ///       route:
    ///         prefix_rewrite: "/"
    ///     - match:
    ///         prefix: "/prefix"
    ///       route:
    ///         prefix_rewrite: "/"
    ///
    ///   Having above entries in the config, requests to ``/prefix`` will be stripped to ``/``, while
    ///   requests to ``/prefix/etc`` will be stripped to ``/etc``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PrefixRewrite {
      get { return prefixRewrite_; }
      set {
        prefixRewrite_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "regex_rewrite" field.</summary>
    public const int RegexRewriteFieldNumber = 32;
    private global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute regexRewrite_;
    /// <summary>
    /// Indicates that during forwarding, portions of the path that match the
    /// pattern should be rewritten, even allowing the substitution of capture
    /// groups from the pattern into the new path as specified by the rewrite
    /// substitution string. This is useful to allow application paths to be
    /// rewritten in a way that is aware of segments with variable content like
    /// identifiers. The router filter will place the original path as it was
    /// before the rewrite into the :ref:`x-envoy-original-path
    /// &lt;config_http_filters_router_x-envoy-original-path>` header.
    ///
    /// Only one of :ref:`regex_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`,
    /// :ref:`prefix_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`, or
    /// :ref:`path_rewrite_policy &lt;envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`]
    /// may be specified.
    ///
    /// Examples using Google's `RE2 &lt;https://github.com/google/re2>`_ engine:
    ///
    /// * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
    ///   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
    ///   into ``/v1/api/instance/foo``.
    ///
    /// * The pattern ``one`` paired with a substitution string of ``two`` would
    ///   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
    ///
    /// * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
    ///   ``\1two\2`` would replace only the first occurrence of ``one``,
    ///   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
    ///
    /// * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
    ///   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
    ///   ``/aaa/yyy/bbb``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute RegexRewrite {
      get { return regexRewrite_; }
      set {
        regexRewrite_ = value;
      }
    }

    /// <summary>Field number for the "path_rewrite_policy" field.</summary>
    public const int PathRewritePolicyFieldNumber = 41;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig pathRewritePolicy_;
    /// <summary>
    /// [#extension-category: envoy.path.rewrite]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig PathRewritePolicy {
      get { return pathRewritePolicy_; }
      set {
        pathRewritePolicy_ = value;
      }
    }

    /// <summary>Field number for the "host_rewrite_literal" field.</summary>
    public const int HostRewriteLiteralFieldNumber = 6;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// this value. Using this option will append the
    /// :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    /// :ref:`append_x_forwarded_host &lt;envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    /// is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostRewriteLiteral {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral ? (string) hostRewriteSpecifier_ : ""; }
      set {
        hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.HostRewriteLiteral;
      }
    }

    /// <summary>Field number for the "auto_host_rewrite" field.</summary>
    public const int AutoHostRewriteFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _oneof_autoHostRewrite_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// the hostname of the upstream host chosen by the cluster manager. This
    /// option is applicable only when the destination cluster for a route is of
    /// type ``strict_dns`` or ``logical_dns``. Setting this to true with other cluster types
    /// has no effect. Using this option will append the
    /// :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    /// :ref:`append_x_forwarded_host &lt;envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    /// is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? AutoHostRewrite {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite ? (bool?) hostRewriteSpecifier_ : (bool?) null; }
      set {
        hostRewriteSpecifier_ = value;
        hostRewriteSpecifierCase_ = value == null ? HostRewriteSpecifierOneofCase.None : HostRewriteSpecifierOneofCase.AutoHostRewrite;
      }
    }

    /// <summary>Field number for the "host_rewrite_header" field.</summary>
    public const int HostRewriteHeaderFieldNumber = 29;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with the content of given
    /// downstream or :ref:`custom &lt;config_http_conn_man_headers_custom_request_headers>` header.
    /// If header value is empty, host header is left intact. Using this option will append the
    /// :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    /// :ref:`append_x_forwarded_host &lt;envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    /// is set.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the potential security implications of using this option. Provided header
    ///   must come from trusted source.
    ///
    /// .. note::
    ///
    ///   If the header appears multiple times only the first value is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostRewriteHeader {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteHeader ? (string) hostRewriteSpecifier_ : ""; }
      set {
        hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.HostRewriteHeader;
      }
    }

    /// <summary>Field number for the "host_rewrite_path_regex" field.</summary>
    public const int HostRewritePathRegexFieldNumber = 35;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// the result of the regex substitution executed on path value with query and fragment removed.
    /// This is useful for transitioning variable content between path segment and subdomain.
    /// Using this option will append the
    /// :ref:`config_http_conn_man_headers_x-forwarded-host` header if
    /// :ref:`append_x_forwarded_host &lt;envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
    /// is set.
    ///
    /// For example with the following config:
    ///
    ///   .. code-block:: yaml
    ///
    ///     host_rewrite_path_regex:
    ///       pattern:
    ///         google_re2: {}
    ///         regex: "^/(.+)/.+$"
    ///       substitution: \1
    ///
    /// Would rewrite the host header to ``envoyproxy.io`` given the path ``/envoyproxy.io/some/path``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute HostRewritePathRegex {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex ? (global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute) hostRewriteSpecifier_ : null; }
      set {
        hostRewriteSpecifier_ = value;
        hostRewriteSpecifierCase_ = value == null ? HostRewriteSpecifierOneofCase.None : HostRewriteSpecifierOneofCase.HostRewritePathRegex;
      }
    }

    /// <summary>Field number for the "append_x_forwarded_host" field.</summary>
    public const int AppendXForwardedHostFieldNumber = 38;
    private bool appendXForwardedHost_;
    /// <summary>
    /// If set, then a host rewrite action (one of
    /// :ref:`host_rewrite_literal &lt;envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>`,
    /// :ref:`auto_host_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`,
    /// :ref:`host_rewrite_header &lt;envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_header>`, or
    /// :ref:`host_rewrite_path_regex &lt;envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex>`)
    /// causes the original value of the host header, if any, to be appended to the
    /// :ref:`config_http_conn_man_headers_x-forwarded-host` HTTP header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AppendXForwardedHost {
      get { return appendXForwardedHost_; }
      set {
        appendXForwardedHost_ = value;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
    /// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
    /// processed and when the upstream response has been completely processed. A value of 0 will
    /// disable the route's timeout.
    ///
    /// .. note::
    ///
    ///   This timeout includes all retries. See also
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
    ///   :ref:`retry overview &lt;arch_overview_http_routing_retry>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 24;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
    /// although the connection manager wide :ref:`stream_idle_timeout
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
    /// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
    /// connection manager stream idle timeout is configured.
    ///
    /// The idle timeout is distinct to :ref:`timeout
    /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
    /// on the upstream response time; :ref:`idle_timeout
    /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
    /// of time the request's stream may be idle.
    ///
    /// After header decoding, the idle timeout will apply on downstream and
    /// upstream request events. Each time an encode/decode event for headers or
    /// data is processed for the stream, the timer will be reset. If the timeout
    /// fires, the stream is terminated with a 408 Request Timeout error code if no
    /// upstream response header has been received, otherwise a stream reset
    /// occurs.
    ///
    /// If the :ref:`overload action &lt;config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
    /// is configured, this timeout is scaled according to the value for
    /// :ref:`HTTP_DOWNSTREAM_STREAM_IDLE &lt;envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "early_data_policy" field.</summary>
    public const int EarlyDataPolicyFieldNumber = 40;
    private global::Envoy.Config.Core.V3.TypedExtensionConfig earlyDataPolicy_;
    /// <summary>
    /// Specifies how to send request over TLS early data.
    /// If absent, allows `safe HTTP requests &lt;https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ to be sent on early data.
    /// [#extension-category: envoy.route.early_data_policy]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.TypedExtensionConfig EarlyDataPolicy {
      get { return earlyDataPolicy_; }
      set {
        earlyDataPolicy_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 9;
    private global::Envoy.Config.Route.V3.RetryPolicy retryPolicy_;
    /// <summary>
    /// Indicates that the route has a retry policy. Note that if this is set,
    /// it'll take precedence over the virtual host level retry policy entirely
    /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RetryPolicy RetryPolicy {
      get { return retryPolicy_; }
      set {
        retryPolicy_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy_typed_config" field.</summary>
    public const int RetryPolicyTypedConfigFieldNumber = 33;
    private global::Google.Protobuf.WellKnownTypes.Any retryPolicyTypedConfig_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// Specifies the configuration for retry policy extension. Note that if this is set, it'll take
    /// precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
    /// most internal one becomes the enforced policy). :ref:`Retry policy &lt;envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>`
    /// should not be set if this field is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any RetryPolicyTypedConfig {
      get { return retryPolicyTypedConfig_; }
      set {
        retryPolicyTypedConfig_ = value;
      }
    }

    /// <summary>Field number for the "request_mirror_policies" field.</summary>
    public const int RequestMirrorPoliciesFieldNumber = 30;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> _repeated_requestMirrorPolicies_codec
        = pb::FieldCodec.ForMessage(242, global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> requestMirrorPolicies_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy>();
    /// <summary>
    /// Specify a set of route request mirroring policies.
    /// It takes precedence over the virtual host and route config mirror policy entirely.
    /// That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.RequestMirrorPolicy> RequestMirrorPolicies {
      get { return requestMirrorPolicies_; }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 11;
    private global::Envoy.Config.Core.V3.RoutingPriority priority_ = global::Envoy.Config.Core.V3.RoutingPriority.Default;
    /// <summary>
    /// Optionally specifies the :ref:`routing priority &lt;arch_overview_http_routing_priority>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.RoutingPriority Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Route.V3.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that could be applied to the
    /// route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "include_vh_rate_limits" field.</summary>
    public const int IncludeVhRateLimitsFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_includeVhRateLimits_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? includeVhRateLimits_;
    /// <summary>
    /// Specifies if the rate limit filter should include the virtual host rate
    /// limits. By default, if the route configured rate limits, the virtual host
    /// :ref:`rate_limits &lt;envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
    /// request.
    ///
    /// This field is deprecated. Please use :ref:`vh_rate_limits &lt;envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? IncludeVhRateLimits {
      get { return includeVhRateLimits_; }
      set {
        includeVhRateLimits_ = value;
      }
    }


    /// <summary>Field number for the "hash_policy" field.</summary>
    public const int HashPolicyFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy> _repeated_hashPolicy_codec
        = pb::FieldCodec.ForMessage(122, global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy> hashPolicy_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy>();
    /// <summary>
    /// Specifies a list of hash policies to use for ring hash load balancing. Each
    /// hash policy is evaluated individually and the combined result is used to
    /// route the request. The method of combination is deterministic such that
    /// identical lists of hash policies will produce the same hash. Since a hash
    /// policy examines specific parts of a request, it can fail to produce a hash
    /// (i.e. if the hashed header is not present). If (and only if) all configured
    /// hash policies fail to generate a hash, no hash will be produced for
    /// the route. In this case, the behavior is the same as if no hash policies
    /// were specified (i.e. the ring hash load balancer will choose a random
    /// backend). If a hash policy has the "terminal" attribute set to true, and
    /// there is already a hash generated, the hash is returned immediately,
    /// ignoring the rest of the hash policy list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy> HashPolicy {
      get { return hashPolicy_; }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 17;
    private global::Envoy.Config.Route.V3.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the route has a CORS policy. This field is ignored if related cors policy is
    /// found in the :ref:`Route.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
    /// :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`.
    ///
    /// .. attention::
    ///
    ///   This option has been deprecated. Please use
    ///   :ref:`Route.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
    ///   :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
    ///   to configure the CORS HTTP filter.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "max_grpc_timeout" field.</summary>
    public const int MaxGrpcTimeoutFieldNumber = 23;
    private global::Google.Protobuf.WellKnownTypes.Duration maxGrpcTimeout_;
    /// <summary>
    /// Deprecated by :ref:`grpc_timeout_header_max &lt;envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`
    /// If present, and the request is a gRPC request, use the
    /// `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
    /// or its default value (infinity) instead of
    /// :ref:`timeout &lt;envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
    /// to the maximum value specified here. If configured as 0, the maximum allowed timeout for
    /// gRPC requests is infinity. If not configured at all, the ``grpc-timeout`` header is not used
    /// and gRPC requests time out like any other requests using
    /// :ref:`timeout &lt;envoy_v3_api_field_config.route.v3.RouteAction.timeout>` or its default.
    /// This can be used to prevent unexpected upstream request timeouts due to potentially long
    /// time gaps between gRPC request and response in gRPC streaming mode.
    ///
    /// .. note::
    ///
    ///    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
    ///    precedence over `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
    ///    both are present. See also
    ///    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
    ///    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
    ///    :ref:`retry overview &lt;arch_overview_http_routing_retry>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxGrpcTimeout {
      get { return maxGrpcTimeout_; }
      set {
        maxGrpcTimeout_ = value;
      }
    }

    /// <summary>Field number for the "grpc_timeout_offset" field.</summary>
    public const int GrpcTimeoutOffsetFieldNumber = 28;
    private global::Google.Protobuf.WellKnownTypes.Duration grpcTimeoutOffset_;
    /// <summary>
    /// Deprecated by :ref:`grpc_timeout_header_offset &lt;envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
    /// If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting
    /// the provided duration from the header. This is useful in allowing Envoy to set its global
    /// timeout to be less than that of the deadline imposed by the calling client, which makes it more
    /// likely that Envoy will handle the timeout instead of having the call canceled by the client.
    /// The offset will only be applied if the provided grpc_timeout is greater than the offset. This
    /// ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
    /// infinity).
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration GrpcTimeoutOffset {
      get { return grpcTimeoutOffset_; }
      set {
        grpcTimeoutOffset_ = value;
      }
    }

    /// <summary>Field number for the "upgrade_configs" field.</summary>
    public const int UpgradeConfigsFieldNumber = 25;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig> _repeated_upgradeConfigs_codec
        = pb::FieldCodec.ForMessage(202, global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig> upgradeConfigs_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig> UpgradeConfigs {
      get { return upgradeConfigs_; }
    }

    /// <summary>Field number for the "internal_redirect_policy" field.</summary>
    public const int InternalRedirectPolicyFieldNumber = 34;
    private global::Envoy.Config.Route.V3.InternalRedirectPolicy internalRedirectPolicy_;
    /// <summary>
    /// If present, Envoy will try to follow an upstream redirect response instead of proxying the
    /// response back to the downstream. An upstream redirect response is defined
    /// by :ref:`redirect_response_codes
    /// &lt;envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.InternalRedirectPolicy InternalRedirectPolicy {
      get { return internalRedirectPolicy_; }
      set {
        internalRedirectPolicy_ = value;
      }
    }

    /// <summary>Field number for the "internal_redirect_action" field.</summary>
    public const int InternalRedirectActionFieldNumber = 26;
    private global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction internalRedirectAction_ = global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect;
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction InternalRedirectAction {
      get { return internalRedirectAction_; }
      set {
        internalRedirectAction_ = value;
      }
    }

    /// <summary>Field number for the "max_internal_redirects" field.</summary>
    public const int MaxInternalRedirectsFieldNumber = 31;
    private static readonly pb::FieldCodec<uint?> _single_maxInternalRedirects_codec = pb::FieldCodec.ForStructWrapper<uint>(250);
    private uint? maxInternalRedirects_;
    /// <summary>
    /// An internal redirect is handled, iff the number of previous internal redirects that a
    /// downstream request has encountered is lower than this value, and
    /// :ref:`internal_redirect_action &lt;envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
    /// is set to :ref:`HANDLE_INTERNAL_REDIRECT
    /// &lt;envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
    /// In the case where a downstream request is bounced among multiple routes by internal redirect,
    /// the first route that hits this threshold, or has
    /// :ref:`internal_redirect_action &lt;envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
    /// set to
    /// :ref:`PASS_THROUGH_INTERNAL_REDIRECT
    /// &lt;envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
    /// will pass the redirect back to downstream.
    ///
    /// If not specified, at most one redirect will be followed.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInternalRedirects {
      get { return maxInternalRedirects_; }
      set {
        maxInternalRedirects_ = value;
      }
    }


    /// <summary>Field number for the "hedge_policy" field.</summary>
    public const int HedgePolicyFieldNumber = 27;
    private global::Envoy.Config.Route.V3.HedgePolicy hedgePolicy_;
    /// <summary>
    /// Indicates that the route has a hedge policy. Note that if this is set,
    /// it'll take precedence over the virtual host level hedge policy entirely
    /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.HedgePolicy HedgePolicy {
      get { return hedgePolicy_; }
      set {
        hedgePolicy_ = value;
      }
    }

    /// <summary>Field number for the "max_stream_duration" field.</summary>
    public const int MaxStreamDurationFieldNumber = 36;
    private global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration maxStreamDuration_;
    /// <summary>
    /// Specifies the maximum stream duration for this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration MaxStreamDuration {
      get { return maxStreamDuration_; }
      set {
        maxStreamDuration_ = value;
      }
    }

    private object clusterSpecifier_;
    /// <summary>Enum of possible cases for the "cluster_specifier" oneof.</summary>
    public enum ClusterSpecifierOneofCase {
      None = 0,
      Cluster = 1,
      ClusterHeader = 2,
      WeightedClusters = 3,
      ClusterSpecifierPlugin = 37,
      InlineClusterSpecifierPlugin = 39,
    }
    private ClusterSpecifierOneofCase clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClusterSpecifierOneofCase ClusterSpecifierCase {
      get { return clusterSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClusterSpecifier() {
      clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
      clusterSpecifier_ = null;
    }

    private object hostRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "host_rewrite_specifier" oneof.</summary>
    public enum HostRewriteSpecifierOneofCase {
      None = 0,
      HostRewriteLiteral = 6,
      AutoHostRewrite = 7,
      HostRewriteHeader = 29,
      HostRewritePathRegex = 35,
    }
    private HostRewriteSpecifierOneofCase hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostRewriteSpecifierOneofCase HostRewriteSpecifierCase {
      get { return hostRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostRewriteSpecifier() {
      hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
      hostRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RouteAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RouteAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Cluster != other.Cluster) return false;
      if (ClusterHeader != other.ClusterHeader) return false;
      if (!object.Equals(WeightedClusters, other.WeightedClusters)) return false;
      if (ClusterSpecifierPlugin != other.ClusterSpecifierPlugin) return false;
      if (!object.Equals(InlineClusterSpecifierPlugin, other.InlineClusterSpecifierPlugin)) return false;
      if (ClusterNotFoundResponseCode != other.ClusterNotFoundResponseCode) return false;
      if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (!object.Equals(RegexRewrite, other.RegexRewrite)) return false;
      if (!object.Equals(PathRewritePolicy, other.PathRewritePolicy)) return false;
      if (HostRewriteLiteral != other.HostRewriteLiteral) return false;
      if (AutoHostRewrite != other.AutoHostRewrite) return false;
      if (HostRewriteHeader != other.HostRewriteHeader) return false;
      if (!object.Equals(HostRewritePathRegex, other.HostRewritePathRegex)) return false;
      if (AppendXForwardedHost != other.AppendXForwardedHost) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(EarlyDataPolicy, other.EarlyDataPolicy)) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(RetryPolicyTypedConfig, other.RetryPolicyTypedConfig)) return false;
      if(!requestMirrorPolicies_.Equals(other.requestMirrorPolicies_)) return false;
      if (Priority != other.Priority) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if (IncludeVhRateLimits != other.IncludeVhRateLimits) return false;
      if(!hashPolicy_.Equals(other.hashPolicy_)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!object.Equals(MaxGrpcTimeout, other.MaxGrpcTimeout)) return false;
      if (!object.Equals(GrpcTimeoutOffset, other.GrpcTimeoutOffset)) return false;
      if(!upgradeConfigs_.Equals(other.upgradeConfigs_)) return false;
      if (!object.Equals(InternalRedirectPolicy, other.InternalRedirectPolicy)) return false;
      if (InternalRedirectAction != other.InternalRedirectAction) return false;
      if (MaxInternalRedirects != other.MaxInternalRedirects) return false;
      if (!object.Equals(HedgePolicy, other.HedgePolicy)) return false;
      if (!object.Equals(MaxStreamDuration, other.MaxStreamDuration)) return false;
      if (ClusterSpecifierCase != other.ClusterSpecifierCase) return false;
      if (HostRewriteSpecifierCase != other.HostRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) hash ^= Cluster.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) hash ^= ClusterHeader.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) hash ^= WeightedClusters.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterSpecifierPlugin) hash ^= ClusterSpecifierPlugin.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) hash ^= InlineClusterSpecifierPlugin.GetHashCode();
      if (ClusterNotFoundResponseCode != global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) hash ^= ClusterNotFoundResponseCode.GetHashCode();
      if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
      if (PrefixRewrite.Length != 0) hash ^= PrefixRewrite.GetHashCode();
      if (regexRewrite_ != null) hash ^= RegexRewrite.GetHashCode();
      if (pathRewritePolicy_ != null) hash ^= PathRewritePolicy.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) hash ^= HostRewriteLiteral.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) hash ^= AutoHostRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteHeader) hash ^= HostRewriteHeader.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) hash ^= HostRewritePathRegex.GetHashCode();
      if (AppendXForwardedHost != false) hash ^= AppendXForwardedHost.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (earlyDataPolicy_ != null) hash ^= EarlyDataPolicy.GetHashCode();
      if (retryPolicy_ != null) hash ^= RetryPolicy.GetHashCode();
      if (retryPolicyTypedConfig_ != null) hash ^= RetryPolicyTypedConfig.GetHashCode();
      hash ^= requestMirrorPolicies_.GetHashCode();
      if (Priority != global::Envoy.Config.Core.V3.RoutingPriority.Default) hash ^= Priority.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      if (includeVhRateLimits_ != null) hash ^= IncludeVhRateLimits.GetHashCode();
      hash ^= hashPolicy_.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      if (maxGrpcTimeout_ != null) hash ^= MaxGrpcTimeout.GetHashCode();
      if (grpcTimeoutOffset_ != null) hash ^= GrpcTimeoutOffset.GetHashCode();
      hash ^= upgradeConfigs_.GetHashCode();
      if (internalRedirectPolicy_ != null) hash ^= InternalRedirectPolicy.GetHashCode();
      if (InternalRedirectAction != global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) hash ^= InternalRedirectAction.GetHashCode();
      if (maxInternalRedirects_ != null) hash ^= MaxInternalRedirects.GetHashCode();
      if (hedgePolicy_ != null) hash ^= HedgePolicy.GetHashCode();
      if (maxStreamDuration_ != null) hash ^= MaxStreamDuration.GetHashCode();
      hash ^= (int) clusterSpecifierCase_;
      hash ^= (int) hostRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        output.WriteRawTag(10);
        output.WriteString(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        output.WriteRawTag(18);
        output.WriteString(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        output.WriteRawTag(26);
        output.WriteMessage(WeightedClusters);
      }
      if (metadataMatch_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
        output.WriteRawTag(50);
        output.WriteString(HostRewriteLiteral);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        _oneof_autoHostRewrite_codec.WriteTagAndValue(output, (bool?) hostRewriteSpecifier_);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      if (retryPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RetryPolicy);
      }
      if (Priority != global::Envoy.Config.Core.V3.RoutingPriority.Default) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Priority);
      }
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        _single_includeVhRateLimits_codec.WriteTagAndValue(output, IncludeVhRateLimits);
      }
      hashPolicy_.WriteTo(output, _repeated_hashPolicy_codec);
      if (cors_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Cors);
      }
      if (ClusterNotFoundResponseCode != global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) ClusterNotFoundResponseCode);
      }
      if (maxGrpcTimeout_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(MaxGrpcTimeout);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(IdleTimeout);
      }
      upgradeConfigs_.WriteTo(output, _repeated_upgradeConfigs_codec);
      if (InternalRedirectAction != global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) InternalRedirectAction);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (grpcTimeoutOffset_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(GrpcTimeoutOffset);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteHeader) {
        output.WriteRawTag(234, 1);
        output.WriteString(HostRewriteHeader);
      }
      requestMirrorPolicies_.WriteTo(output, _repeated_requestMirrorPolicies_codec);
      if (maxInternalRedirects_ != null) {
        _single_maxInternalRedirects_codec.WriteTagAndValue(output, MaxInternalRedirects);
      }
      if (regexRewrite_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(RegexRewrite);
      }
      if (retryPolicyTypedConfig_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(RetryPolicyTypedConfig);
      }
      if (internalRedirectPolicy_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(InternalRedirectPolicy);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) {
        output.WriteRawTag(154, 2);
        output.WriteMessage(HostRewritePathRegex);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(162, 2);
        output.WriteMessage(MaxStreamDuration);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterSpecifierPlugin) {
        output.WriteRawTag(170, 2);
        output.WriteString(ClusterSpecifierPlugin);
      }
      if (AppendXForwardedHost != false) {
        output.WriteRawTag(176, 2);
        output.WriteBool(AppendXForwardedHost);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) {
        output.WriteRawTag(186, 2);
        output.WriteMessage(InlineClusterSpecifierPlugin);
      }
      if (earlyDataPolicy_ != null) {
        output.WriteRawTag(194, 2);
        output.WriteMessage(EarlyDataPolicy);
      }
      if (pathRewritePolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(PathRewritePolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        output.WriteRawTag(10);
        output.WriteString(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        output.WriteRawTag(18);
        output.WriteString(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        output.WriteRawTag(26);
        output.WriteMessage(WeightedClusters);
      }
      if (metadataMatch_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
        output.WriteRawTag(50);
        output.WriteString(HostRewriteLiteral);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        _oneof_autoHostRewrite_codec.WriteTagAndValue(ref output, (bool?) hostRewriteSpecifier_);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      if (retryPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RetryPolicy);
      }
      if (Priority != global::Envoy.Config.Core.V3.RoutingPriority.Default) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Priority);
      }
      rateLimits_.WriteTo(ref output, _repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        _single_includeVhRateLimits_codec.WriteTagAndValue(ref output, IncludeVhRateLimits);
      }
      hashPolicy_.WriteTo(ref output, _repeated_hashPolicy_codec);
      if (cors_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Cors);
      }
      if (ClusterNotFoundResponseCode != global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) ClusterNotFoundResponseCode);
      }
      if (maxGrpcTimeout_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(MaxGrpcTimeout);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(IdleTimeout);
      }
      upgradeConfigs_.WriteTo(ref output, _repeated_upgradeConfigs_codec);
      if (InternalRedirectAction != global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) InternalRedirectAction);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (grpcTimeoutOffset_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(GrpcTimeoutOffset);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteHeader) {
        output.WriteRawTag(234, 1);
        output.WriteString(HostRewriteHeader);
      }
      requestMirrorPolicies_.WriteTo(ref output, _repeated_requestMirrorPolicies_codec);
      if (maxInternalRedirects_ != null) {
        _single_maxInternalRedirects_codec.WriteTagAndValue(ref output, MaxInternalRedirects);
      }
      if (regexRewrite_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(RegexRewrite);
      }
      if (retryPolicyTypedConfig_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(RetryPolicyTypedConfig);
      }
      if (internalRedirectPolicy_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(InternalRedirectPolicy);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) {
        output.WriteRawTag(154, 2);
        output.WriteMessage(HostRewritePathRegex);
      }
      if (maxStreamDuration_ != null) {
        output.WriteRawTag(162, 2);
        output.WriteMessage(MaxStreamDuration);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterSpecifierPlugin) {
        output.WriteRawTag(170, 2);
        output.WriteString(ClusterSpecifierPlugin);
      }
      if (AppendXForwardedHost != false) {
        output.WriteRawTag(176, 2);
        output.WriteBool(AppendXForwardedHost);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) {
        output.WriteRawTag(186, 2);
        output.WriteMessage(InlineClusterSpecifierPlugin);
      }
      if (earlyDataPolicy_ != null) {
        output.WriteRawTag(194, 2);
        output.WriteMessage(EarlyDataPolicy);
      }
      if (pathRewritePolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(PathRewritePolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedClusters);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterSpecifierPlugin) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ClusterSpecifierPlugin);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InlineClusterSpecifierPlugin);
      }
      if (ClusterNotFoundResponseCode != global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ClusterNotFoundResponseCode);
      }
      if (metadataMatch_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (regexRewrite_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RegexRewrite);
      }
      if (pathRewritePolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PathRewritePolicy);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteLiteral) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRewriteLiteral);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        size += _oneof_autoHostRewrite_codec.CalculateSizeWithTag(AutoHostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewriteHeader) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(HostRewriteHeader);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HostRewritePathRegex);
      }
      if (AppendXForwardedHost != false) {
        size += 2 + 1;
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (idleTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (earlyDataPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EarlyDataPolicy);
      }
      if (retryPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (retryPolicyTypedConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicyTypedConfig);
      }
      size += requestMirrorPolicies_.CalculateSize(_repeated_requestMirrorPolicies_codec);
      if (Priority != global::Envoy.Config.Core.V3.RoutingPriority.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Priority);
      }
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        size += _single_includeVhRateLimits_codec.CalculateSizeWithTag(IncludeVhRateLimits);
      }
      size += hashPolicy_.CalculateSize(_repeated_hashPolicy_codec);
      if (cors_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      if (maxGrpcTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaxGrpcTimeout);
      }
      if (grpcTimeoutOffset_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(GrpcTimeoutOffset);
      }
      size += upgradeConfigs_.CalculateSize(_repeated_upgradeConfigs_codec);
      if (internalRedirectPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InternalRedirectPolicy);
      }
      if (InternalRedirectAction != global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) InternalRedirectAction);
      }
      if (maxInternalRedirects_ != null) {
        size += _single_maxInternalRedirects_codec.CalculateSizeWithTag(MaxInternalRedirects);
      }
      if (hedgePolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HedgePolicy);
      }
      if (maxStreamDuration_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaxStreamDuration);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RouteAction other) {
      if (other == null) {
        return;
      }
      if (other.ClusterNotFoundResponseCode != global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        ClusterNotFoundResponseCode = other.ClusterNotFoundResponseCode;
      }
      if (other.metadataMatch_ != null) {
        if (metadataMatch_ == null) {
          MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
        }
        MetadataMatch.MergeFrom(other.MetadataMatch);
      }
      if (other.PrefixRewrite.Length != 0) {
        PrefixRewrite = other.PrefixRewrite;
      }
      if (other.regexRewrite_ != null) {
        if (regexRewrite_ == null) {
          RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
        }
        RegexRewrite.MergeFrom(other.RegexRewrite);
      }
      if (other.pathRewritePolicy_ != null) {
        if (pathRewritePolicy_ == null) {
          PathRewritePolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        PathRewritePolicy.MergeFrom(other.PathRewritePolicy);
      }
      if (other.AppendXForwardedHost != false) {
        AppendXForwardedHost = other.AppendXForwardedHost;
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.earlyDataPolicy_ != null) {
        if (earlyDataPolicy_ == null) {
          EarlyDataPolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
        }
        EarlyDataPolicy.MergeFrom(other.EarlyDataPolicy);
      }
      if (other.retryPolicy_ != null) {
        if (retryPolicy_ == null) {
          RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
        }
        RetryPolicy.MergeFrom(other.RetryPolicy);
      }
      if (other.retryPolicyTypedConfig_ != null) {
        if (retryPolicyTypedConfig_ == null) {
          RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        RetryPolicyTypedConfig.MergeFrom(other.RetryPolicyTypedConfig);
      }
      requestMirrorPolicies_.Add(other.requestMirrorPolicies_);
      if (other.Priority != global::Envoy.Config.Core.V3.RoutingPriority.Default) {
        Priority = other.Priority;
      }
      rateLimits_.Add(other.rateLimits_);
      if (other.includeVhRateLimits_ != null) {
        if (includeVhRateLimits_ == null || other.IncludeVhRateLimits != false) {
          IncludeVhRateLimits = other.IncludeVhRateLimits;
        }
      }
      hashPolicy_.Add(other.hashPolicy_);
      if (other.cors_ != null) {
        if (cors_ == null) {
          Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      if (other.maxGrpcTimeout_ != null) {
        if (maxGrpcTimeout_ == null) {
          MaxGrpcTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxGrpcTimeout.MergeFrom(other.MaxGrpcTimeout);
      }
      if (other.grpcTimeoutOffset_ != null) {
        if (grpcTimeoutOffset_ == null) {
          GrpcTimeoutOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        GrpcTimeoutOffset.MergeFrom(other.GrpcTimeoutOffset);
      }
      upgradeConfigs_.Add(other.upgradeConfigs_);
      if (other.internalRedirectPolicy_ != null) {
        if (internalRedirectPolicy_ == null) {
          InternalRedirectPolicy = new global::Envoy.Config.Route.V3.InternalRedirectPolicy();
        }
        InternalRedirectPolicy.MergeFrom(other.InternalRedirectPolicy);
      }
      if (other.InternalRedirectAction != global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        InternalRedirectAction = other.InternalRedirectAction;
      }
      if (other.maxInternalRedirects_ != null) {
        if (maxInternalRedirects_ == null || other.MaxInternalRedirects != 0) {
          MaxInternalRedirects = other.MaxInternalRedirects;
        }
      }
      if (other.hedgePolicy_ != null) {
        if (hedgePolicy_ == null) {
          HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
        }
        HedgePolicy.MergeFrom(other.HedgePolicy);
      }
      if (other.maxStreamDuration_ != null) {
        if (maxStreamDuration_ == null) {
          MaxStreamDuration = new global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration();
        }
        MaxStreamDuration.MergeFrom(other.MaxStreamDuration);
      }
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          if (WeightedClusters == null) {
            WeightedClusters = new global::Envoy.Config.Route.V3.WeightedCluster();
          }
          WeightedClusters.MergeFrom(other.WeightedClusters);
          break;
        case ClusterSpecifierOneofCase.ClusterSpecifierPlugin:
          ClusterSpecifierPlugin = other.ClusterSpecifierPlugin;
          break;
        case ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin:
          if (InlineClusterSpecifierPlugin == null) {
            InlineClusterSpecifierPlugin = new global::Envoy.Config.Route.V3.ClusterSpecifierPlugin();
          }
          InlineClusterSpecifierPlugin.MergeFrom(other.InlineClusterSpecifierPlugin);
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewriteLiteral:
          HostRewriteLiteral = other.HostRewriteLiteral;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.HostRewriteHeader:
          HostRewriteHeader = other.HostRewriteHeader;
          break;
        case HostRewriteSpecifierOneofCase.HostRewritePathRegex:
          if (HostRewritePathRegex == null) {
            HostRewritePathRegex = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
          }
          HostRewritePathRegex.MergeFrom(other.HostRewritePathRegex);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Cluster = input.ReadString();
            break;
          }
          case 18: {
            ClusterHeader = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Config.Route.V3.WeightedCluster subBuilder = new global::Envoy.Config.Route.V3.WeightedCluster();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
              subBuilder.MergeFrom(WeightedClusters);
            }
            input.ReadMessage(subBuilder);
            WeightedClusters = subBuilder;
            break;
          }
          case 34: {
            if (metadataMatch_ == null) {
              MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(MetadataMatch);
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 50: {
            HostRewriteLiteral = input.ReadString();
            break;
          }
          case 58: {
            AutoHostRewrite = _oneof_autoHostRewrite_codec.Read(input);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 74: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 88: {
            Priority = (global::Envoy.Config.Core.V3.RoutingPriority) input.ReadEnum();
            break;
          }
          case 106: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 114: {
            bool? value = _single_includeVhRateLimits_codec.Read(input);
            if (includeVhRateLimits_ == null || value != false) {
              IncludeVhRateLimits = value;
            }
            break;
          }
          case 122: {
            hashPolicy_.AddEntriesFrom(input, _repeated_hashPolicy_codec);
            break;
          }
          case 138: {
            if (cors_ == null) {
              Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 160: {
            ClusterNotFoundResponseCode = (global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode) input.ReadEnum();
            break;
          }
          case 186: {
            if (maxGrpcTimeout_ == null) {
              MaxGrpcTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxGrpcTimeout);
            break;
          }
          case 194: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 202: {
            upgradeConfigs_.AddEntriesFrom(input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 208: {
            InternalRedirectAction = (global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction) input.ReadEnum();
            break;
          }
          case 218: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
          case 226: {
            if (grpcTimeoutOffset_ == null) {
              GrpcTimeoutOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(GrpcTimeoutOffset);
            break;
          }
          case 234: {
            HostRewriteHeader = input.ReadString();
            break;
          }
          case 242: {
            requestMirrorPolicies_.AddEntriesFrom(input, _repeated_requestMirrorPolicies_codec);
            break;
          }
          case 250: {
            uint? value = _single_maxInternalRedirects_codec.Read(input);
            if (maxInternalRedirects_ == null || value != 0) {
              MaxInternalRedirects = value;
            }
            break;
          }
          case 258: {
            if (regexRewrite_ == null) {
              RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            }
            input.ReadMessage(RegexRewrite);
            break;
          }
          case 266: {
            if (retryPolicyTypedConfig_ == null) {
              RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(RetryPolicyTypedConfig);
            break;
          }
          case 274: {
            if (internalRedirectPolicy_ == null) {
              InternalRedirectPolicy = new global::Envoy.Config.Route.V3.InternalRedirectPolicy();
            }
            input.ReadMessage(InternalRedirectPolicy);
            break;
          }
          case 282: {
            global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) {
              subBuilder.MergeFrom(HostRewritePathRegex);
            }
            input.ReadMessage(subBuilder);
            HostRewritePathRegex = subBuilder;
            break;
          }
          case 290: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 298: {
            ClusterSpecifierPlugin = input.ReadString();
            break;
          }
          case 304: {
            AppendXForwardedHost = input.ReadBool();
            break;
          }
          case 314: {
            global::Envoy.Config.Route.V3.ClusterSpecifierPlugin subBuilder = new global::Envoy.Config.Route.V3.ClusterSpecifierPlugin();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) {
              subBuilder.MergeFrom(InlineClusterSpecifierPlugin);
            }
            input.ReadMessage(subBuilder);
            InlineClusterSpecifierPlugin = subBuilder;
            break;
          }
          case 322: {
            if (earlyDataPolicy_ == null) {
              EarlyDataPolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(EarlyDataPolicy);
            break;
          }
          case 330: {
            if (pathRewritePolicy_ == null) {
              PathRewritePolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(PathRewritePolicy);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Cluster = input.ReadString();
            break;
          }
          case 18: {
            ClusterHeader = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Config.Route.V3.WeightedCluster subBuilder = new global::Envoy.Config.Route.V3.WeightedCluster();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
              subBuilder.MergeFrom(WeightedClusters);
            }
            input.ReadMessage(subBuilder);
            WeightedClusters = subBuilder;
            break;
          }
          case 34: {
            if (metadataMatch_ == null) {
              MetadataMatch = new global::Envoy.Config.Core.V3.Metadata();
            }
            input.ReadMessage(MetadataMatch);
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 50: {
            HostRewriteLiteral = input.ReadString();
            break;
          }
          case 58: {
            AutoHostRewrite = _oneof_autoHostRewrite_codec.Read(ref input);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 74: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Config.Route.V3.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 88: {
            Priority = (global::Envoy.Config.Core.V3.RoutingPriority) input.ReadEnum();
            break;
          }
          case 106: {
            rateLimits_.AddEntriesFrom(ref input, _repeated_rateLimits_codec);
            break;
          }
          case 114: {
            bool? value = _single_includeVhRateLimits_codec.Read(ref input);
            if (includeVhRateLimits_ == null || value != false) {
              IncludeVhRateLimits = value;
            }
            break;
          }
          case 122: {
            hashPolicy_.AddEntriesFrom(ref input, _repeated_hashPolicy_codec);
            break;
          }
          case 138: {
            if (cors_ == null) {
              Cors = new global::Envoy.Config.Route.V3.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 160: {
            ClusterNotFoundResponseCode = (global::Envoy.Config.Route.V3.RouteAction.Types.ClusterNotFoundResponseCode) input.ReadEnum();
            break;
          }
          case 186: {
            if (maxGrpcTimeout_ == null) {
              MaxGrpcTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxGrpcTimeout);
            break;
          }
          case 194: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 202: {
            upgradeConfigs_.AddEntriesFrom(ref input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 208: {
            InternalRedirectAction = (global::Envoy.Config.Route.V3.RouteAction.Types.InternalRedirectAction) input.ReadEnum();
            break;
          }
          case 218: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Config.Route.V3.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
          case 226: {
            if (grpcTimeoutOffset_ == null) {
              GrpcTimeoutOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(GrpcTimeoutOffset);
            break;
          }
          case 234: {
            HostRewriteHeader = input.ReadString();
            break;
          }
          case 242: {
            requestMirrorPolicies_.AddEntriesFrom(ref input, _repeated_requestMirrorPolicies_codec);
            break;
          }
          case 250: {
            uint? value = _single_maxInternalRedirects_codec.Read(ref input);
            if (maxInternalRedirects_ == null || value != 0) {
              MaxInternalRedirects = value;
            }
            break;
          }
          case 258: {
            if (regexRewrite_ == null) {
              RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            }
            input.ReadMessage(RegexRewrite);
            break;
          }
          case 266: {
            if (retryPolicyTypedConfig_ == null) {
              RetryPolicyTypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(RetryPolicyTypedConfig);
            break;
          }
          case 274: {
            if (internalRedirectPolicy_ == null) {
              InternalRedirectPolicy = new global::Envoy.Config.Route.V3.InternalRedirectPolicy();
            }
            input.ReadMessage(InternalRedirectPolicy);
            break;
          }
          case 282: {
            global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewritePathRegex) {
              subBuilder.MergeFrom(HostRewritePathRegex);
            }
            input.ReadMessage(subBuilder);
            HostRewritePathRegex = subBuilder;
            break;
          }
          case 290: {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration = new global::Envoy.Config.Route.V3.RouteAction.Types.MaxStreamDuration();
            }
            input.ReadMessage(MaxStreamDuration);
            break;
          }
          case 298: {
            ClusterSpecifierPlugin = input.ReadString();
            break;
          }
          case 304: {
            AppendXForwardedHost = input.ReadBool();
            break;
          }
          case 314: {
            global::Envoy.Config.Route.V3.ClusterSpecifierPlugin subBuilder = new global::Envoy.Config.Route.V3.ClusterSpecifierPlugin();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.InlineClusterSpecifierPlugin) {
              subBuilder.MergeFrom(InlineClusterSpecifierPlugin);
            }
            input.ReadMessage(subBuilder);
            InlineClusterSpecifierPlugin = subBuilder;
            break;
          }
          case 322: {
            if (earlyDataPolicy_ == null) {
              EarlyDataPolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(EarlyDataPolicy);
            break;
          }
          case 330: {
            if (pathRewritePolicy_ == null) {
              PathRewritePolicy = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
            }
            input.ReadMessage(PathRewritePolicy);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RouteAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ClusterNotFoundResponseCode {
        /// <summary>
        /// HTTP status code - 503 Service Unavailable.
        /// </summary>
        [pbr::OriginalName("SERVICE_UNAVAILABLE")] ServiceUnavailable = 0,
        /// <summary>
        /// HTTP status code - 404 Not Found.
        /// </summary>
        [pbr::OriginalName("NOT_FOUND")] NotFound = 1,
        /// <summary>
        /// HTTP status code - 500 Internal Server Error.
        /// </summary>
        [pbr::OriginalName("INTERNAL_SERVER_ERROR")] InternalServerError = 2,
      }

      /// <summary>
      /// Configures :ref:`internal redirect &lt;arch_overview_internal_redirects>` behavior.
      /// [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
      /// </summary>
      public enum InternalRedirectAction {
        [pbr::OriginalName("PASS_THROUGH_INTERNAL_REDIRECT")] PassThroughInternalRedirect = 0,
        [pbr::OriginalName("HANDLE_INTERNAL_REDIRECT")] HandleInternalRedirect = 1,
      }

      /// <summary>
      /// The router is capable of shadowing traffic from one cluster to another. The current
      /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      /// respond before returning the response from the primary cluster. All normal statistics are
      /// collected for the shadow cluster making this feature useful for testing.
      ///
      /// During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is
      /// useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``.
      ///
      /// .. note::
      ///
      ///   Shadowing will not be triggered if the primary cluster does not exist.
      ///
      /// .. note::
      ///
      ///   Shadowing doesn't support Http CONNECT and upgrades.
      /// [#next-free-field: 6]
      /// </summary>
      public sealed partial class RequestMirrorPolicy : pb::IMessage<RequestMirrorPolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RequestMirrorPolicy> _parser = new pb::MessageParser<RequestMirrorPolicy>(() => new RequestMirrorPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RequestMirrorPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteAction.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RequestMirrorPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RequestMirrorPolicy(RequestMirrorPolicy other) : this() {
          cluster_ = other.cluster_;
          clusterHeader_ = other.clusterHeader_;
          runtimeFraction_ = other.runtimeFraction_ != null ? other.runtimeFraction_.Clone() : null;
          TraceSampled = other.TraceSampled;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RequestMirrorPolicy Clone() {
          return new RequestMirrorPolicy(this);
        }

        /// <summary>Field number for the "cluster" field.</summary>
        public const int ClusterFieldNumber = 1;
        private string cluster_ = "";
        /// <summary>
        /// Only one of ``cluster`` and ``cluster_header`` can be specified.
        /// [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
        /// Specifies the cluster that requests will be mirrored to. The cluster must
        /// exist in the cluster manager configuration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Cluster {
          get { return cluster_; }
          set {
            cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "cluster_header" field.</summary>
        public const int ClusterHeaderFieldNumber = 5;
        private string clusterHeader_ = "";
        /// <summary>
        /// Only one of ``cluster`` and ``cluster_header`` can be specified.
        /// Envoy will determine the cluster to route to by reading the value of the
        /// HTTP header named by cluster_header from the request headers. Only the first value in header is used,
        /// and no shadow request will happen if the value is not found in headers. Envoy will not wait for
        /// the shadow cluster to respond before returning the response from the primary cluster.
        ///
        /// .. attention::
        ///
        ///   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
        ///   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
        ///
        /// .. note::
        ///
        ///   If the header appears multiple times only the first value is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ClusterHeader {
          get { return clusterHeader_; }
          set {
            clusterHeader_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "runtime_fraction" field.</summary>
        public const int RuntimeFractionFieldNumber = 3;
        private global::Envoy.Config.Core.V3.RuntimeFractionalPercent runtimeFraction_;
        /// <summary>
        /// If not specified, all requests to the target cluster will be mirrored.
        ///
        /// If specified, this field takes precedence over the ``runtime_key`` field and requests must also
        /// fall under the percentage of matches indicated by this field.
        ///
        /// For some fraction N/D, a random number in the range [0,D) is selected. If the
        /// number is &lt;= the value of the numerator N, or if the key is not present, the default
        /// value, the request will be mirrored.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.RuntimeFractionalPercent RuntimeFraction {
          get { return runtimeFraction_; }
          set {
            runtimeFraction_ = value;
          }
        }

        /// <summary>Field number for the "trace_sampled" field.</summary>
        public const int TraceSampledFieldNumber = 4;
        private static readonly pb::FieldCodec<bool?> _single_traceSampled_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
        private bool? traceSampled_;
        /// <summary>
        /// Determines if the trace span should be sampled. Defaults to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? TraceSampled {
          get { return traceSampled_; }
          set {
            traceSampled_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RequestMirrorPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RequestMirrorPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Cluster != other.Cluster) return false;
          if (ClusterHeader != other.ClusterHeader) return false;
          if (!object.Equals(RuntimeFraction, other.RuntimeFraction)) return false;
          if (TraceSampled != other.TraceSampled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
          if (ClusterHeader.Length != 0) hash ^= ClusterHeader.GetHashCode();
          if (runtimeFraction_ != null) hash ^= RuntimeFraction.GetHashCode();
          if (traceSampled_ != null) hash ^= TraceSampled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Cluster.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Cluster);
          }
          if (runtimeFraction_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(RuntimeFraction);
          }
          if (traceSampled_ != null) {
            _single_traceSampled_codec.WriteTagAndValue(output, TraceSampled);
          }
          if (ClusterHeader.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(ClusterHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Cluster.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Cluster);
          }
          if (runtimeFraction_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(RuntimeFraction);
          }
          if (traceSampled_ != null) {
            _single_traceSampled_codec.WriteTagAndValue(ref output, TraceSampled);
          }
          if (ClusterHeader.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(ClusterHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Cluster.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
          }
          if (ClusterHeader.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterHeader);
          }
          if (runtimeFraction_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RuntimeFraction);
          }
          if (traceSampled_ != null) {
            size += _single_traceSampled_codec.CalculateSizeWithTag(TraceSampled);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RequestMirrorPolicy other) {
          if (other == null) {
            return;
          }
          if (other.Cluster.Length != 0) {
            Cluster = other.Cluster;
          }
          if (other.ClusterHeader.Length != 0) {
            ClusterHeader = other.ClusterHeader;
          }
          if (other.runtimeFraction_ != null) {
            if (runtimeFraction_ == null) {
              RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
            }
            RuntimeFraction.MergeFrom(other.RuntimeFraction);
          }
          if (other.traceSampled_ != null) {
            if (traceSampled_ == null || other.TraceSampled != false) {
              TraceSampled = other.TraceSampled;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Cluster = input.ReadString();
                break;
              }
              case 26: {
                if (runtimeFraction_ == null) {
                  RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
                }
                input.ReadMessage(RuntimeFraction);
                break;
              }
              case 34: {
                bool? value = _single_traceSampled_codec.Read(input);
                if (traceSampled_ == null || value != false) {
                  TraceSampled = value;
                }
                break;
              }
              case 42: {
                ClusterHeader = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Cluster = input.ReadString();
                break;
              }
              case 26: {
                if (runtimeFraction_ == null) {
                  RuntimeFraction = new global::Envoy.Config.Core.V3.RuntimeFractionalPercent();
                }
                input.ReadMessage(RuntimeFraction);
                break;
              }
              case 34: {
                bool? value = _single_traceSampled_codec.Read(ref input);
                if (traceSampled_ == null || value != false) {
                  TraceSampled = value;
                }
                break;
              }
              case 42: {
                ClusterHeader = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
      /// &lt;arch_overview_load_balancing_types>`.
      /// [#next-free-field: 7]
      /// </summary>
      public sealed partial class HashPolicy : pb::IMessage<HashPolicy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<HashPolicy> _parser = new pb::MessageParser<HashPolicy>(() => new HashPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<HashPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteAction.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy(HashPolicy other) : this() {
          terminal_ = other.terminal_;
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              Header = other.Header.Clone();
              break;
            case PolicySpecifierOneofCase.Cookie:
              Cookie = other.Cookie.Clone();
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              ConnectionProperties = other.ConnectionProperties.Clone();
              break;
            case PolicySpecifierOneofCase.QueryParameter:
              QueryParameter = other.QueryParameter.Clone();
              break;
            case PolicySpecifierOneofCase.FilterState:
              FilterState = other.FilterState.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public HashPolicy Clone() {
          return new HashPolicy(this);
        }

        /// <summary>Field number for the "header" field.</summary>
        public const int HeaderFieldNumber = 1;
        /// <summary>
        /// Header hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header Header {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Header ? (global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Header;
          }
        }

        /// <summary>Field number for the "cookie" field.</summary>
        public const int CookieFieldNumber = 2;
        /// <summary>
        /// Cookie hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie Cookie {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Cookie ? (global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Cookie;
          }
        }

        /// <summary>Field number for the "connection_properties" field.</summary>
        public const int ConnectionPropertiesFieldNumber = 3;
        /// <summary>
        /// Connection properties hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties ConnectionProperties {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties ? (global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.ConnectionProperties;
          }
        }

        /// <summary>Field number for the "query_parameter" field.</summary>
        public const int QueryParameterFieldNumber = 5;
        /// <summary>
        /// Query parameter hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter QueryParameter {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter ? (global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.QueryParameter;
          }
        }

        /// <summary>Field number for the "filter_state" field.</summary>
        public const int FilterStateFieldNumber = 6;
        /// <summary>
        /// Filter state hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState FilterState {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.FilterState ? (global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.FilterState;
          }
        }

        /// <summary>Field number for the "terminal" field.</summary>
        public const int TerminalFieldNumber = 4;
        private bool terminal_;
        /// <summary>
        /// The flag that short-circuits the hash computing. This field provides a
        /// 'fallback' style of configuration: "if a terminal policy doesn't work,
        /// fallback to rest of the policy list", it saves time when the terminal
        /// policy works.
        ///
        /// If true, and there is already a hash computed, ignore rest of the
        /// list of hash polices.
        /// For example, if the following hash methods are configured:
        ///
        ///  ========= ========
        ///  specifier terminal
        ///  ========= ========
        ///  Header A  true
        ///  Header B  false
        ///  Header C  false
        ///  ========= ========
        ///
        /// The generateHash process ends if policy "header A" generates a hash, as
        /// it's a terminal policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Terminal {
          get { return terminal_; }
          set {
            terminal_ = value;
          }
        }

        private object policySpecifier_;
        /// <summary>Enum of possible cases for the "policy_specifier" oneof.</summary>
        public enum PolicySpecifierOneofCase {
          None = 0,
          Header = 1,
          Cookie = 2,
          ConnectionProperties = 3,
          QueryParameter = 5,
          FilterState = 6,
        }
        private PolicySpecifierOneofCase policySpecifierCase_ = PolicySpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PolicySpecifierOneofCase PolicySpecifierCase {
          get { return policySpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearPolicySpecifier() {
          policySpecifierCase_ = PolicySpecifierOneofCase.None;
          policySpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as HashPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(HashPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Header, other.Header)) return false;
          if (!object.Equals(Cookie, other.Cookie)) return false;
          if (!object.Equals(ConnectionProperties, other.ConnectionProperties)) return false;
          if (!object.Equals(QueryParameter, other.QueryParameter)) return false;
          if (!object.Equals(FilterState, other.FilterState)) return false;
          if (Terminal != other.Terminal) return false;
          if (PolicySpecifierCase != other.PolicySpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) hash ^= Header.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) hash ^= Cookie.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) hash ^= ConnectionProperties.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) hash ^= QueryParameter.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) hash ^= FilterState.GetHashCode();
          if (Terminal != false) hash ^= Terminal.GetHashCode();
          hash ^= (int) policySpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            output.WriteRawTag(10);
            output.WriteMessage(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            output.WriteRawTag(18);
            output.WriteMessage(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectionProperties);
          }
          if (Terminal != false) {
            output.WriteRawTag(32);
            output.WriteBool(Terminal);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) {
            output.WriteRawTag(42);
            output.WriteMessage(QueryParameter);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) {
            output.WriteRawTag(50);
            output.WriteMessage(FilterState);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            output.WriteRawTag(10);
            output.WriteMessage(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            output.WriteRawTag(18);
            output.WriteMessage(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectionProperties);
          }
          if (Terminal != false) {
            output.WriteRawTag(32);
            output.WriteBool(Terminal);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) {
            output.WriteRawTag(42);
            output.WriteMessage(QueryParameter);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) {
            output.WriteRawTag(50);
            output.WriteMessage(FilterState);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionProperties);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(QueryParameter);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilterState);
          }
          if (Terminal != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(HashPolicy other) {
          if (other == null) {
            return;
          }
          if (other.Terminal != false) {
            Terminal = other.Terminal;
          }
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              if (Header == null) {
                Header = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header();
              }
              Header.MergeFrom(other.Header);
              break;
            case PolicySpecifierOneofCase.Cookie:
              if (Cookie == null) {
                Cookie = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie();
              }
              Cookie.MergeFrom(other.Cookie);
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              if (ConnectionProperties == null) {
                ConnectionProperties = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
              }
              ConnectionProperties.MergeFrom(other.ConnectionProperties);
              break;
            case PolicySpecifierOneofCase.QueryParameter:
              if (QueryParameter == null) {
                QueryParameter = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter();
              }
              QueryParameter.MergeFrom(other.QueryParameter);
              break;
            case PolicySpecifierOneofCase.FilterState:
              if (FilterState == null) {
                FilterState = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState();
              }
              FilterState.MergeFrom(other.FilterState);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
                  subBuilder.MergeFrom(Header);
                }
                input.ReadMessage(subBuilder);
                Header = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
                  subBuilder.MergeFrom(Cookie);
                }
                input.ReadMessage(subBuilder);
                Cookie = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
                  subBuilder.MergeFrom(ConnectionProperties);
                }
                input.ReadMessage(subBuilder);
                ConnectionProperties = subBuilder;
                break;
              }
              case 32: {
                Terminal = input.ReadBool();
                break;
              }
              case 42: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) {
                  subBuilder.MergeFrom(QueryParameter);
                }
                input.ReadMessage(subBuilder);
                QueryParameter = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) {
                  subBuilder.MergeFrom(FilterState);
                }
                input.ReadMessage(subBuilder);
                FilterState = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Header();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
                  subBuilder.MergeFrom(Header);
                }
                input.ReadMessage(subBuilder);
                Header = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.Cookie();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
                  subBuilder.MergeFrom(Cookie);
                }
                input.ReadMessage(subBuilder);
                Cookie = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
                  subBuilder.MergeFrom(ConnectionProperties);
                }
                input.ReadMessage(subBuilder);
                ConnectionProperties = subBuilder;
                break;
              }
              case 32: {
                Terminal = input.ReadBool();
                break;
              }
              case 42: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.QueryParameter();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.QueryParameter) {
                  subBuilder.MergeFrom(QueryParameter);
                }
                input.ReadMessage(subBuilder);
                QueryParameter = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState subBuilder = new global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Types.FilterState();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.FilterState) {
                  subBuilder.MergeFrom(FilterState);
                }
                input.ReadMessage(subBuilder);
                FilterState = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the HashPolicy message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public sealed partial class Header : pb::IMessage<Header>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Header> _parser = new pb::MessageParser<Header>(() => new Header());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Header> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Header() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Header(Header other) : this() {
              headerName_ = other.headerName_;
              regexRewrite_ = other.regexRewrite_ != null ? other.regexRewrite_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Header Clone() {
              return new Header(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The name of the request header that will be used to obtain the hash
            /// key. If the request header is not present, no hash will be produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "regex_rewrite" field.</summary>
            public const int RegexRewriteFieldNumber = 2;
            private global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute regexRewrite_;
            /// <summary>
            /// If specified, the request header value will be rewritten and used
            /// to produce the hash key.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute RegexRewrite {
              get { return regexRewrite_; }
              set {
                regexRewrite_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Header);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Header other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              if (!object.Equals(RegexRewrite, other.RegexRewrite)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (regexRewrite_ != null) hash ^= RegexRewrite.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (regexRewrite_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(RegexRewrite);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (regexRewrite_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(RegexRewrite);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (regexRewrite_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RegexRewrite);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Header other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              if (other.regexRewrite_ != null) {
                if (regexRewrite_ == null) {
                  RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
                }
                RegexRewrite.MergeFrom(other.RegexRewrite);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (regexRewrite_ == null) {
                      RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
                    }
                    input.ReadMessage(RegexRewrite);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (regexRewrite_ == null) {
                      RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
                    }
                    input.ReadMessage(RegexRewrite);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Envoy supports two types of cookie affinity:
          ///
          /// 1. Passive. Envoy takes a cookie that's present in the cookies header and
          ///    hashes on its value.
          ///
          /// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
          ///    on the first request from the client in its response to the client,
          ///    based on the endpoint the request gets sent to. The client then
          ///    presents this on the next and all subsequent requests. The hash of
          ///    this is sufficient to ensure these requests get sent to the same
          ///    endpoint. The cookie is generated by hashing the source and
          ///    destination ports and addresses so that multiple independent HTTP2
          ///    streams on the same connection will independently receive the same
          ///    cookie, even if they arrive at the Envoy simultaneously.
          /// </summary>
          public sealed partial class Cookie : pb::IMessage<Cookie>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Cookie> _parser = new pb::MessageParser<Cookie>(() => new Cookie());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Cookie> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Cookie() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Cookie(Cookie other) : this() {
              name_ = other.name_;
              ttl_ = other.ttl_ != null ? other.ttl_.Clone() : null;
              path_ = other.path_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Cookie Clone() {
              return new Cookie(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            /// The name of the cookie that will be used to obtain the hash key. If the
            /// cookie is not present and ttl below is not set, no hash will be
            /// produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "ttl" field.</summary>
            public const int TtlFieldNumber = 2;
            private global::Google.Protobuf.WellKnownTypes.Duration ttl_;
            /// <summary>
            /// If specified, a cookie with the TTL will be generated if the cookie is
            /// not present. If the TTL is present and zero, the generated cookie will
            /// be a session cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Protobuf.WellKnownTypes.Duration Ttl {
              get { return ttl_; }
              set {
                ttl_ = value;
              }
            }

            /// <summary>Field number for the "path" field.</summary>
            public const int PathFieldNumber = 3;
            private string path_ = "";
            /// <summary>
            /// The name of the path for the cookie. If no path is specified here, no path
            /// will be set for the cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Path {
              get { return path_; }
              set {
                path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Cookie);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Cookie other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              if (!object.Equals(Ttl, other.Ttl)) return false;
              if (Path != other.Path) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              if (ttl_ != null) hash ^= Ttl.GetHashCode();
              if (Path.Length != 0) hash ^= Path.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (ttl_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(Ttl);
              }
              if (Path.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(Path);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (ttl_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(Ttl);
              }
              if (Path.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(Path);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              if (ttl_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ttl);
              }
              if (Path.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Cookie other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              if (other.ttl_ != null) {
                if (ttl_ == null) {
                  Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                Ttl.MergeFrom(other.Ttl);
              }
              if (other.Path.Length != 0) {
                Path = other.Path;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (ttl_ == null) {
                      Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(Ttl);
                    break;
                  }
                  case 26: {
                    Path = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (ttl_ == null) {
                      Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(Ttl);
                    break;
                  }
                  case 26: {
                    Path = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          public sealed partial class ConnectionProperties : pb::IMessage<ConnectionProperties>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ConnectionProperties> _parser = new pb::MessageParser<ConnectionProperties>(() => new ConnectionProperties());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ConnectionProperties> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectionProperties() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectionProperties(ConnectionProperties other) : this() {
              sourceIp_ = other.sourceIp_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectionProperties Clone() {
              return new ConnectionProperties(this);
            }

            /// <summary>Field number for the "source_ip" field.</summary>
            public const int SourceIpFieldNumber = 1;
            private bool sourceIp_;
            /// <summary>
            /// Hash on source IP address.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool SourceIp {
              get { return sourceIp_; }
              set {
                sourceIp_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ConnectionProperties);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ConnectionProperties other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (SourceIp != other.SourceIp) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (SourceIp != false) hash ^= SourceIp.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (SourceIp != false) {
                output.WriteRawTag(8);
                output.WriteBool(SourceIp);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (SourceIp != false) {
                output.WriteRawTag(8);
                output.WriteBool(SourceIp);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (SourceIp != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ConnectionProperties other) {
              if (other == null) {
                return;
              }
              if (other.SourceIp != false) {
                SourceIp = other.SourceIp;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    SourceIp = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    SourceIp = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

          public sealed partial class QueryParameter : pb::IMessage<QueryParameter>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<QueryParameter> _parser = new pb::MessageParser<QueryParameter>(() => new QueryParameter());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<QueryParameter> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryParameter() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryParameter(QueryParameter other) : this() {
              name_ = other.name_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryParameter Clone() {
              return new QueryParameter(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            /// The name of the URL query parameter that will be used to obtain the hash
            /// key. If the parameter is not present, no hash will be produced. Query
            /// parameter names are case-sensitive.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as QueryParameter);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(QueryParameter other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(QueryParameter other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          public sealed partial class FilterState : pb::IMessage<FilterState>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<FilterState> _parser = new pb::MessageParser<FilterState>(() => new FilterState());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<FilterState> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[4]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FilterState() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FilterState(FilterState other) : this() {
              key_ = other.key_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FilterState Clone() {
              return new FilterState(this);
            }

            /// <summary>Field number for the "key" field.</summary>
            public const int KeyFieldNumber = 1;
            private string key_ = "";
            /// <summary>
            /// The name of the Object in the per-request filterState, which is an
            /// Envoy::Hashable object. If there is no data associated with the key,
            /// or the stored object is not Envoy::Hashable, no hash will be produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Key {
              get { return key_; }
              set {
                key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as FilterState);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(FilterState other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Key != other.Key) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Key.Length != 0) hash ^= Key.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Key.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Key);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Key.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Key);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Key.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(FilterState other) {
              if (other == null) {
                return;
              }
              if (other.Key.Length != 0) {
                Key = other.Key;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Key = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Key = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// Allows enabling and disabling upgrades on a per-route basis.
      /// This overrides any enabled/disabled upgrade filter chain specified in the
      /// HttpConnectionManager
      /// :ref:`upgrade_configs
      /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
      /// but does not affect any custom filter chain specified there.
      /// </summary>
      public sealed partial class UpgradeConfig : pb::IMessage<UpgradeConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<UpgradeConfig> _parser = new pb::MessageParser<UpgradeConfig>(() => new UpgradeConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<UpgradeConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteAction.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig(UpgradeConfig other) : this() {
          upgradeType_ = other.upgradeType_;
          Enabled = other.Enabled;
          connectConfig_ = other.connectConfig_ != null ? other.connectConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public UpgradeConfig Clone() {
          return new UpgradeConfig(this);
        }

        /// <summary>Field number for the "upgrade_type" field.</summary>
        public const int UpgradeTypeFieldNumber = 1;
        private string upgradeType_ = "";
        /// <summary>
        /// The case-insensitive name of this upgrade, e.g. "websocket".
        /// For each upgrade type present in upgrade_configs, requests with
        /// Upgrade: [upgrade_type] will be proxied upstream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string UpgradeType {
          get { return upgradeType_; }
          set {
            upgradeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 2;
        private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
        private bool? enabled_;
        /// <summary>
        /// Determines if upgrades are available on this route. Defaults to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool? Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }


        /// <summary>Field number for the "connect_config" field.</summary>
        public const int ConnectConfigFieldNumber = 3;
        private global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig connectConfig_;
        /// <summary>
        /// Configuration for sending data upstream as a raw data payload. This is used for
        /// CONNECT requests, when forwarding CONNECT payload as raw TCP.
        /// Note that CONNECT support is currently considered alpha in Envoy.
        /// [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig ConnectConfig {
          get { return connectConfig_; }
          set {
            connectConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as UpgradeConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(UpgradeConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UpgradeType != other.UpgradeType) return false;
          if (Enabled != other.Enabled) return false;
          if (!object.Equals(ConnectConfig, other.ConnectConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (UpgradeType.Length != 0) hash ^= UpgradeType.GetHashCode();
          if (enabled_ != null) hash ^= Enabled.GetHashCode();
          if (connectConfig_ != null) hash ^= ConnectConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(output, Enabled);
          }
          if (connectConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(ref output, Enabled);
          }
          if (connectConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (UpgradeType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(UpgradeType);
          }
          if (enabled_ != null) {
            size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
          }
          if (connectConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(UpgradeConfig other) {
          if (other == null) {
            return;
          }
          if (other.UpgradeType.Length != 0) {
            UpgradeType = other.UpgradeType;
          }
          if (other.enabled_ != null) {
            if (enabled_ == null || other.Enabled != false) {
              Enabled = other.Enabled;
            }
          }
          if (other.connectConfig_ != null) {
            if (connectConfig_ == null) {
              ConnectConfig = new global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig();
            }
            ConnectConfig.MergeFrom(other.ConnectConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                bool? value = _single_enabled_codec.Read(input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
              case 26: {
                if (connectConfig_ == null) {
                  ConnectConfig = new global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig();
                }
                input.ReadMessage(ConnectConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                bool? value = _single_enabled_codec.Read(ref input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
              case 26: {
                if (connectConfig_ == null) {
                  ConnectConfig = new global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Types.ConnectConfig();
                }
                input.ReadMessage(ConnectConfig);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the UpgradeConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Configuration for sending data upstream as a raw data payload. This is used for
          /// CONNECT or POST requests, when forwarding request payload as raw TCP.
          /// </summary>
          public sealed partial class ConnectConfig : pb::IMessage<ConnectConfig>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ConnectConfig> _parser = new pb::MessageParser<ConnectConfig>(() => new ConnectConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ConnectConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RouteAction.Types.UpgradeConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectConfig(ConnectConfig other) : this() {
              proxyProtocolConfig_ = other.proxyProtocolConfig_ != null ? other.proxyProtocolConfig_.Clone() : null;
              allowPost_ = other.allowPost_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ConnectConfig Clone() {
              return new ConnectConfig(this);
            }

            /// <summary>Field number for the "proxy_protocol_config" field.</summary>
            public const int ProxyProtocolConfigFieldNumber = 1;
            private global::Envoy.Config.Core.V3.ProxyProtocolConfig proxyProtocolConfig_;
            /// <summary>
            /// If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Config.Core.V3.ProxyProtocolConfig ProxyProtocolConfig {
              get { return proxyProtocolConfig_; }
              set {
                proxyProtocolConfig_ = value;
              }
            }

            /// <summary>Field number for the "allow_post" field.</summary>
            public const int AllowPostFieldNumber = 2;
            private bool allowPost_;
            /// <summary>
            /// If set, the route will also allow forwarding POST payload as raw TCP.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowPost {
              get { return allowPost_; }
              set {
                allowPost_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ConnectConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ConnectConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(ProxyProtocolConfig, other.ProxyProtocolConfig)) return false;
              if (AllowPost != other.AllowPost) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (proxyProtocolConfig_ != null) hash ^= ProxyProtocolConfig.GetHashCode();
              if (AllowPost != false) hash ^= AllowPost.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (proxyProtocolConfig_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(ProxyProtocolConfig);
              }
              if (AllowPost != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowPost);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (proxyProtocolConfig_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(ProxyProtocolConfig);
              }
              if (AllowPost != false) {
                output.WriteRawTag(16);
                output.WriteBool(AllowPost);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (proxyProtocolConfig_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(ProxyProtocolConfig);
              }
              if (AllowPost != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ConnectConfig other) {
              if (other == null) {
                return;
              }
              if (other.proxyProtocolConfig_ != null) {
                if (proxyProtocolConfig_ == null) {
                  ProxyProtocolConfig = new global::Envoy.Config.Core.V3.ProxyProtocolConfig();
                }
                ProxyProtocolConfig.MergeFrom(other.ProxyProtocolConfig);
              }
              if (other.AllowPost != false) {
                AllowPost = other.AllowPost;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (proxyProtocolConfig_ == null) {
                      ProxyProtocolConfig = new global::Envoy.Config.Core.V3.ProxyProtocolConfig();
                    }
                    input.ReadMessage(ProxyProtocolConfig);
                    break;
                  }
                  case 16: {
                    AllowPost = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (proxyProtocolConfig_ == null) {
                      ProxyProtocolConfig = new global::Envoy.Config.Core.V3.ProxyProtocolConfig();
                    }
                    input.ReadMessage(ProxyProtocolConfig);
                    break;
                  }
                  case 16: {
                    AllowPost = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      public sealed partial class MaxStreamDuration : pb::IMessage<MaxStreamDuration>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<MaxStreamDuration> _parser = new pb::MessageParser<MaxStreamDuration>(() => new MaxStreamDuration());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<MaxStreamDuration> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RouteAction.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaxStreamDuration() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaxStreamDuration(MaxStreamDuration other) : this() {
          maxStreamDuration_ = other.maxStreamDuration_ != null ? other.maxStreamDuration_.Clone() : null;
          grpcTimeoutHeaderMax_ = other.grpcTimeoutHeaderMax_ != null ? other.grpcTimeoutHeaderMax_.Clone() : null;
          grpcTimeoutHeaderOffset_ = other.grpcTimeoutHeaderOffset_ != null ? other.grpcTimeoutHeaderOffset_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public MaxStreamDuration Clone() {
          return new MaxStreamDuration(this);
        }

        /// <summary>Field number for the "max_stream_duration" field.</summary>
        public const int MaxStreamDuration_FieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration maxStreamDuration_;
        /// <summary>
        /// Specifies the maximum duration allowed for streams on the route. If not specified, the value
        /// from the :ref:`max_stream_duration
        /// &lt;envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
        /// :ref:`HttpConnectionManager.common_http_protocol_options
        /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
        /// is used. If this field is set explicitly to zero, any
        /// HttpConnectionManager max_stream_duration timeout will be disabled for
        /// this route.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxStreamDuration_ {
          get { return maxStreamDuration_; }
          set {
            maxStreamDuration_ = value;
          }
        }

        /// <summary>Field number for the "grpc_timeout_header_max" field.</summary>
        public const int GrpcTimeoutHeaderMaxFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration grpcTimeoutHeaderMax_;
        /// <summary>
        /// If present, and the request contains a `grpc-timeout header
        /// &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
        /// ``max_stream_duration``, but limit the applied timeout to the maximum value specified here.
        /// If set to 0, the ``grpc-timeout`` header is used without modification.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration GrpcTimeoutHeaderMax {
          get { return grpcTimeoutHeaderMax_; }
          set {
            grpcTimeoutHeaderMax_ = value;
          }
        }

        /// <summary>Field number for the "grpc_timeout_header_offset" field.</summary>
        public const int GrpcTimeoutHeaderOffsetFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Duration grpcTimeoutHeaderOffset_;
        /// <summary>
        /// If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by
        /// subtracting the provided duration from the header. This is useful for allowing Envoy to set
        /// its global timeout to be less than that of the deadline imposed by the calling client, which
        /// makes it more likely that Envoy will handle the timeout instead of having the call canceled
        /// by the client. If, after applying the offset, the resulting timeout is zero or negative,
        /// the stream will timeout immediately.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration GrpcTimeoutHeaderOffset {
          get { return grpcTimeoutHeaderOffset_; }
          set {
            grpcTimeoutHeaderOffset_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as MaxStreamDuration);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(MaxStreamDuration other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(MaxStreamDuration_, other.MaxStreamDuration_)) return false;
          if (!object.Equals(GrpcTimeoutHeaderMax, other.GrpcTimeoutHeaderMax)) return false;
          if (!object.Equals(GrpcTimeoutHeaderOffset, other.GrpcTimeoutHeaderOffset)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (maxStreamDuration_ != null) hash ^= MaxStreamDuration_.GetHashCode();
          if (grpcTimeoutHeaderMax_ != null) hash ^= GrpcTimeoutHeaderMax.GetHashCode();
          if (grpcTimeoutHeaderOffset_ != null) hash ^= GrpcTimeoutHeaderOffset.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (maxStreamDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MaxStreamDuration_);
          }
          if (grpcTimeoutHeaderMax_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(GrpcTimeoutHeaderMax);
          }
          if (grpcTimeoutHeaderOffset_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(GrpcTimeoutHeaderOffset);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (maxStreamDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MaxStreamDuration_);
          }
          if (grpcTimeoutHeaderMax_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(GrpcTimeoutHeaderMax);
          }
          if (grpcTimeoutHeaderOffset_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(GrpcTimeoutHeaderOffset);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (maxStreamDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxStreamDuration_);
          }
          if (grpcTimeoutHeaderMax_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcTimeoutHeaderMax);
          }
          if (grpcTimeoutHeaderOffset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcTimeoutHeaderOffset);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(MaxStreamDuration other) {
          if (other == null) {
            return;
          }
          if (other.maxStreamDuration_ != null) {
            if (maxStreamDuration_ == null) {
              MaxStreamDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxStreamDuration_.MergeFrom(other.MaxStreamDuration_);
          }
          if (other.grpcTimeoutHeaderMax_ != null) {
            if (grpcTimeoutHeaderMax_ == null) {
              GrpcTimeoutHeaderMax = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            GrpcTimeoutHeaderMax.MergeFrom(other.GrpcTimeoutHeaderMax);
          }
          if (other.grpcTimeoutHeaderOffset_ != null) {
            if (grpcTimeoutHeaderOffset_ == null) {
              GrpcTimeoutHeaderOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            GrpcTimeoutHeaderOffset.MergeFrom(other.GrpcTimeoutHeaderOffset);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (maxStreamDuration_ == null) {
                  MaxStreamDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxStreamDuration_);
                break;
              }
              case 18: {
                if (grpcTimeoutHeaderMax_ == null) {
                  GrpcTimeoutHeaderMax = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(GrpcTimeoutHeaderMax);
                break;
              }
              case 26: {
                if (grpcTimeoutHeaderOffset_ == null) {
                  GrpcTimeoutHeaderOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(GrpcTimeoutHeaderOffset);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (maxStreamDuration_ == null) {
                  MaxStreamDuration_ = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxStreamDuration_);
                break;
              }
              case 18: {
                if (grpcTimeoutHeaderMax_ == null) {
                  GrpcTimeoutHeaderMax = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(GrpcTimeoutHeaderMax);
                break;
              }
              case 26: {
                if (grpcTimeoutHeaderOffset_ == null) {
                  GrpcTimeoutHeaderOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(GrpcTimeoutHeaderOffset);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// HTTP retry :ref:`architecture overview &lt;arch_overview_http_routing_retry>`.
  /// [#next-free-field: 14]
  /// </summary>
  public sealed partial class RetryPolicy : pb::IMessage<RetryPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RetryPolicy> _parser = new pb::MessageParser<RetryPolicy>(() => new RetryPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RetryPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RetryPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RetryPolicy(RetryPolicy other) : this() {
      retryOn_ = other.retryOn_;
      NumRetries = other.NumRetries;
      perTryTimeout_ = other.perTryTimeout_ != null ? other.perTryTimeout_.Clone() : null;
      perTryIdleTimeout_ = other.perTryIdleTimeout_ != null ? other.perTryIdleTimeout_.Clone() : null;
      retryPriority_ = other.retryPriority_ != null ? other.retryPriority_.Clone() : null;
      retryHostPredicate_ = other.retryHostPredicate_.Clone();
      retryOptionsPredicates_ = other.retryOptionsPredicates_.Clone();
      hostSelectionRetryMaxAttempts_ = other.hostSelectionRetryMaxAttempts_;
      retriableStatusCodes_ = other.retriableStatusCodes_.Clone();
      retryBackOff_ = other.retryBackOff_ != null ? other.retryBackOff_.Clone() : null;
      rateLimitedRetryBackOff_ = other.rateLimitedRetryBackOff_ != null ? other.rateLimitedRetryBackOff_.Clone() : null;
      retriableHeaders_ = other.retriableHeaders_.Clone();
      retriableRequestHeaders_ = other.retriableRequestHeaders_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RetryPolicy Clone() {
      return new RetryPolicy(this);
    }

    /// <summary>Field number for the "retry_on" field.</summary>
    public const int RetryOnFieldNumber = 1;
    private string retryOn_ = "";
    /// <summary>
    /// Specifies the conditions under which retry takes place. These are the same
    /// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
    /// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RetryOn {
      get { return retryOn_; }
      set {
        retryOn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "num_retries" field.</summary>
    public const int NumRetriesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_numRetries_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? numRetries_;
    /// <summary>
    /// Specifies the allowed number of retries. This parameter is optional and
    /// defaults to 1. These are the same conditions documented for
    /// :ref:`config_http_filters_router_x-envoy-max-retries`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? NumRetries {
      get { return numRetries_; }
      set {
        numRetries_ = value;
      }
    }


    /// <summary>Field number for the "per_try_timeout" field.</summary>
    public const int PerTryTimeoutFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration perTryTimeout_;
    /// <summary>
    /// Specifies a non-zero upstream timeout per retry attempt (including the initial attempt). This
    /// parameter is optional. The same conditions documented for
    /// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
    ///
    /// .. note::
    ///
    ///   If left unspecified, Envoy will use the global
    ///   :ref:`route timeout &lt;envoy_v3_api_field_config.route.v3.RouteAction.timeout>` for the request.
    ///   Consequently, when using a :ref:`5xx &lt;config_http_filters_router_x-envoy-retry-on>` based
    ///   retry policy, a request that times out will not be retried as the total timeout budget
    ///   would have been exhausted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration PerTryTimeout {
      get { return perTryTimeout_; }
      set {
        perTryTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_try_idle_timeout" field.</summary>
    public const int PerTryIdleTimeoutFieldNumber = 13;
    private global::Google.Protobuf.WellKnownTypes.Duration perTryIdleTimeout_;
    /// <summary>
    /// Specifies an upstream idle timeout per retry attempt (including the initial attempt). This
    /// parameter is optional and if absent there is no per try idle timeout. The semantics of the per
    /// try idle timeout are similar to the
    /// :ref:`route idle timeout &lt;envoy_v3_api_field_config.route.v3.RouteAction.timeout>` and
    /// :ref:`stream idle timeout
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
    /// both enforced by the HTTP connection manager. The difference is that this idle timeout
    /// is enforced by the router for each individual attempt and thus after all previous filters have
    /// run, as opposed to *before* all previous filters run for the other idle timeouts. This timeout
    /// is useful in cases in which total request timeout is bounded by a number of retries and a
    /// :ref:`per_try_timeout &lt;envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`, but
    /// there is a desire to ensure each try is making incremental progress. Note also that similar
    /// to :ref:`per_try_timeout &lt;envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
    /// this idle timeout does not start until after both the entire request has been received by the
    /// router *and* a connection pool connection has been obtained. Unlike
    /// :ref:`per_try_timeout &lt;envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
    /// the idle timer continues once the response starts streaming back to the downstream client.
    /// This ensures that response data continues to make progress without using one of the HTTP
    /// connection manager idle timeouts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration PerTryIdleTimeout {
      get { return perTryIdleTimeout_; }
      set {
        perTryIdleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "retry_priority" field.</summary>
    public const int RetryPriorityFieldNumber = 4;
    private global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority retryPriority_;
    /// <summary>
    /// Specifies an implementation of a RetryPriority which is used to determine the
    /// distribution of load across priorities used for retries. Refer to
    /// :ref:`retry plugin configuration &lt;arch_overview_http_retry_plugins>` for more details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority RetryPriority {
      get { return retryPriority_; }
      set {
        retryPriority_ = value;
      }
    }

    /// <summary>Field number for the "retry_host_predicate" field.</summary>
    public const int RetryHostPredicateFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate> _repeated_retryHostPredicate_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate> retryHostPredicate_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate>();
    /// <summary>
    /// Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
    /// for retries. If any of the predicates reject the host, host selection will be reattempted.
    /// Refer to :ref:`retry plugin configuration &lt;arch_overview_http_retry_plugins>` for more
    /// details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryHostPredicate> RetryHostPredicate {
      get { return retryHostPredicate_; }
    }

    /// <summary>Field number for the "retry_options_predicates" field.</summary>
    public const int RetryOptionsPredicatesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.TypedExtensionConfig> _repeated_retryOptionsPredicates_codec
        = pb::FieldCodec.ForMessage(98, global::Envoy.Config.Core.V3.TypedExtensionConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> retryOptionsPredicates_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig>();
    /// <summary>
    /// Retry options predicates that will be applied prior to retrying a request. These predicates
    /// allow customizing request behavior between retries.
    /// [#comment: add [#extension-category: envoy.retry_options_predicates] when there are built-in extensions]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> RetryOptionsPredicates {
      get { return retryOptionsPredicates_; }
    }

    /// <summary>Field number for the "host_selection_retry_max_attempts" field.</summary>
    public const int HostSelectionRetryMaxAttemptsFieldNumber = 6;
    private long hostSelectionRetryMaxAttempts_;
    /// <summary>
    /// The maximum number of times host selection will be reattempted before giving up, at which
    /// point the host that was last selected will be routed to. If unspecified, this will default to
    /// retrying once.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long HostSelectionRetryMaxAttempts {
      get { return hostSelectionRetryMaxAttempts_; }
      set {
        hostSelectionRetryMaxAttempts_ = value;
      }
    }

    /// <summary>Field number for the "retriable_status_codes" field.</summary>
    public const int RetriableStatusCodesFieldNumber = 7;
    private static readonly pb::FieldCodec<uint> _repeated_retriableStatusCodes_codec
        = pb::FieldCodec.ForUInt32(58);
    private readonly pbc::RepeatedField<uint> retriableStatusCodes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> RetriableStatusCodes {
      get { return retriableStatusCodes_; }
    }

    /// <summary>Field number for the "retry_back_off" field.</summary>
    public const int RetryBackOffFieldNumber = 8;
    private global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff retryBackOff_;
    /// <summary>
    /// Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
    /// default base interval is 25 milliseconds or, if set, the current value of the
    /// ``upstream.base_retry_backoff_ms`` runtime parameter. The default maximum interval is 10 times
    /// the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
    /// describes Envoy's back-off algorithm.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff RetryBackOff {
      get { return retryBackOff_; }
      set {
        retryBackOff_ = value;
      }
    }

    /// <summary>Field number for the "rate_limited_retry_back_off" field.</summary>
    public const int RateLimitedRetryBackOffFieldNumber = 11;
    private global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff rateLimitedRetryBackOff_;
    /// <summary>
    /// Specifies parameters that control a retry back-off strategy that is used
    /// when the request is rate limited by the upstream server. The server may
    /// return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
    /// provide feedback to the client on how long to wait before retrying. If
    /// configured, this back-off strategy will be used instead of the
    /// default exponential back off strategy (configured using ``retry_back_off``)
    /// whenever a response includes the matching headers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff RateLimitedRetryBackOff {
      get { return rateLimitedRetryBackOff_; }
      set {
        rateLimitedRetryBackOff_ = value;
      }
    }

    /// <summary>Field number for the "retriable_headers" field.</summary>
    public const int RetriableHeadersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.HeaderMatcher> _repeated_retriableHeaders_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Config.Route.V3.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> retriableHeaders_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher>();
    /// <summary>
    /// HTTP response headers that trigger a retry if present in the response. A retry will be
    /// triggered if any of the header matches match the upstream response headers.
    /// The field is only consulted if 'retriable-headers' retry policy is active.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> RetriableHeaders {
      get { return retriableHeaders_; }
    }

    /// <summary>Field number for the "retriable_request_headers" field.</summary>
    public const int RetriableRequestHeadersFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.HeaderMatcher> _repeated_retriableRequestHeaders_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Config.Route.V3.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> retriableRequestHeaders_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher>();
    /// <summary>
    /// HTTP headers which must be present in the request for retries to be attempted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> RetriableRequestHeaders {
      get { return retriableRequestHeaders_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RetryPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RetryPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RetryOn != other.RetryOn) return false;
      if (NumRetries != other.NumRetries) return false;
      if (!object.Equals(PerTryTimeout, other.PerTryTimeout)) return false;
      if (!object.Equals(PerTryIdleTimeout, other.PerTryIdleTimeout)) return false;
      if (!object.Equals(RetryPriority, other.RetryPriority)) return false;
      if(!retryHostPredicate_.Equals(other.retryHostPredicate_)) return false;
      if(!retryOptionsPredicates_.Equals(other.retryOptionsPredicates_)) return false;
      if (HostSelectionRetryMaxAttempts != other.HostSelectionRetryMaxAttempts) return false;
      if(!retriableStatusCodes_.Equals(other.retriableStatusCodes_)) return false;
      if (!object.Equals(RetryBackOff, other.RetryBackOff)) return false;
      if (!object.Equals(RateLimitedRetryBackOff, other.RateLimitedRetryBackOff)) return false;
      if(!retriableHeaders_.Equals(other.retriableHeaders_)) return false;
      if(!retriableRequestHeaders_.Equals(other.retriableRequestHeaders_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (RetryOn.Length != 0) hash ^= RetryOn.GetHashCode();
      if (numRetries_ != null) hash ^= NumRetries.GetHashCode();
      if (perTryTimeout_ != null) hash ^= PerTryTimeout.GetHashCode();
      if (perTryIdleTimeout_ != null) hash ^= PerTryIdleTimeout.GetHashCode();
      if (retryPriority_ != null) hash ^= RetryPriority.GetHashCode();
      hash ^= retryHostPredicate_.GetHashCode();
      hash ^= retryOptionsPredicates_.GetHashCode();
      if (HostSelectionRetryMaxAttempts != 0L) hash ^= HostSelectionRetryMaxAttempts.GetHashCode();
      hash ^= retriableStatusCodes_.GetHashCode();
      if (retryBackOff_ != null) hash ^= RetryBackOff.GetHashCode();
      if (rateLimitedRetryBackOff_ != null) hash ^= RateLimitedRetryBackOff.GetHashCode();
      hash ^= retriableHeaders_.GetHashCode();
      hash ^= retriableRequestHeaders_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (RetryOn.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RetryOn);
      }
      if (numRetries_ != null) {
        _single_numRetries_codec.WriteTagAndValue(output, NumRetries);
      }
      if (perTryTimeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PerTryTimeout);
      }
      if (retryPriority_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(RetryPriority);
      }
      retryHostPredicate_.WriteTo(output, _repeated_retryHostPredicate_codec);
      if (HostSelectionRetryMaxAttempts != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(HostSelectionRetryMaxAttempts);
      }
      retriableStatusCodes_.WriteTo(output, _repeated_retriableStatusCodes_codec);
      if (retryBackOff_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RetryBackOff);
      }
      retriableHeaders_.WriteTo(output, _repeated_retriableHeaders_codec);
      retriableRequestHeaders_.WriteTo(output, _repeated_retriableRequestHeaders_codec);
      if (rateLimitedRetryBackOff_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RateLimitedRetryBackOff);
      }
      retryOptionsPredicates_.WriteTo(output, _repeated_retryOptionsPredicates_codec);
      if (perTryIdleTimeout_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(PerTryIdleTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (RetryOn.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RetryOn);
      }
      if (numRetries_ != null) {
        _single_numRetries_codec.WriteTagAndValue(ref output, NumRetries);
      }
      if (perTryTimeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PerTryTimeout);
      }
      if (retryPriority_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(RetryPriority);
      }
      retryHostPredicate_.WriteTo(ref output, _repeated_retryHostPredicate_codec);
      if (HostSelectionRetryMaxAttempts != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(HostSelectionRetryMaxAttempts);
      }
      retriableStatusCodes_.WriteTo(ref output, _repeated_retriableStatusCodes_codec);
      if (retryBackOff_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RetryBackOff);
      }
      retriableHeaders_.WriteTo(ref output, _repeated_retriableHeaders_codec);
      retriableRequestHeaders_.WriteTo(ref output, _repeated_retriableRequestHeaders_codec);
      if (rateLimitedRetryBackOff_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(RateLimitedRetryBackOff);
      }
      retryOptionsPredicates_.WriteTo(ref output, _repeated_retryOptionsPredicates_codec);
      if (perTryIdleTimeout_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(PerTryIdleTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (RetryOn.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RetryOn);
      }
      if (numRetries_ != null) {
        size += _single_numRetries_codec.CalculateSizeWithTag(NumRetries);
      }
      if (perTryTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PerTryTimeout);
      }
      if (perTryIdleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PerTryIdleTimeout);
      }
      if (retryPriority_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPriority);
      }
      size += retryHostPredicate_.CalculateSize(_repeated_retryHostPredicate_codec);
      size += retryOptionsPredicates_.CalculateSize(_repeated_retryOptionsPredicates_codec);
      if (HostSelectionRetryMaxAttempts != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HostSelectionRetryMaxAttempts);
      }
      size += retriableStatusCodes_.CalculateSize(_repeated_retriableStatusCodes_codec);
      if (retryBackOff_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryBackOff);
      }
      if (rateLimitedRetryBackOff_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateLimitedRetryBackOff);
      }
      size += retriableHeaders_.CalculateSize(_repeated_retriableHeaders_codec);
      size += retriableRequestHeaders_.CalculateSize(_repeated_retriableRequestHeaders_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RetryPolicy other) {
      if (other == null) {
        return;
      }
      if (other.RetryOn.Length != 0) {
        RetryOn = other.RetryOn;
      }
      if (other.numRetries_ != null) {
        if (numRetries_ == null || other.NumRetries != 0) {
          NumRetries = other.NumRetries;
        }
      }
      if (other.perTryTimeout_ != null) {
        if (perTryTimeout_ == null) {
          PerTryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        PerTryTimeout.MergeFrom(other.PerTryTimeout);
      }
      if (other.perTryIdleTimeout_ != null) {
        if (perTryIdleTimeout_ == null) {
          PerTryIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        PerTryIdleTimeout.MergeFrom(other.PerTryIdleTimeout);
      }
      if (other.retryPriority_ != null) {
        if (retryPriority_ == null) {
          RetryPriority = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority();
        }
        RetryPriority.MergeFrom(other.RetryPriority);
      }
      retryHostPredicate_.Add(other.retryHostPredicate_);
      retryOptionsPredicates_.Add(other.retryOptionsPredicates_);
      if (other.HostSelectionRetryMaxAttempts != 0L) {
        HostSelectionRetryMaxAttempts = other.HostSelectionRetryMaxAttempts;
      }
      retriableStatusCodes_.Add(other.retriableStatusCodes_);
      if (other.retryBackOff_ != null) {
        if (retryBackOff_ == null) {
          RetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff();
        }
        RetryBackOff.MergeFrom(other.RetryBackOff);
      }
      if (other.rateLimitedRetryBackOff_ != null) {
        if (rateLimitedRetryBackOff_ == null) {
          RateLimitedRetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff();
        }
        RateLimitedRetryBackOff.MergeFrom(other.RateLimitedRetryBackOff);
      }
      retriableHeaders_.Add(other.retriableHeaders_);
      retriableRequestHeaders_.Add(other.retriableRequestHeaders_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RetryOn = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_numRetries_codec.Read(input);
            if (numRetries_ == null || value != 0) {
              NumRetries = value;
            }
            break;
          }
          case 26: {
            if (perTryTimeout_ == null) {
              PerTryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PerTryTimeout);
            break;
          }
          case 34: {
            if (retryPriority_ == null) {
              RetryPriority = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority();
            }
            input.ReadMessage(RetryPriority);
            break;
          }
          case 42: {
            retryHostPredicate_.AddEntriesFrom(input, _repeated_retryHostPredicate_codec);
            break;
          }
          case 48: {
            HostSelectionRetryMaxAttempts = input.ReadInt64();
            break;
          }
          case 58:
          case 56: {
            retriableStatusCodes_.AddEntriesFrom(input, _repeated_retriableStatusCodes_codec);
            break;
          }
          case 66: {
            if (retryBackOff_ == null) {
              RetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff();
            }
            input.ReadMessage(RetryBackOff);
            break;
          }
          case 74: {
            retriableHeaders_.AddEntriesFrom(input, _repeated_retriableHeaders_codec);
            break;
          }
          case 82: {
            retriableRequestHeaders_.AddEntriesFrom(input, _repeated_retriableRequestHeaders_codec);
            break;
          }
          case 90: {
            if (rateLimitedRetryBackOff_ == null) {
              RateLimitedRetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff();
            }
            input.ReadMessage(RateLimitedRetryBackOff);
            break;
          }
          case 98: {
            retryOptionsPredicates_.AddEntriesFrom(input, _repeated_retryOptionsPredicates_codec);
            break;
          }
          case 106: {
            if (perTryIdleTimeout_ == null) {
              PerTryIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PerTryIdleTimeout);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RetryOn = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_numRetries_codec.Read(ref input);
            if (numRetries_ == null || value != 0) {
              NumRetries = value;
            }
            break;
          }
          case 26: {
            if (perTryTimeout_ == null) {
              PerTryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PerTryTimeout);
            break;
          }
          case 34: {
            if (retryPriority_ == null) {
              RetryPriority = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryPriority();
            }
            input.ReadMessage(RetryPriority);
            break;
          }
          case 42: {
            retryHostPredicate_.AddEntriesFrom(ref input, _repeated_retryHostPredicate_codec);
            break;
          }
          case 48: {
            HostSelectionRetryMaxAttempts = input.ReadInt64();
            break;
          }
          case 58:
          case 56: {
            retriableStatusCodes_.AddEntriesFrom(ref input, _repeated_retriableStatusCodes_codec);
            break;
          }
          case 66: {
            if (retryBackOff_ == null) {
              RetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RetryBackOff();
            }
            input.ReadMessage(RetryBackOff);
            break;
          }
          case 74: {
            retriableHeaders_.AddEntriesFrom(ref input, _repeated_retriableHeaders_codec);
            break;
          }
          case 82: {
            retriableRequestHeaders_.AddEntriesFrom(ref input, _repeated_retriableRequestHeaders_codec);
            break;
          }
          case 90: {
            if (rateLimitedRetryBackOff_ == null) {
              RateLimitedRetryBackOff = new global::Envoy.Config.Route.V3.RetryPolicy.Types.RateLimitedRetryBackOff();
            }
            input.ReadMessage(RateLimitedRetryBackOff);
            break;
          }
          case 98: {
            retryOptionsPredicates_.AddEntriesFrom(ref input, _repeated_retryOptionsPredicates_codec);
            break;
          }
          case 106: {
            if (perTryIdleTimeout_ == null) {
              PerTryIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PerTryIdleTimeout);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RetryPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum ResetHeaderFormat {
        [pbr::OriginalName("SECONDS")] Seconds = 0,
        [pbr::OriginalName("UNIX_TIMESTAMP")] UnixTimestamp = 1,
      }

      public sealed partial class RetryPriority : pb::IMessage<RetryPriority>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RetryPriority> _parser = new pb::MessageParser<RetryPriority>(() => new RetryPriority());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RetryPriority> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RetryPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryPriority() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryPriority(RetryPriority other) : this() {
          name_ = other.name_;
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryPriority Clone() {
          return new RetryPriority(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
          }
        }

        private object configType_;
        /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
        public enum ConfigTypeOneofCase {
          None = 0,
          TypedConfig = 3,
        }
        private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConfigTypeOneofCase ConfigTypeCase {
          get { return configTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearConfigType() {
          configTypeCase_ = ConfigTypeOneofCase.None;
          configType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RetryPriority);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RetryPriority other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigTypeCase != other.ConfigTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RetryPriority other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class RetryHostPredicate : pb::IMessage<RetryHostPredicate>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RetryHostPredicate> _parser = new pb::MessageParser<RetryHostPredicate>(() => new RetryHostPredicate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RetryHostPredicate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RetryPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryHostPredicate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryHostPredicate(RetryHostPredicate other) : this() {
          name_ = other.name_;
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryHostPredicate Clone() {
          return new RetryHostPredicate(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
          }
        }

        private object configType_;
        /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
        public enum ConfigTypeOneofCase {
          None = 0,
          TypedConfig = 3,
        }
        private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConfigTypeOneofCase ConfigTypeCase {
          get { return configTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearConfigType() {
          configTypeCase_ = ConfigTypeOneofCase.None;
          configType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RetryHostPredicate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RetryHostPredicate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigTypeCase != other.ConfigTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RetryHostPredicate other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class RetryBackOff : pb::IMessage<RetryBackOff>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RetryBackOff> _parser = new pb::MessageParser<RetryBackOff>(() => new RetryBackOff());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RetryBackOff> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RetryPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryBackOff() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryBackOff(RetryBackOff other) : this() {
          baseInterval_ = other.baseInterval_ != null ? other.baseInterval_.Clone() : null;
          maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RetryBackOff Clone() {
          return new RetryBackOff(this);
        }

        /// <summary>Field number for the "base_interval" field.</summary>
        public const int BaseIntervalFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration baseInterval_;
        /// <summary>
        /// Specifies the base interval between retries. This parameter is required and must be greater
        /// than zero. Values less than 1 ms are rounded up to 1 ms.
        /// See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
        /// back-off algorithm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration BaseInterval {
          get { return baseInterval_; }
          set {
            baseInterval_ = value;
          }
        }

        /// <summary>Field number for the "max_interval" field.</summary>
        public const int MaxIntervalFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
        /// <summary>
        /// Specifies the maximum interval between retries. This parameter is optional, but must be
        /// greater than or equal to the ``base_interval`` if set. The default is 10 times the
        /// ``base_interval``. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
        /// of Envoy's back-off algorithm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
          get { return maxInterval_; }
          set {
            maxInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RetryBackOff);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RetryBackOff other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BaseInterval, other.BaseInterval)) return false;
          if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (baseInterval_ != null) hash ^= BaseInterval.GetHashCode();
          if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (baseInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseInterval);
          }
          if (maxInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RetryBackOff other) {
          if (other == null) {
            return;
          }
          if (other.baseInterval_ != null) {
            if (baseInterval_ == null) {
              BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BaseInterval.MergeFrom(other.BaseInterval);
          }
          if (other.maxInterval_ != null) {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterval.MergeFrom(other.MaxInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        }
        #endif

      }

      public sealed partial class ResetHeader : pb::IMessage<ResetHeader>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ResetHeader> _parser = new pb::MessageParser<ResetHeader>(() => new ResetHeader());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ResetHeader> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RetryPolicy.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ResetHeader() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ResetHeader(ResetHeader other) : this() {
          name_ = other.name_;
          format_ = other.format_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ResetHeader Clone() {
          return new ResetHeader(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the reset header.
        ///
        /// .. note::
        ///
        ///   If the header appears multiple times only the first value is used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "format" field.</summary>
        public const int FormatFieldNumber = 2;
        private global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat format_ = global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds;
        /// <summary>
        /// The format of the reset header.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat Format {
          get { return format_; }
          set {
            format_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ResetHeader);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ResetHeader other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Format != other.Format) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Format != global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds) hash ^= Format.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Format != global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Format);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Format != global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Format);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Format != global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ResetHeader other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Format != global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat.Seconds) {
            Format = other.Format;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Format = (global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Format = (global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeaderFormat) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A retry back-off strategy that applies when the upstream server rate limits
      /// the request.
      ///
      /// Given this configuration:
      ///
      /// .. code-block:: yaml
      ///
      ///   rate_limited_retry_back_off:
      ///     reset_headers:
      ///     - name: Retry-After
      ///       format: SECONDS
      ///     - name: X-RateLimit-Reset
      ///       format: UNIX_TIMESTAMP
      ///     max_interval: "300s"
      ///
      /// The following algorithm will apply:
      ///
      ///  1. If the response contains the header ``Retry-After`` its value must be on
      ///     the form ``120`` (an integer that represents the number of seconds to
      ///     wait before retrying). If so, this value is used as the back-off interval.
      ///  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
      ///     value must be on the form ``1595320702`` (an integer that represents the
      ///     point in time at which to retry, as a Unix timestamp in seconds). If so,
      ///     the current time is subtracted from this value and the result is used as
      ///     the back-off interval.
      ///  3. Otherwise, Envoy will use the default
      ///     :ref:`exponential back-off &lt;envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
      ///     strategy.
      ///
      /// No matter which format is used, if the resulting back-off interval exceeds
      /// ``max_interval`` it is discarded and the next header in ``reset_headers``
      /// is tried. If a request timeout is configured for the route it will further
      /// limit how long the request will be allowed to run.
      ///
      /// To prevent many clients retrying at the same point in time jitter is added
      /// to the back-off interval, so the resulting interval is decided by taking:
      /// ``random(interval, interval * 1.5)``.
      ///
      /// .. attention::
      ///
      ///   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
      ///   to be retried. You will still need to configure the right retry policy to match
      ///   the responses from the upstream server.
      /// </summary>
      public sealed partial class RateLimitedRetryBackOff : pb::IMessage<RateLimitedRetryBackOff>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RateLimitedRetryBackOff> _parser = new pb::MessageParser<RateLimitedRetryBackOff>(() => new RateLimitedRetryBackOff());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RateLimitedRetryBackOff> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RetryPolicy.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RateLimitedRetryBackOff() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RateLimitedRetryBackOff(RateLimitedRetryBackOff other) : this() {
          resetHeaders_ = other.resetHeaders_.Clone();
          maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RateLimitedRetryBackOff Clone() {
          return new RateLimitedRetryBackOff(this);
        }

        /// <summary>Field number for the "reset_headers" field.</summary>
        public const int ResetHeadersFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader> _repeated_resetHeaders_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader> resetHeaders_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader>();
        /// <summary>
        /// Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
        /// to match against the response. Headers are tried in order, and matched case
        /// insensitive. The first header to be parsed successfully is used. If no headers
        /// match the default exponential back-off is used instead.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Envoy.Config.Route.V3.RetryPolicy.Types.ResetHeader> ResetHeaders {
          get { return resetHeaders_; }
        }

        /// <summary>Field number for the "max_interval" field.</summary>
        public const int MaxIntervalFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
        /// <summary>
        /// Specifies the maximum back off interval that Envoy will allow. If a reset
        /// header contains an interval longer than this then it will be discarded and
        /// the next header will be tried. Defaults to 300 seconds.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
          get { return maxInterval_; }
          set {
            maxInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RateLimitedRetryBackOff);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RateLimitedRetryBackOff other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!resetHeaders_.Equals(other.resetHeaders_)) return false;
          if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= resetHeaders_.GetHashCode();
          if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          resetHeaders_.WriteTo(output, _repeated_resetHeaders_codec);
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          resetHeaders_.WriteTo(ref output, _repeated_resetHeaders_codec);
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += resetHeaders_.CalculateSize(_repeated_resetHeaders_codec);
          if (maxInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RateLimitedRetryBackOff other) {
          if (other == null) {
            return;
          }
          resetHeaders_.Add(other.resetHeaders_);
          if (other.maxInterval_ != null) {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterval.MergeFrom(other.MaxInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                resetHeaders_.AddEntriesFrom(input, _repeated_resetHeaders_codec);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                resetHeaders_.AddEntriesFrom(ref input, _repeated_resetHeaders_codec);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// HTTP request hedging :ref:`architecture overview &lt;arch_overview_http_routing_hedging>`.
  /// </summary>
  public sealed partial class HedgePolicy : pb::IMessage<HedgePolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HedgePolicy> _parser = new pb::MessageParser<HedgePolicy>(() => new HedgePolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HedgePolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HedgePolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HedgePolicy(HedgePolicy other) : this() {
      InitialRequests = other.InitialRequests;
      additionalRequestChance_ = other.additionalRequestChance_ != null ? other.additionalRequestChance_.Clone() : null;
      hedgeOnPerTryTimeout_ = other.hedgeOnPerTryTimeout_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HedgePolicy Clone() {
      return new HedgePolicy(this);
    }

    /// <summary>Field number for the "initial_requests" field.</summary>
    public const int InitialRequestsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_initialRequests_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? initialRequests_;
    /// <summary>
    /// Specifies the number of initial requests that should be sent upstream.
    /// Must be at least 1.
    /// Defaults to 1.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? InitialRequests {
      get { return initialRequests_; }
      set {
        initialRequests_ = value;
      }
    }


    /// <summary>Field number for the "additional_request_chance" field.</summary>
    public const int AdditionalRequestChanceFieldNumber = 2;
    private global::Envoy.Type.V3.FractionalPercent additionalRequestChance_;
    /// <summary>
    /// Specifies a probability that an additional upstream request should be sent
    /// on top of what is specified by initial_requests.
    /// Defaults to 0.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.FractionalPercent AdditionalRequestChance {
      get { return additionalRequestChance_; }
      set {
        additionalRequestChance_ = value;
      }
    }

    /// <summary>Field number for the "hedge_on_per_try_timeout" field.</summary>
    public const int HedgeOnPerTryTimeoutFieldNumber = 3;
    private bool hedgeOnPerTryTimeout_;
    /// <summary>
    /// Indicates that a hedged request should be sent when the per-try timeout is hit.
    /// This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
    /// The first request to complete successfully will be the one returned to the caller.
    ///
    /// * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
    /// * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
    ///   if there are no more retries left.
    /// * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
    ///
    /// Note: For this to have effect, you must have a :ref:`RetryPolicy &lt;envoy_v3_api_msg_config.route.v3.RetryPolicy>` that retries at least
    /// one error code and specifies a maximum number of retries.
    ///
    /// Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HedgeOnPerTryTimeout {
      get { return hedgeOnPerTryTimeout_; }
      set {
        hedgeOnPerTryTimeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HedgePolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HedgePolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InitialRequests != other.InitialRequests) return false;
      if (!object.Equals(AdditionalRequestChance, other.AdditionalRequestChance)) return false;
      if (HedgeOnPerTryTimeout != other.HedgeOnPerTryTimeout) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (initialRequests_ != null) hash ^= InitialRequests.GetHashCode();
      if (additionalRequestChance_ != null) hash ^= AdditionalRequestChance.GetHashCode();
      if (HedgeOnPerTryTimeout != false) hash ^= HedgeOnPerTryTimeout.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (initialRequests_ != null) {
        _single_initialRequests_codec.WriteTagAndValue(output, InitialRequests);
      }
      if (additionalRequestChance_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdditionalRequestChance);
      }
      if (HedgeOnPerTryTimeout != false) {
        output.WriteRawTag(24);
        output.WriteBool(HedgeOnPerTryTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (initialRequests_ != null) {
        _single_initialRequests_codec.WriteTagAndValue(ref output, InitialRequests);
      }
      if (additionalRequestChance_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdditionalRequestChance);
      }
      if (HedgeOnPerTryTimeout != false) {
        output.WriteRawTag(24);
        output.WriteBool(HedgeOnPerTryTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (initialRequests_ != null) {
        size += _single_initialRequests_codec.CalculateSizeWithTag(InitialRequests);
      }
      if (additionalRequestChance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdditionalRequestChance);
      }
      if (HedgeOnPerTryTimeout != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HedgePolicy other) {
      if (other == null) {
        return;
      }
      if (other.initialRequests_ != null) {
        if (initialRequests_ == null || other.InitialRequests != 0) {
          InitialRequests = other.InitialRequests;
        }
      }
      if (other.additionalRequestChance_ != null) {
        if (additionalRequestChance_ == null) {
          AdditionalRequestChance = new global::Envoy.Type.V3.FractionalPercent();
        }
        AdditionalRequestChance.MergeFrom(other.AdditionalRequestChance);
      }
      if (other.HedgeOnPerTryTimeout != false) {
        HedgeOnPerTryTimeout = other.HedgeOnPerTryTimeout;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_initialRequests_codec.Read(input);
            if (initialRequests_ == null || value != 0) {
              InitialRequests = value;
            }
            break;
          }
          case 18: {
            if (additionalRequestChance_ == null) {
              AdditionalRequestChance = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(AdditionalRequestChance);
            break;
          }
          case 24: {
            HedgeOnPerTryTimeout = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_initialRequests_codec.Read(ref input);
            if (initialRequests_ == null || value != 0) {
              InitialRequests = value;
            }
            break;
          }
          case 18: {
            if (additionalRequestChance_ == null) {
              AdditionalRequestChance = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(AdditionalRequestChance);
            break;
          }
          case 24: {
            HedgeOnPerTryTimeout = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#next-free-field: 10]
  /// </summary>
  public sealed partial class RedirectAction : pb::IMessage<RedirectAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RedirectAction> _parser = new pb::MessageParser<RedirectAction>(() => new RedirectAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RedirectAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RedirectAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RedirectAction(RedirectAction other) : this() {
      hostRedirect_ = other.hostRedirect_;
      portRedirect_ = other.portRedirect_;
      responseCode_ = other.responseCode_;
      stripQuery_ = other.stripQuery_;
      switch (other.SchemeRewriteSpecifierCase) {
        case SchemeRewriteSpecifierOneofCase.HttpsRedirect:
          HttpsRedirect = other.HttpsRedirect;
          break;
        case SchemeRewriteSpecifierOneofCase.SchemeRedirect:
          SchemeRedirect = other.SchemeRedirect;
          break;
      }

      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
        case PathRewriteSpecifierOneofCase.RegexRewrite:
          RegexRewrite = other.RegexRewrite.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RedirectAction Clone() {
      return new RedirectAction(this);
    }

    /// <summary>Field number for the "https_redirect" field.</summary>
    public const int HttpsRedirectFieldNumber = 4;
    /// <summary>
    /// The scheme portion of the URL will be swapped with "https".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HttpsRedirect {
      get { return schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect ? (bool) schemeRewriteSpecifier_ : false; }
      set {
        schemeRewriteSpecifier_ = value;
        schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.HttpsRedirect;
      }
    }

    /// <summary>Field number for the "scheme_redirect" field.</summary>
    public const int SchemeRedirectFieldNumber = 7;
    /// <summary>
    /// The scheme portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SchemeRedirect {
      get { return schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect ? (string) schemeRewriteSpecifier_ : ""; }
      set {
        schemeRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.SchemeRedirect;
      }
    }

    /// <summary>Field number for the "host_redirect" field.</summary>
    public const int HostRedirectFieldNumber = 1;
    private string hostRedirect_ = "";
    /// <summary>
    /// The host portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostRedirect {
      get { return hostRedirect_; }
      set {
        hostRedirect_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port_redirect" field.</summary>
    public const int PortRedirectFieldNumber = 8;
    private uint portRedirect_;
    /// <summary>
    /// The port value of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PortRedirect {
      get { return portRedirect_; }
      set {
        portRedirect_ = value;
      }
    }

    /// <summary>Field number for the "path_redirect" field.</summary>
    public const int PathRedirectFieldNumber = 2;
    /// <summary>
    /// The path portion of the URL will be swapped with this value.
    /// Please note that query string in path_redirect will override the
    /// request's query string and will not be stripped.
    ///
    /// For example, let's say we have the following routes:
    ///
    /// - match: { path: "/old-path-1" }
    ///   redirect: { path_redirect: "/new-path-1" }
    /// - match: { path: "/old-path-2" }
    ///   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
    /// - match: { path: "/old-path-3" }
    ///   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
    ///
    /// 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
    /// 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
    /// 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PathRedirect {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PathRedirect;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    /// <summary>
    /// Indicates that during redirection, the matched prefix (or path)
    /// should be swapped with this value. This option allows redirect URLs be dynamically created
    /// based on the request.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the use of trailing slashes as mentioned in
    ///   :ref:`RouteAction's prefix_rewrite &lt;envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PrefixRewrite {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PrefixRewrite;
      }
    }

    /// <summary>Field number for the "regex_rewrite" field.</summary>
    public const int RegexRewriteFieldNumber = 9;
    /// <summary>
    /// Indicates that during redirect, portions of the path that match the
    /// pattern should be rewritten, even allowing the substitution of capture
    /// groups from the pattern into the new path as specified by the rewrite
    /// substitution string. This is useful to allow application paths to be
    /// rewritten in a way that is aware of segments with variable content like
    /// identifiers.
    ///
    /// Examples using Google's `RE2 &lt;https://github.com/google/re2>`_ engine:
    ///
    /// * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
    ///   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
    ///   into ``/v1/api/instance/foo``.
    ///
    /// * The pattern ``one`` paired with a substitution string of ``two`` would
    ///   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
    ///
    /// * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
    ///   ``\1two\2`` would replace only the first occurrence of ``one``,
    ///   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
    ///
    /// * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
    ///   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
    ///   ``/aaa/yyy/bbb``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute RegexRewrite {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite ? (global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute) pathRewriteSpecifier_ : null; }
      set {
        pathRewriteSpecifier_ = value;
        pathRewriteSpecifierCase_ = value == null ? PathRewriteSpecifierOneofCase.None : PathRewriteSpecifierOneofCase.RegexRewrite;
      }
    }

    /// <summary>Field number for the "response_code" field.</summary>
    public const int ResponseCodeFieldNumber = 3;
    private global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode responseCode_ = global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently;
    /// <summary>
    /// The HTTP status code to use in the redirect response. The default response
    /// code is MOVED_PERMANENTLY (301).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode ResponseCode {
      get { return responseCode_; }
      set {
        responseCode_ = value;
      }
    }

    /// <summary>Field number for the "strip_query" field.</summary>
    public const int StripQueryFieldNumber = 6;
    private bool stripQuery_;
    /// <summary>
    /// Indicates that during redirection, the query portion of the URL will
    /// be removed. Default value is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StripQuery {
      get { return stripQuery_; }
      set {
        stripQuery_ = value;
      }
    }

    private object schemeRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "scheme_rewrite_specifier" oneof.</summary>
    public enum SchemeRewriteSpecifierOneofCase {
      None = 0,
      HttpsRedirect = 4,
      SchemeRedirect = 7,
    }
    private SchemeRewriteSpecifierOneofCase schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchemeRewriteSpecifierOneofCase SchemeRewriteSpecifierCase {
      get { return schemeRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSchemeRewriteSpecifier() {
      schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.None;
      schemeRewriteSpecifier_ = null;
    }

    private object pathRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "path_rewrite_specifier" oneof.</summary>
    public enum PathRewriteSpecifierOneofCase {
      None = 0,
      PathRedirect = 2,
      PrefixRewrite = 5,
      RegexRewrite = 9,
    }
    private PathRewriteSpecifierOneofCase pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PathRewriteSpecifierOneofCase PathRewriteSpecifierCase {
      get { return pathRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPathRewriteSpecifier() {
      pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
      pathRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RedirectAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RedirectAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HttpsRedirect != other.HttpsRedirect) return false;
      if (SchemeRedirect != other.SchemeRedirect) return false;
      if (HostRedirect != other.HostRedirect) return false;
      if (PortRedirect != other.PortRedirect) return false;
      if (PathRedirect != other.PathRedirect) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (!object.Equals(RegexRewrite, other.RegexRewrite)) return false;
      if (ResponseCode != other.ResponseCode) return false;
      if (StripQuery != other.StripQuery) return false;
      if (SchemeRewriteSpecifierCase != other.SchemeRewriteSpecifierCase) return false;
      if (PathRewriteSpecifierCase != other.PathRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) hash ^= HttpsRedirect.GetHashCode();
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) hash ^= SchemeRedirect.GetHashCode();
      if (HostRedirect.Length != 0) hash ^= HostRedirect.GetHashCode();
      if (PortRedirect != 0) hash ^= PortRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) hash ^= PathRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) hash ^= PrefixRewrite.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) hash ^= RegexRewrite.GetHashCode();
      if (ResponseCode != global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently) hash ^= ResponseCode.GetHashCode();
      if (StripQuery != false) hash ^= StripQuery.GetHashCode();
      hash ^= (int) schemeRewriteSpecifierCase_;
      hash ^= (int) pathRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HostRedirect.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(HostRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        output.WriteRawTag(18);
        output.WriteString(PathRedirect);
      }
      if (ResponseCode != global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ResponseCode);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) {
        output.WriteRawTag(32);
        output.WriteBool(HttpsRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (StripQuery != false) {
        output.WriteRawTag(48);
        output.WriteBool(StripQuery);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) {
        output.WriteRawTag(58);
        output.WriteString(SchemeRedirect);
      }
      if (PortRedirect != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(PortRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) {
        output.WriteRawTag(74);
        output.WriteMessage(RegexRewrite);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HostRedirect.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(HostRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        output.WriteRawTag(18);
        output.WriteString(PathRedirect);
      }
      if (ResponseCode != global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ResponseCode);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) {
        output.WriteRawTag(32);
        output.WriteBool(HttpsRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (StripQuery != false) {
        output.WriteRawTag(48);
        output.WriteBool(StripQuery);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) {
        output.WriteRawTag(58);
        output.WriteString(SchemeRedirect);
      }
      if (PortRedirect != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(PortRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) {
        output.WriteRawTag(74);
        output.WriteMessage(RegexRewrite);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) {
        size += 1 + 1;
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemeRedirect);
      }
      if (HostRedirect.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRedirect);
      }
      if (PortRedirect != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PortRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RegexRewrite);
      }
      if (ResponseCode != global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResponseCode);
      }
      if (StripQuery != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RedirectAction other) {
      if (other == null) {
        return;
      }
      if (other.HostRedirect.Length != 0) {
        HostRedirect = other.HostRedirect;
      }
      if (other.PortRedirect != 0) {
        PortRedirect = other.PortRedirect;
      }
      if (other.ResponseCode != global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        ResponseCode = other.ResponseCode;
      }
      if (other.StripQuery != false) {
        StripQuery = other.StripQuery;
      }
      switch (other.SchemeRewriteSpecifierCase) {
        case SchemeRewriteSpecifierOneofCase.HttpsRedirect:
          HttpsRedirect = other.HttpsRedirect;
          break;
        case SchemeRewriteSpecifierOneofCase.SchemeRedirect:
          SchemeRedirect = other.SchemeRedirect;
          break;
      }

      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
        case PathRewriteSpecifierOneofCase.RegexRewrite:
          if (RegexRewrite == null) {
            RegexRewrite = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
          }
          RegexRewrite.MergeFrom(other.RegexRewrite);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            HostRedirect = input.ReadString();
            break;
          }
          case 18: {
            PathRedirect = input.ReadString();
            break;
          }
          case 24: {
            ResponseCode = (global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode) input.ReadEnum();
            break;
          }
          case 32: {
            HttpsRedirect = input.ReadBool();
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 48: {
            StripQuery = input.ReadBool();
            break;
          }
          case 58: {
            SchemeRedirect = input.ReadString();
            break;
          }
          case 64: {
            PortRedirect = input.ReadUInt32();
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) {
              subBuilder.MergeFrom(RegexRewrite);
            }
            input.ReadMessage(subBuilder);
            RegexRewrite = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            HostRedirect = input.ReadString();
            break;
          }
          case 18: {
            PathRedirect = input.ReadString();
            break;
          }
          case 24: {
            ResponseCode = (global::Envoy.Config.Route.V3.RedirectAction.Types.RedirectResponseCode) input.ReadEnum();
            break;
          }
          case 32: {
            HttpsRedirect = input.ReadBool();
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 48: {
            StripQuery = input.ReadBool();
            break;
          }
          case 58: {
            SchemeRedirect = input.ReadString();
            break;
          }
          case 64: {
            PortRedirect = input.ReadUInt32();
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatchAndSubstitute();
            if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.RegexRewrite) {
              subBuilder.MergeFrom(RegexRewrite);
            }
            input.ReadMessage(subBuilder);
            RegexRewrite = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RedirectAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum RedirectResponseCode {
        /// <summary>
        /// Moved Permanently HTTP Status Code - 301.
        /// </summary>
        [pbr::OriginalName("MOVED_PERMANENTLY")] MovedPermanently = 0,
        /// <summary>
        /// Found HTTP Status Code - 302.
        /// </summary>
        [pbr::OriginalName("FOUND")] Found = 1,
        /// <summary>
        /// See Other HTTP Status Code - 303.
        /// </summary>
        [pbr::OriginalName("SEE_OTHER")] SeeOther = 2,
        /// <summary>
        /// Temporary Redirect HTTP Status Code - 307.
        /// </summary>
        [pbr::OriginalName("TEMPORARY_REDIRECT")] TemporaryRedirect = 3,
        /// <summary>
        /// Permanent Redirect HTTP Status Code - 308.
        /// </summary>
        [pbr::OriginalName("PERMANENT_REDIRECT")] PermanentRedirect = 4,
      }

    }
    #endregion

  }

  public sealed partial class DirectResponseAction : pb::IMessage<DirectResponseAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DirectResponseAction> _parser = new pb::MessageParser<DirectResponseAction>(() => new DirectResponseAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DirectResponseAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DirectResponseAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DirectResponseAction(DirectResponseAction other) : this() {
      status_ = other.status_;
      body_ = other.body_ != null ? other.body_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DirectResponseAction Clone() {
      return new DirectResponseAction(this);
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 1;
    private uint status_;
    /// <summary>
    /// Specifies the HTTP response status to be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 2;
    private global::Envoy.Config.Core.V3.DataSource body_;
    /// <summary>
    /// Specifies the content of the response body. If this setting is omitted,
    /// no body is included in the generated response.
    ///
    /// .. note::
    ///
    ///   Headers can be specified using ``response_headers_to_add`` in the enclosing
    ///   :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or
    ///   :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Core.V3.DataSource Body {
      get { return body_; }
      set {
        body_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DirectResponseAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DirectResponseAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      if (!object.Equals(Body, other.Body)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != 0) hash ^= Status.GetHashCode();
      if (body_ != null) hash ^= Body.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Status);
      }
      if (body_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Body);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Status);
      }
      if (body_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Body);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Status);
      }
      if (body_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Body);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DirectResponseAction other) {
      if (other == null) {
        return;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.body_ != null) {
        if (body_ == null) {
          Body = new global::Envoy.Config.Core.V3.DataSource();
        }
        Body.MergeFrom(other.Body);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = input.ReadUInt32();
            break;
          }
          case 18: {
            if (body_ == null) {
              Body = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Body);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Status = input.ReadUInt32();
            break;
          }
          case 18: {
            if (body_ == null) {
              Body = new global::Envoy.Config.Core.V3.DataSource();
            }
            input.ReadMessage(Body);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class NonForwardingAction : pb::IMessage<NonForwardingAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NonForwardingAction> _parser = new pb::MessageParser<NonForwardingAction>(() => new NonForwardingAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NonForwardingAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NonForwardingAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NonForwardingAction(NonForwardingAction other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NonForwardingAction Clone() {
      return new NonForwardingAction(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NonForwardingAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NonForwardingAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NonForwardingAction other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  public sealed partial class Decorator : pb::IMessage<Decorator>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Decorator> _parser = new pb::MessageParser<Decorator>(() => new Decorator());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Decorator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Decorator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Decorator(Decorator other) : this() {
      operation_ = other.operation_;
      Propagate = other.Propagate;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Decorator Clone() {
      return new Decorator(this);
    }

    /// <summary>Field number for the "operation" field.</summary>
    public const int OperationFieldNumber = 1;
    private string operation_ = "";
    /// <summary>
    /// The operation name associated with the request matched to this route. If tracing is
    /// enabled, this information will be used as the span name reported for this request.
    ///
    /// .. note::
    ///
    ///   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
    ///   by the :ref:`x-envoy-decorator-operation
    ///   &lt;config_http_filters_router_x-envoy-decorator-operation>` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Operation {
      get { return operation_; }
      set {
        operation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "propagate" field.</summary>
    public const int PropagateFieldNumber = 2;
    private static readonly pb::FieldCodec<bool?> _single_propagate_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
    private bool? propagate_;
    /// <summary>
    /// Whether the decorated details should be propagated to the other party. The default is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool? Propagate {
      get { return propagate_; }
      set {
        propagate_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Decorator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Decorator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Operation != other.Operation) return false;
      if (Propagate != other.Propagate) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Operation.Length != 0) hash ^= Operation.GetHashCode();
      if (propagate_ != null) hash ^= Propagate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Operation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Operation);
      }
      if (propagate_ != null) {
        _single_propagate_codec.WriteTagAndValue(output, Propagate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Operation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Operation);
      }
      if (propagate_ != null) {
        _single_propagate_codec.WriteTagAndValue(ref output, Propagate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Operation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operation);
      }
      if (propagate_ != null) {
        size += _single_propagate_codec.CalculateSizeWithTag(Propagate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Decorator other) {
      if (other == null) {
        return;
      }
      if (other.Operation.Length != 0) {
        Operation = other.Operation;
      }
      if (other.propagate_ != null) {
        if (propagate_ == null || other.Propagate != false) {
          Propagate = other.Propagate;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Operation = input.ReadString();
            break;
          }
          case 18: {
            bool? value = _single_propagate_codec.Read(input);
            if (propagate_ == null || value != false) {
              Propagate = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Operation = input.ReadString();
            break;
          }
          case 18: {
            bool? value = _single_propagate_codec.Read(ref input);
            if (propagate_ == null || value != false) {
              Propagate = value;
            }
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Tracing : pb::IMessage<Tracing>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tracing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tracing(Tracing other) : this() {
      clientSampling_ = other.clientSampling_ != null ? other.clientSampling_.Clone() : null;
      randomSampling_ = other.randomSampling_ != null ? other.randomSampling_.Clone() : null;
      overallSampling_ = other.overallSampling_ != null ? other.overallSampling_.Clone() : null;
      customTags_ = other.customTags_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tracing Clone() {
      return new Tracing(this);
    }

    /// <summary>Field number for the "client_sampling" field.</summary>
    public const int ClientSamplingFieldNumber = 1;
    private global::Envoy.Type.V3.FractionalPercent clientSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be force
    /// traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id>`
    /// header is set. This field is a direct analog for the runtime variable
    /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
    /// &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.FractionalPercent ClientSampling {
      get { return clientSampling_; }
      set {
        clientSampling_ = value;
      }
    }

    /// <summary>Field number for the "random_sampling" field.</summary>
    public const int RandomSamplingFieldNumber = 2;
    private global::Envoy.Type.V3.FractionalPercent randomSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be randomly
    /// selected for trace generation, if not requested by the client or not forced. This field is
    /// a direct analog for the runtime variable 'tracing.random_sampling' in the
    /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.FractionalPercent RandomSampling {
      get { return randomSampling_; }
      set {
        randomSampling_ = value;
      }
    }

    /// <summary>Field number for the "overall_sampling" field.</summary>
    public const int OverallSamplingFieldNumber = 3;
    private global::Envoy.Type.V3.FractionalPercent overallSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be traced
    /// after all other sampling checks have been applied (client-directed, force tracing, random
    /// sampling). This field functions as an upper limit on the total configured sampling rate. For
    /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
    /// of client requests with the appropriate headers to be force traced. This field is a direct
    /// analog for the runtime variable 'tracing.global_enabled' in the
    /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.FractionalPercent OverallSampling {
      get { return overallSampling_; }
      set {
        overallSampling_ = value;
      }
    }

    /// <summary>Field number for the "custom_tags" field.</summary>
    public const int CustomTagsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Type.Tracing.V3.CustomTag> _repeated_customTags_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Type.Tracing.V3.CustomTag.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag> customTags_ = new pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag>();
    /// <summary>
    /// A list of custom tags with unique tag name to create tags for the active span.
    /// It will take effect after merging with the :ref:`corresponding configuration
    /// &lt;envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
    /// configured in the HTTP connection manager. If two tags with the same name are configured
    /// each in the HTTP connection manager and the route level, the one configured here takes
    /// priority.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Type.Tracing.V3.CustomTag> CustomTags {
      get { return customTags_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Tracing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Tracing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ClientSampling, other.ClientSampling)) return false;
      if (!object.Equals(RandomSampling, other.RandomSampling)) return false;
      if (!object.Equals(OverallSampling, other.OverallSampling)) return false;
      if(!customTags_.Equals(other.customTags_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (clientSampling_ != null) hash ^= ClientSampling.GetHashCode();
      if (randomSampling_ != null) hash ^= RandomSampling.GetHashCode();
      if (overallSampling_ != null) hash ^= OverallSampling.GetHashCode();
      hash ^= customTags_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (clientSampling_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientSampling);
      }
      if (randomSampling_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RandomSampling);
      }
      if (overallSampling_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(OverallSampling);
      }
      customTags_.WriteTo(output, _repeated_customTags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (clientSampling_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientSampling);
      }
      if (randomSampling_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RandomSampling);
      }
      if (overallSampling_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(OverallSampling);
      }
      customTags_.WriteTo(ref output, _repeated_customTags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (clientSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientSampling);
      }
      if (randomSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomSampling);
      }
      if (overallSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverallSampling);
      }
      size += customTags_.CalculateSize(_repeated_customTags_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Tracing other) {
      if (other == null) {
        return;
      }
      if (other.clientSampling_ != null) {
        if (clientSampling_ == null) {
          ClientSampling = new global::Envoy.Type.V3.FractionalPercent();
        }
        ClientSampling.MergeFrom(other.ClientSampling);
      }
      if (other.randomSampling_ != null) {
        if (randomSampling_ == null) {
          RandomSampling = new global::Envoy.Type.V3.FractionalPercent();
        }
        RandomSampling.MergeFrom(other.RandomSampling);
      }
      if (other.overallSampling_ != null) {
        if (overallSampling_ == null) {
          OverallSampling = new global::Envoy.Type.V3.FractionalPercent();
        }
        OverallSampling.MergeFrom(other.OverallSampling);
      }
      customTags_.Add(other.customTags_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (clientSampling_ == null) {
              ClientSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(ClientSampling);
            break;
          }
          case 18: {
            if (randomSampling_ == null) {
              RandomSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(RandomSampling);
            break;
          }
          case 26: {
            if (overallSampling_ == null) {
              OverallSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(OverallSampling);
            break;
          }
          case 34: {
            customTags_.AddEntriesFrom(input, _repeated_customTags_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (clientSampling_ == null) {
              ClientSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(ClientSampling);
            break;
          }
          case 18: {
            if (randomSampling_ == null) {
              RandomSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(RandomSampling);
            break;
          }
          case 26: {
            if (overallSampling_ == null) {
              OverallSampling = new global::Envoy.Type.V3.FractionalPercent();
            }
            input.ReadMessage(OverallSampling);
            break;
          }
          case 34: {
            customTags_.AddEntriesFrom(ref input, _repeated_customTags_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A virtual cluster is a way of specifying a regex matching rule against
  /// certain important endpoints such that statistics are generated explicitly for
  /// the matched requests. The reason this is useful is that when doing
  /// prefix/path matching Envoy does not always know what the application
  /// considers to be an endpoint. Thus, its impossible for Envoy to generically
  /// emit per endpoint statistics. However, often systems have highly critical
  /// endpoints that they wish to get perfect statistics on. Virtual cluster
  /// statistics are perfect in the sense that they are emitted on the downstream
  /// side such that they include network level failures.
  ///
  /// Documentation for :ref:`virtual cluster statistics &lt;config_http_filters_router_vcluster_stats>`.
  ///
  /// .. note::
  ///
  ///    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
  ///    every application endpoint. This is both not easily maintainable and as well the matching and
  ///    statistics output are not free.
  /// </summary>
  public sealed partial class VirtualCluster : pb::IMessage<VirtualCluster>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VirtualCluster> _parser = new pb::MessageParser<VirtualCluster>(() => new VirtualCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VirtualCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualCluster(VirtualCluster other) : this() {
      headers_ = other.headers_.Clone();
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VirtualCluster Clone() {
      return new VirtualCluster(this);
    }

    /// <summary>Field number for the "headers" field.</summary>
    public const int HeadersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.HeaderMatcher> _repeated_headers_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Route.V3.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher>();
    /// <summary>
    /// Specifies a list of header matchers to use for matching requests. Each specified header must
    /// match. The pseudo-headers ``:path`` and ``:method`` can be used to match the request path and
    /// method, respectively.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> Headers {
      get { return headers_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of the virtual cluster. The virtual cluster name as well
    /// as the virtual host name are used when emitting statistics. The statistics are emitted by the
    /// router filter and are documented :ref:`here &lt;config_http_filters_router_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VirtualCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VirtualCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!headers_.Equals(other.headers_)) return false;
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= headers_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      headers_.WriteTo(output, _repeated_headers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      headers_.WriteTo(ref output, _repeated_headers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += headers_.CalculateSize(_repeated_headers_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VirtualCluster other) {
      if (other == null) {
        return;
      }
      headers_.Add(other.headers_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            headers_.AddEntriesFrom(input, _repeated_headers_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            headers_.AddEntriesFrom(ref input, _repeated_headers_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Global rate limiting :ref:`architecture overview &lt;arch_overview_global_rate_limit>`.
  /// Also applies to Local rate limiting :ref:`using descriptors &lt;config_http_filters_local_rate_limit_descriptors>`.
  /// </summary>
  public sealed partial class RateLimit : pb::IMessage<RateLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RateLimit> _parser = new pb::MessageParser<RateLimit>(() => new RateLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RateLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimit(RateLimit other) : this() {
      Stage = other.Stage;
      disableKey_ = other.disableKey_;
      actions_ = other.actions_.Clone();
      limit_ = other.limit_ != null ? other.limit_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RateLimit Clone() {
      return new RateLimit(this);
    }

    /// <summary>Field number for the "stage" field.</summary>
    public const int StageFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_stage_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? stage_;
    /// <summary>
    /// Refers to the stage set in the filter. The rate limit configuration only
    /// applies to filters with the same stage number. The default stage number is
    /// 0.
    ///
    /// .. note::
    ///
    ///   The filter supports a range of 0 - 10 inclusively for stage numbers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? Stage {
      get { return stage_; }
      set {
        stage_ = value;
      }
    }


    /// <summary>Field number for the "disable_key" field.</summary>
    public const int DisableKeyFieldNumber = 2;
    private string disableKey_ = "";
    /// <summary>
    /// The key to be set in runtime to disable this rate limit configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DisableKey {
      get { return disableKey_; }
      set {
        disableKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "actions" field.</summary>
    public const int ActionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.RateLimit.Types.Action> _repeated_actions_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Route.V3.RateLimit.Types.Action.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit.Types.Action> actions_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit.Types.Action>();
    /// <summary>
    /// A list of actions that are to be applied for this rate limit configuration.
    /// Order matters as the actions are processed sequentially and the descriptor
    /// is composed by appending descriptor entries in that sequence. If an action
    /// cannot append a descriptor entry, no descriptor is generated for the
    /// configuration. See :ref:`composing actions
    /// &lt;config_http_filters_rate_limit_composing_actions>` for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Route.V3.RateLimit.Types.Action> Actions {
      get { return actions_; }
    }

    /// <summary>Field number for the "limit" field.</summary>
    public const int LimitFieldNumber = 4;
    private global::Envoy.Config.Route.V3.RateLimit.Types.Override limit_;
    /// <summary>
    /// An optional limit override to be appended to the descriptor produced by this
    /// rate limit configuration. If the override value is invalid or cannot be resolved
    /// from metadata, no override is provided. See :ref:`rate limit override
    /// &lt;config_http_filters_rate_limit_rate_limit_override>` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Config.Route.V3.RateLimit.Types.Override Limit {
      get { return limit_; }
      set {
        limit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RateLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RateLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Stage != other.Stage) return false;
      if (DisableKey != other.DisableKey) return false;
      if(!actions_.Equals(other.actions_)) return false;
      if (!object.Equals(Limit, other.Limit)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (stage_ != null) hash ^= Stage.GetHashCode();
      if (DisableKey.Length != 0) hash ^= DisableKey.GetHashCode();
      hash ^= actions_.GetHashCode();
      if (limit_ != null) hash ^= Limit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (stage_ != null) {
        _single_stage_codec.WriteTagAndValue(output, Stage);
      }
      if (DisableKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisableKey);
      }
      actions_.WriteTo(output, _repeated_actions_codec);
      if (limit_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Limit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (stage_ != null) {
        _single_stage_codec.WriteTagAndValue(ref output, Stage);
      }
      if (DisableKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisableKey);
      }
      actions_.WriteTo(ref output, _repeated_actions_codec);
      if (limit_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Limit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (stage_ != null) {
        size += _single_stage_codec.CalculateSizeWithTag(Stage);
      }
      if (DisableKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisableKey);
      }
      size += actions_.CalculateSize(_repeated_actions_codec);
      if (limit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Limit);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RateLimit other) {
      if (other == null) {
        return;
      }
      if (other.stage_ != null) {
        if (stage_ == null || other.Stage != 0) {
          Stage = other.Stage;
        }
      }
      if (other.DisableKey.Length != 0) {
        DisableKey = other.DisableKey;
      }
      actions_.Add(other.actions_);
      if (other.limit_ != null) {
        if (limit_ == null) {
          Limit = new global::Envoy.Config.Route.V3.RateLimit.Types.Override();
        }
        Limit.MergeFrom(other.Limit);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_stage_codec.Read(input);
            if (stage_ == null || value != 0) {
              Stage = value;
            }
            break;
          }
          case 18: {
            DisableKey = input.ReadString();
            break;
          }
          case 26: {
            actions_.AddEntriesFrom(input, _repeated_actions_codec);
            break;
          }
          case 34: {
            if (limit_ == null) {
              Limit = new global::Envoy.Config.Route.V3.RateLimit.Types.Override();
            }
            input.ReadMessage(Limit);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_stage_codec.Read(ref input);
            if (stage_ == null || value != 0) {
              Stage = value;
            }
            break;
          }
          case 18: {
            DisableKey = input.ReadString();
            break;
          }
          case 26: {
            actions_.AddEntriesFrom(ref input, _repeated_actions_codec);
            break;
          }
          case 34: {
            if (limit_ == null) {
              Limit = new global::Envoy.Config.Route.V3.RateLimit.Types.Override();
            }
            input.ReadMessage(Limit);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RateLimit message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// [#next-free-field: 11]
      /// </summary>
      public sealed partial class Action : pb::IMessage<Action>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Action> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RateLimit.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Action() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Action(Action other) : this() {
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              SourceCluster = other.SourceCluster.Clone();
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              DestinationCluster = other.DestinationCluster.Clone();
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              RequestHeaders = other.RequestHeaders.Clone();
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              RemoteAddress = other.RemoteAddress.Clone();
              break;
            case ActionSpecifierOneofCase.GenericKey:
              GenericKey = other.GenericKey.Clone();
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              HeaderValueMatch = other.HeaderValueMatch.Clone();
              break;
            case ActionSpecifierOneofCase.DynamicMetadata:
              DynamicMetadata = other.DynamicMetadata.Clone();
              break;
            case ActionSpecifierOneofCase.Metadata:
              Metadata = other.Metadata.Clone();
              break;
            case ActionSpecifierOneofCase.Extension:
              Extension = other.Extension.Clone();
              break;
            case ActionSpecifierOneofCase.MaskedRemoteAddress:
              MaskedRemoteAddress = other.MaskedRemoteAddress.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Action Clone() {
          return new Action(this);
        }

        /// <summary>Field number for the "source_cluster" field.</summary>
        public const int SourceClusterFieldNumber = 1;
        /// <summary>
        /// Rate limit on source cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster SourceCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.SourceCluster;
          }
        }

        /// <summary>Field number for the "destination_cluster" field.</summary>
        public const int DestinationClusterFieldNumber = 2;
        /// <summary>
        /// Rate limit on destination cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster DestinationCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.DestinationCluster;
          }
        }

        /// <summary>Field number for the "request_headers" field.</summary>
        public const int RequestHeadersFieldNumber = 3;
        /// <summary>
        /// Rate limit on request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders RequestHeaders {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RequestHeaders;
          }
        }

        /// <summary>Field number for the "remote_address" field.</summary>
        public const int RemoteAddressFieldNumber = 4;
        /// <summary>
        /// Rate limit on remote address.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress RemoteAddress {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RemoteAddress;
          }
        }

        /// <summary>Field number for the "generic_key" field.</summary>
        public const int GenericKeyFieldNumber = 5;
        /// <summary>
        /// Rate limit on a generic key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey GenericKey {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.GenericKey;
          }
        }

        /// <summary>Field number for the "header_value_match" field.</summary>
        public const int HeaderValueMatchFieldNumber = 6;
        /// <summary>
        /// Rate limit on the existence of request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch HeaderValueMatch {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.HeaderValueMatch;
          }
        }

        /// <summary>Field number for the "dynamic_metadata" field.</summary>
        public const int DynamicMetadataFieldNumber = 7;
        /// <summary>
        /// Rate limit on dynamic metadata.
        ///
        /// .. attention::
        ///   This field has been deprecated in favor of the :ref:`metadata &lt;envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` field
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData DynamicMetadata {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.DynamicMetadata;
          }
        }

        /// <summary>Field number for the "metadata" field.</summary>
        public const int MetadataFieldNumber = 8;
        /// <summary>
        /// Rate limit on metadata.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData Metadata {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.Metadata;
          }
        }

        /// <summary>Field number for the "extension" field.</summary>
        public const int ExtensionFieldNumber = 9;
        /// <summary>
        /// Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
        ///
        /// :ref:`HTTP matching input functions &lt;arch_overview_matching_api>` are
        /// permitted as descriptor extensions. The input functions are only
        /// looked up if there is no rate limit descriptor extension matching
        /// the type URL.
        ///
        /// [#extension-category: envoy.rate_limit_descriptors]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Core.V3.TypedExtensionConfig Extension {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.Extension ? (global::Envoy.Config.Core.V3.TypedExtensionConfig) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.Extension;
          }
        }

        /// <summary>Field number for the "masked_remote_address" field.</summary>
        public const int MaskedRemoteAddressFieldNumber = 10;
        /// <summary>
        /// Rate limit on masked remote address.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress MaskedRemoteAddress {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress ? (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.MaskedRemoteAddress;
          }
        }

        private object actionSpecifier_;
        /// <summary>Enum of possible cases for the "action_specifier" oneof.</summary>
        public enum ActionSpecifierOneofCase {
          None = 0,
          SourceCluster = 1,
          DestinationCluster = 2,
          RequestHeaders = 3,
          RemoteAddress = 4,
          GenericKey = 5,
          HeaderValueMatch = 6,
          DynamicMetadata = 7,
          Metadata = 8,
          Extension = 9,
          MaskedRemoteAddress = 10,
        }
        private ActionSpecifierOneofCase actionSpecifierCase_ = ActionSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ActionSpecifierOneofCase ActionSpecifierCase {
          get { return actionSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearActionSpecifier() {
          actionSpecifierCase_ = ActionSpecifierOneofCase.None;
          actionSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Action);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Action other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(SourceCluster, other.SourceCluster)) return false;
          if (!object.Equals(DestinationCluster, other.DestinationCluster)) return false;
          if (!object.Equals(RequestHeaders, other.RequestHeaders)) return false;
          if (!object.Equals(RemoteAddress, other.RemoteAddress)) return false;
          if (!object.Equals(GenericKey, other.GenericKey)) return false;
          if (!object.Equals(HeaderValueMatch, other.HeaderValueMatch)) return false;
          if (!object.Equals(DynamicMetadata, other.DynamicMetadata)) return false;
          if (!object.Equals(Metadata, other.Metadata)) return false;
          if (!object.Equals(Extension, other.Extension)) return false;
          if (!object.Equals(MaskedRemoteAddress, other.MaskedRemoteAddress)) return false;
          if (ActionSpecifierCase != other.ActionSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) hash ^= SourceCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) hash ^= DestinationCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) hash ^= RequestHeaders.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) hash ^= RemoteAddress.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) hash ^= GenericKey.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) hash ^= HeaderValueMatch.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) hash ^= DynamicMetadata.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) hash ^= Metadata.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) hash ^= Extension.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) hash ^= MaskedRemoteAddress.GetHashCode();
          hash ^= (int) actionSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            output.WriteRawTag(10);
            output.WriteMessage(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            output.WriteRawTag(18);
            output.WriteMessage(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            output.WriteRawTag(26);
            output.WriteMessage(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            output.WriteRawTag(34);
            output.WriteMessage(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            output.WriteRawTag(42);
            output.WriteMessage(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            output.WriteRawTag(50);
            output.WriteMessage(HeaderValueMatch);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) {
            output.WriteRawTag(58);
            output.WriteMessage(DynamicMetadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) {
            output.WriteRawTag(66);
            output.WriteMessage(Metadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) {
            output.WriteRawTag(74);
            output.WriteMessage(Extension);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) {
            output.WriteRawTag(82);
            output.WriteMessage(MaskedRemoteAddress);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            output.WriteRawTag(10);
            output.WriteMessage(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            output.WriteRawTag(18);
            output.WriteMessage(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            output.WriteRawTag(26);
            output.WriteMessage(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            output.WriteRawTag(34);
            output.WriteMessage(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            output.WriteRawTag(42);
            output.WriteMessage(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            output.WriteRawTag(50);
            output.WriteMessage(HeaderValueMatch);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) {
            output.WriteRawTag(58);
            output.WriteMessage(DynamicMetadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) {
            output.WriteRawTag(66);
            output.WriteMessage(Metadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) {
            output.WriteRawTag(74);
            output.WriteMessage(Extension);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) {
            output.WriteRawTag(82);
            output.WriteMessage(MaskedRemoteAddress);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderValueMatch);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicMetadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Extension);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaskedRemoteAddress);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Action other) {
          if (other == null) {
            return;
          }
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              if (SourceCluster == null) {
                SourceCluster = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster();
              }
              SourceCluster.MergeFrom(other.SourceCluster);
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              if (DestinationCluster == null) {
                DestinationCluster = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster();
              }
              DestinationCluster.MergeFrom(other.DestinationCluster);
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              if (RequestHeaders == null) {
                RequestHeaders = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders();
              }
              RequestHeaders.MergeFrom(other.RequestHeaders);
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              if (RemoteAddress == null) {
                RemoteAddress = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress();
              }
              RemoteAddress.MergeFrom(other.RemoteAddress);
              break;
            case ActionSpecifierOneofCase.GenericKey:
              if (GenericKey == null) {
                GenericKey = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey();
              }
              GenericKey.MergeFrom(other.GenericKey);
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              if (HeaderValueMatch == null) {
                HeaderValueMatch = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch();
              }
              HeaderValueMatch.MergeFrom(other.HeaderValueMatch);
              break;
            case ActionSpecifierOneofCase.DynamicMetadata:
              if (DynamicMetadata == null) {
                DynamicMetadata = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData();
              }
              DynamicMetadata.MergeFrom(other.DynamicMetadata);
              break;
            case ActionSpecifierOneofCase.Metadata:
              if (Metadata == null) {
                Metadata = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData();
              }
              Metadata.MergeFrom(other.Metadata);
              break;
            case ActionSpecifierOneofCase.Extension:
              if (Extension == null) {
                Extension = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
              }
              Extension.MergeFrom(other.Extension);
              break;
            case ActionSpecifierOneofCase.MaskedRemoteAddress:
              if (MaskedRemoteAddress == null) {
                MaskedRemoteAddress = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress();
              }
              MaskedRemoteAddress.MergeFrom(other.MaskedRemoteAddress);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
                  subBuilder.MergeFrom(SourceCluster);
                }
                input.ReadMessage(subBuilder);
                SourceCluster = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
                  subBuilder.MergeFrom(DestinationCluster);
                }
                input.ReadMessage(subBuilder);
                DestinationCluster = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
                  subBuilder.MergeFrom(RequestHeaders);
                }
                input.ReadMessage(subBuilder);
                RequestHeaders = subBuilder;
                break;
              }
              case 34: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
                  subBuilder.MergeFrom(RemoteAddress);
                }
                input.ReadMessage(subBuilder);
                RemoteAddress = subBuilder;
                break;
              }
              case 42: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
                  subBuilder.MergeFrom(GenericKey);
                }
                input.ReadMessage(subBuilder);
                GenericKey = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
                  subBuilder.MergeFrom(HeaderValueMatch);
                }
                input.ReadMessage(subBuilder);
                HeaderValueMatch = subBuilder;
                break;
              }
              case 58: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) {
                  subBuilder.MergeFrom(DynamicMetadata);
                }
                input.ReadMessage(subBuilder);
                DynamicMetadata = subBuilder;
                break;
              }
              case 66: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) {
                  subBuilder.MergeFrom(Metadata);
                }
                input.ReadMessage(subBuilder);
                Metadata = subBuilder;
                break;
              }
              case 74: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) {
                  subBuilder.MergeFrom(Extension);
                }
                input.ReadMessage(subBuilder);
                Extension = subBuilder;
                break;
              }
              case 82: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) {
                  subBuilder.MergeFrom(MaskedRemoteAddress);
                }
                input.ReadMessage(subBuilder);
                MaskedRemoteAddress = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.SourceCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
                  subBuilder.MergeFrom(SourceCluster);
                }
                input.ReadMessage(subBuilder);
                SourceCluster = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DestinationCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
                  subBuilder.MergeFrom(DestinationCluster);
                }
                input.ReadMessage(subBuilder);
                DestinationCluster = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RequestHeaders();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
                  subBuilder.MergeFrom(RequestHeaders);
                }
                input.ReadMessage(subBuilder);
                RequestHeaders = subBuilder;
                break;
              }
              case 34: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.RemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
                  subBuilder.MergeFrom(RemoteAddress);
                }
                input.ReadMessage(subBuilder);
                RemoteAddress = subBuilder;
                break;
              }
              case 42: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.GenericKey();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
                  subBuilder.MergeFrom(GenericKey);
                }
                input.ReadMessage(subBuilder);
                GenericKey = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.HeaderValueMatch();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
                  subBuilder.MergeFrom(HeaderValueMatch);
                }
                input.ReadMessage(subBuilder);
                HeaderValueMatch = subBuilder;
                break;
              }
              case 58: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.DynamicMetaData();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DynamicMetadata) {
                  subBuilder.MergeFrom(DynamicMetadata);
                }
                input.ReadMessage(subBuilder);
                DynamicMetadata = subBuilder;
                break;
              }
              case 66: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.Metadata) {
                  subBuilder.MergeFrom(Metadata);
                }
                input.ReadMessage(subBuilder);
                Metadata = subBuilder;
                break;
              }
              case 74: {
                global::Envoy.Config.Core.V3.TypedExtensionConfig subBuilder = new global::Envoy.Config.Core.V3.TypedExtensionConfig();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.Extension) {
                  subBuilder.MergeFrom(Extension);
                }
                input.ReadMessage(subBuilder);
                Extension = subBuilder;
                break;
              }
              case 82: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MaskedRemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.MaskedRemoteAddress) {
                  subBuilder.MergeFrom(MaskedRemoteAddress);
                }
                input.ReadMessage(subBuilder);
                MaskedRemoteAddress = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Action message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("source_cluster", "&lt;local service cluster>")
          ///
          /// &lt;local service cluster> is derived from the :option:`--service-cluster` option.
          /// </summary>
          public sealed partial class SourceCluster : pb::IMessage<SourceCluster>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<SourceCluster> _parser = new pb::MessageParser<SourceCluster>(() => new SourceCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<SourceCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public SourceCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public SourceCluster(SourceCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public SourceCluster Clone() {
              return new SourceCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as SourceCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(SourceCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(SourceCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("destination_cluster", "&lt;routed target cluster>")
          ///
          /// Once a request matches against a route table rule, a routed cluster is determined by one of
          /// the following :ref:`route table configuration &lt;envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
          /// settings:
          ///
          /// * :ref:`cluster &lt;envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
          ///   to route to.
          /// * :ref:`weighted_clusters &lt;envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
          ///   chooses a cluster randomly from a set of clusters with attributed weight.
          /// * :ref:`cluster_header &lt;envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
          ///   header in the request contains the target cluster.
          /// </summary>
          public sealed partial class DestinationCluster : pb::IMessage<DestinationCluster>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<DestinationCluster> _parser = new pb::MessageParser<DestinationCluster>(() => new DestinationCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<DestinationCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DestinationCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DestinationCluster(DestinationCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DestinationCluster Clone() {
              return new DestinationCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as DestinationCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(DestinationCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(DestinationCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended when a header contains a key that matches the
          /// ``header_name``:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("&lt;descriptor_key>", "&lt;header_value_queried_from_header>")
          /// </summary>
          public sealed partial class RequestHeaders : pb::IMessage<RequestHeaders>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<RequestHeaders> _parser = new pb::MessageParser<RequestHeaders>(() => new RequestHeaders());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<RequestHeaders> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RequestHeaders() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RequestHeaders(RequestHeaders other) : this() {
              headerName_ = other.headerName_;
              descriptorKey_ = other.descriptorKey_;
              skipIfAbsent_ = other.skipIfAbsent_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RequestHeaders Clone() {
              return new RequestHeaders(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The header name to be queried from the request headers. The headers
            /// value is used to populate the value of the descriptor entry for the
            /// descriptor_key.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 2;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "skip_if_absent" field.</summary>
            public const int SkipIfAbsentFieldNumber = 3;
            private bool skipIfAbsent_;
            /// <summary>
            /// If set to true, Envoy skips the descriptor while calling rate limiting service
            /// when header is not present in the request. By default it skips calling the
            /// rate limiting service if this header is not present in the request.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool SkipIfAbsent {
              get { return skipIfAbsent_; }
              set {
                skipIfAbsent_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as RequestHeaders);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(RequestHeaders other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              if (DescriptorKey != other.DescriptorKey) return false;
              if (SkipIfAbsent != other.SkipIfAbsent) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (SkipIfAbsent != false) hash ^= SkipIfAbsent.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (SkipIfAbsent != false) {
                output.WriteRawTag(24);
                output.WriteBool(SkipIfAbsent);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (SkipIfAbsent != false) {
                output.WriteRawTag(24);
                output.WriteBool(SkipIfAbsent);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (SkipIfAbsent != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(RequestHeaders other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              if (other.SkipIfAbsent != false) {
                SkipIfAbsent = other.SkipIfAbsent;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 24: {
                    SkipIfAbsent = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 24: {
                    SkipIfAbsent = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor and is populated using the
          /// trusted address from :ref:`x-forwarded-for &lt;config_http_conn_man_headers_x-forwarded-for>`:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("remote_address", "&lt;trusted address from x-forwarded-for>")
          /// </summary>
          public sealed partial class RemoteAddress : pb::IMessage<RemoteAddress>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<RemoteAddress> _parser = new pb::MessageParser<RemoteAddress>(() => new RemoteAddress());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<RemoteAddress> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RemoteAddress() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RemoteAddress(RemoteAddress other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public RemoteAddress Clone() {
              return new RemoteAddress(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as RemoteAddress);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(RemoteAddress other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(RemoteAddress other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor and is populated using the
          /// masked address from :ref:`x-forwarded-for &lt;config_http_conn_man_headers_x-forwarded-for>`:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("masked_remote_address", "&lt;masked address from x-forwarded-for>")
          /// </summary>
          public sealed partial class MaskedRemoteAddress : pb::IMessage<MaskedRemoteAddress>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<MaskedRemoteAddress> _parser = new pb::MessageParser<MaskedRemoteAddress>(() => new MaskedRemoteAddress());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<MaskedRemoteAddress> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[4]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MaskedRemoteAddress() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MaskedRemoteAddress(MaskedRemoteAddress other) : this() {
              V4PrefixMaskLen = other.V4PrefixMaskLen;
              V6PrefixMaskLen = other.V6PrefixMaskLen;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MaskedRemoteAddress Clone() {
              return new MaskedRemoteAddress(this);
            }

            /// <summary>Field number for the "v4_prefix_mask_len" field.</summary>
            public const int V4PrefixMaskLenFieldNumber = 1;
            private static readonly pb::FieldCodec<uint?> _single_v4PrefixMaskLen_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
            private uint? v4PrefixMaskLen_;
            /// <summary>
            /// Length of prefix mask len for IPv4 (e.g. 0, 32).
            /// Defaults to 32 when unset.
            /// For example, trusted address from x-forwarded-for is ``192.168.1.1``,
            /// the descriptor entry is ("masked_remote_address", "192.168.1.1/32");
            /// if mask len is 24, the descriptor entry is ("masked_remote_address", "192.168.1.0/24").
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint? V4PrefixMaskLen {
              get { return v4PrefixMaskLen_; }
              set {
                v4PrefixMaskLen_ = value;
              }
            }


            /// <summary>Field number for the "v6_prefix_mask_len" field.</summary>
            public const int V6PrefixMaskLenFieldNumber = 2;
            private static readonly pb::FieldCodec<uint?> _single_v6PrefixMaskLen_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
            private uint? v6PrefixMaskLen_;
            /// <summary>
            /// Length of prefix mask len for IPv6 (e.g. 0, 128).
            /// Defaults to 128 when unset.
            /// For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``,
            /// the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345:6789:abcd:ef01:234/128");
            /// if mask len is 64, the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345::/64").
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint? V6PrefixMaskLen {
              get { return v6PrefixMaskLen_; }
              set {
                v6PrefixMaskLen_ = value;
              }
            }


            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as MaskedRemoteAddress);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(MaskedRemoteAddress other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (V4PrefixMaskLen != other.V4PrefixMaskLen) return false;
              if (V6PrefixMaskLen != other.V6PrefixMaskLen) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (v4PrefixMaskLen_ != null) hash ^= V4PrefixMaskLen.GetHashCode();
              if (v6PrefixMaskLen_ != null) hash ^= V6PrefixMaskLen.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (v4PrefixMaskLen_ != null) {
                _single_v4PrefixMaskLen_codec.WriteTagAndValue(output, V4PrefixMaskLen);
              }
              if (v6PrefixMaskLen_ != null) {
                _single_v6PrefixMaskLen_codec.WriteTagAndValue(output, V6PrefixMaskLen);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (v4PrefixMaskLen_ != null) {
                _single_v4PrefixMaskLen_codec.WriteTagAndValue(ref output, V4PrefixMaskLen);
              }
              if (v6PrefixMaskLen_ != null) {
                _single_v6PrefixMaskLen_codec.WriteTagAndValue(ref output, V6PrefixMaskLen);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (v4PrefixMaskLen_ != null) {
                size += _single_v4PrefixMaskLen_codec.CalculateSizeWithTag(V4PrefixMaskLen);
              }
              if (v6PrefixMaskLen_ != null) {
                size += _single_v6PrefixMaskLen_codec.CalculateSizeWithTag(V6PrefixMaskLen);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(MaskedRemoteAddress other) {
              if (other == null) {
                return;
              }
              if (other.v4PrefixMaskLen_ != null) {
                if (v4PrefixMaskLen_ == null || other.V4PrefixMaskLen != 0) {
                  V4PrefixMaskLen = other.V4PrefixMaskLen;
                }
              }
              if (other.v6PrefixMaskLen_ != null) {
                if (v6PrefixMaskLen_ == null || other.V6PrefixMaskLen != 0) {
                  V6PrefixMaskLen = other.V6PrefixMaskLen;
                }
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    uint? value = _single_v4PrefixMaskLen_codec.Read(input);
                    if (v4PrefixMaskLen_ == null || value != 0) {
                      V4PrefixMaskLen = value;
                    }
                    break;
                  }
                  case 18: {
                    uint? value = _single_v6PrefixMaskLen_codec.Read(input);
                    if (v6PrefixMaskLen_ == null || value != 0) {
                      V6PrefixMaskLen = value;
                    }
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    uint? value = _single_v4PrefixMaskLen_codec.Read(ref input);
                    if (v4PrefixMaskLen_ == null || value != 0) {
                      V4PrefixMaskLen = value;
                    }
                    break;
                  }
                  case 18: {
                    uint? value = _single_v6PrefixMaskLen_codec.Read(ref input);
                    if (v6PrefixMaskLen_ == null || value != 0) {
                      V6PrefixMaskLen = value;
                    }
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("generic_key", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class GenericKey : pb::IMessage<GenericKey>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<GenericKey> _parser = new pb::MessageParser<GenericKey>(() => new GenericKey());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<GenericKey> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[5]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GenericKey() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GenericKey(GenericKey other) : this() {
              descriptorValue_ = other.descriptorValue_;
              descriptorKey_ = other.descriptorKey_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GenericKey Clone() {
              return new GenericKey(this);
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 2;
            private string descriptorKey_ = "";
            /// <summary>
            /// An optional key to use in the descriptor entry. If not set it defaults
            /// to 'generic_key' as the descriptor key.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as GenericKey);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(GenericKey other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorValue != other.DescriptorValue) return false;
              if (DescriptorKey != other.DescriptorKey) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(GenericKey other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("header_match", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class HeaderValueMatch : pb::IMessage<HeaderValueMatch>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<HeaderValueMatch> _parser = new pb::MessageParser<HeaderValueMatch>(() => new HeaderValueMatch());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<HeaderValueMatch> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[6]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public HeaderValueMatch() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public HeaderValueMatch(HeaderValueMatch other) : this() {
              descriptorKey_ = other.descriptorKey_;
              descriptorValue_ = other.descriptorValue_;
              ExpectMatch = other.ExpectMatch;
              headers_ = other.headers_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public HeaderValueMatch Clone() {
              return new HeaderValueMatch(this);
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 4;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry. Defaults to ``header_match``.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "expect_match" field.</summary>
            public const int ExpectMatchFieldNumber = 2;
            private static readonly pb::FieldCodec<bool?> _single_expectMatch_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
            private bool? expectMatch_;
            /// <summary>
            /// If set to true, the action will append a descriptor entry when the
            /// request matches the headers. If set to false, the action will append a
            /// descriptor entry when the request does not match the headers. The
            /// default value is true.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool? ExpectMatch {
              get { return expectMatch_; }
              set {
                expectMatch_ = value;
              }
            }


            /// <summary>Field number for the "headers" field.</summary>
            public const int HeadersFieldNumber = 3;
            private static readonly pb::FieldCodec<global::Envoy.Config.Route.V3.HeaderMatcher> _repeated_headers_codec
                = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Route.V3.HeaderMatcher.Parser);
            private readonly pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher>();
            /// <summary>
            /// Specifies a set of headers that the rate limit action should match
            /// on. The action will check the requests headers against all the
            /// specified headers in the config. A match will happen if all the
            /// headers in the config are present in the request with the same values
            /// (or based on presence if the value field is not in the config).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<global::Envoy.Config.Route.V3.HeaderMatcher> Headers {
              get { return headers_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as HeaderValueMatch);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(HeaderValueMatch other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorKey != other.DescriptorKey) return false;
              if (DescriptorValue != other.DescriptorValue) return false;
              if (ExpectMatch != other.ExpectMatch) return false;
              if(!headers_.Equals(other.headers_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (expectMatch_ != null) hash ^= ExpectMatch.GetHashCode();
              hash ^= headers_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (expectMatch_ != null) {
                _single_expectMatch_codec.WriteTagAndValue(output, ExpectMatch);
              }
              headers_.WriteTo(output, _repeated_headers_codec);
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(34);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (expectMatch_ != null) {
                _single_expectMatch_codec.WriteTagAndValue(ref output, ExpectMatch);
              }
              headers_.WriteTo(ref output, _repeated_headers_codec);
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(34);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (expectMatch_ != null) {
                size += _single_expectMatch_codec.CalculateSizeWithTag(ExpectMatch);
              }
              size += headers_.CalculateSize(_repeated_headers_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(HeaderValueMatch other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              if (other.expectMatch_ != null) {
                if (expectMatch_ == null || other.ExpectMatch != false) {
                  ExpectMatch = other.ExpectMatch;
                }
              }
              headers_.Add(other.headers_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    bool? value = _single_expectMatch_codec.Read(input);
                    if (expectMatch_ == null || value != false) {
                      ExpectMatch = value;
                    }
                    break;
                  }
                  case 26: {
                    headers_.AddEntriesFrom(input, _repeated_headers_codec);
                    break;
                  }
                  case 34: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    bool? value = _single_expectMatch_codec.Read(ref input);
                    if (expectMatch_ == null || value != false) {
                      ExpectMatch = value;
                    }
                    break;
                  }
                  case 26: {
                    headers_.AddEntriesFrom(ref input, _repeated_headers_codec);
                    break;
                  }
                  case 34: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended when the
          /// :ref:`dynamic metadata &lt;well_known_dynamic_metadata>` contains a key value:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("&lt;descriptor_key>", "&lt;value_queried_from_dynamic_metadata>")
          ///
          /// .. attention::
          ///   This action has been deprecated in favor of the :ref:`metadata &lt;envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
          /// </summary>
          public sealed partial class DynamicMetaData : pb::IMessage<DynamicMetaData>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<DynamicMetaData> _parser = new pb::MessageParser<DynamicMetaData>(() => new DynamicMetaData());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<DynamicMetaData> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[7]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetaData() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetaData(DynamicMetaData other) : this() {
              descriptorKey_ = other.descriptorKey_;
              metadataKey_ = other.metadataKey_ != null ? other.metadataKey_.Clone() : null;
              defaultValue_ = other.defaultValue_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetaData Clone() {
              return new DynamicMetaData(this);
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 1;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "metadata_key" field.</summary>
            public const int MetadataKeyFieldNumber = 2;
            private global::Envoy.Type.Metadata.V3.MetadataKey metadataKey_;
            /// <summary>
            /// Metadata struct that defines the key and path to retrieve the string value. A match will
            /// only happen if the value in the dynamic metadata is of type string.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.Metadata.V3.MetadataKey MetadataKey {
              get { return metadataKey_; }
              set {
                metadataKey_ = value;
              }
            }

            /// <summary>Field number for the "default_value" field.</summary>
            public const int DefaultValueFieldNumber = 3;
            private string defaultValue_ = "";
            /// <summary>
            /// An optional value to use if ``metadata_key`` is empty. If not set and
            /// no value is present under the metadata_key then no descriptor is generated.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DefaultValue {
              get { return defaultValue_; }
              set {
                defaultValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as DynamicMetaData);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(DynamicMetaData other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorKey != other.DescriptorKey) return false;
              if (!object.Equals(MetadataKey, other.MetadataKey)) return false;
              if (DefaultValue != other.DefaultValue) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (metadataKey_ != null) hash ^= MetadataKey.GetHashCode();
              if (DefaultValue.Length != 0) hash ^= DefaultValue.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorKey);
              }
              if (metadataKey_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(DefaultValue);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorKey);
              }
              if (metadataKey_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(DefaultValue);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (metadataKey_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultValue);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(DynamicMetaData other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              if (other.metadataKey_ != null) {
                if (metadataKey_ == null) {
                  MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                }
                MetadataKey.MergeFrom(other.MetadataKey);
              }
              if (other.DefaultValue.Length != 0) {
                DefaultValue = other.DefaultValue;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                  case 26: {
                    DefaultValue = input.ReadString();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                  case 26: {
                    DefaultValue = input.ReadString();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// The following descriptor entry is appended when the metadata contains a key value:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("&lt;descriptor_key>", "&lt;value_queried_from_metadata>")
          /// </summary>
          public sealed partial class MetaData : pb::IMessage<MetaData>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<MetaData> _parser = new pb::MessageParser<MetaData>(() => new MetaData());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<MetaData> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Action.Descriptor.NestedTypes[8]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MetaData() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MetaData(MetaData other) : this() {
              descriptorKey_ = other.descriptorKey_;
              metadataKey_ = other.metadataKey_ != null ? other.metadataKey_.Clone() : null;
              defaultValue_ = other.defaultValue_;
              source_ = other.source_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public MetaData Clone() {
              return new MetaData(this);
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 1;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "metadata_key" field.</summary>
            public const int MetadataKeyFieldNumber = 2;
            private global::Envoy.Type.Metadata.V3.MetadataKey metadataKey_;
            /// <summary>
            /// Metadata struct that defines the key and path to retrieve the string value. A match will
            /// only happen if the value in the metadata is of type string.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.Metadata.V3.MetadataKey MetadataKey {
              get { return metadataKey_; }
              set {
                metadataKey_ = value;
              }
            }

            /// <summary>Field number for the "default_value" field.</summary>
            public const int DefaultValueFieldNumber = 3;
            private string defaultValue_ = "";
            /// <summary>
            /// An optional value to use if ``metadata_key`` is empty. If not set and
            /// no value is present under the metadata_key then no descriptor is generated.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string DefaultValue {
              get { return defaultValue_; }
              set {
                defaultValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "source" field.</summary>
            public const int SourceFieldNumber = 4;
            private global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source source_ = global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic;
            /// <summary>
            /// Source of metadata
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source Source {
              get { return source_; }
              set {
                source_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as MetaData);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(MetaData other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorKey != other.DescriptorKey) return false;
              if (!object.Equals(MetadataKey, other.MetadataKey)) return false;
              if (DefaultValue != other.DefaultValue) return false;
              if (Source != other.Source) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (metadataKey_ != null) hash ^= MetadataKey.GetHashCode();
              if (DefaultValue.Length != 0) hash ^= DefaultValue.GetHashCode();
              if (Source != global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic) hash ^= Source.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorKey);
              }
              if (metadataKey_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(DefaultValue);
              }
              if (Source != global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic) {
                output.WriteRawTag(32);
                output.WriteEnum((int) Source);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorKey);
              }
              if (metadataKey_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(DefaultValue);
              }
              if (Source != global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic) {
                output.WriteRawTag(32);
                output.WriteEnum((int) Source);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (metadataKey_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataKey);
              }
              if (DefaultValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultValue);
              }
              if (Source != global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Source);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(MetaData other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              if (other.metadataKey_ != null) {
                if (metadataKey_ == null) {
                  MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                }
                MetadataKey.MergeFrom(other.MetadataKey);
              }
              if (other.DefaultValue.Length != 0) {
                DefaultValue = other.DefaultValue;
              }
              if (other.Source != global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source.Dynamic) {
                Source = other.Source;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                  case 26: {
                    DefaultValue = input.ReadString();
                    break;
                  }
                  case 32: {
                    Source = (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source) input.ReadEnum();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                  case 26: {
                    DefaultValue = input.ReadString();
                    break;
                  }
                  case 32: {
                    Source = (global::Envoy.Config.Route.V3.RateLimit.Types.Action.Types.MetaData.Types.Source) input.ReadEnum();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the MetaData message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              public enum Source {
                /// <summary>
                /// Query :ref:`dynamic metadata &lt;well_known_dynamic_metadata>`
                /// </summary>
                [pbr::OriginalName("DYNAMIC")] Dynamic = 0,
                /// <summary>
                /// Query :ref:`route entry metadata &lt;envoy_v3_api_field_config.route.v3.Route.metadata>`
                /// </summary>
                [pbr::OriginalName("ROUTE_ENTRY")] RouteEntry = 1,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      public sealed partial class Override : pb::IMessage<Override>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Override> _parser = new pb::MessageParser<Override>(() => new Override());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Override> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Route.V3.RateLimit.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Override() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Override(Override other) : this() {
          switch (other.OverrideSpecifierCase) {
            case OverrideSpecifierOneofCase.DynamicMetadata:
              DynamicMetadata = other.DynamicMetadata.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Override Clone() {
          return new Override(this);
        }

        /// <summary>Field number for the "dynamic_metadata" field.</summary>
        public const int DynamicMetadataFieldNumber = 1;
        /// <summary>
        /// Limit override from dynamic metadata.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata DynamicMetadata {
          get { return overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata ? (global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata) overrideSpecifier_ : null; }
          set {
            overrideSpecifier_ = value;
            overrideSpecifierCase_ = value == null ? OverrideSpecifierOneofCase.None : OverrideSpecifierOneofCase.DynamicMetadata;
          }
        }

        private object overrideSpecifier_;
        /// <summary>Enum of possible cases for the "override_specifier" oneof.</summary>
        public enum OverrideSpecifierOneofCase {
          None = 0,
          DynamicMetadata = 1,
        }
        private OverrideSpecifierOneofCase overrideSpecifierCase_ = OverrideSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OverrideSpecifierOneofCase OverrideSpecifierCase {
          get { return overrideSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOverrideSpecifier() {
          overrideSpecifierCase_ = OverrideSpecifierOneofCase.None;
          overrideSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Override);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Override other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(DynamicMetadata, other.DynamicMetadata)) return false;
          if (OverrideSpecifierCase != other.OverrideSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) hash ^= DynamicMetadata.GetHashCode();
          hash ^= (int) overrideSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) {
            output.WriteRawTag(10);
            output.WriteMessage(DynamicMetadata);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) {
            output.WriteRawTag(10);
            output.WriteMessage(DynamicMetadata);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicMetadata);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Override other) {
          if (other == null) {
            return;
          }
          switch (other.OverrideSpecifierCase) {
            case OverrideSpecifierOneofCase.DynamicMetadata:
              if (DynamicMetadata == null) {
                DynamicMetadata = new global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata();
              }
              DynamicMetadata.MergeFrom(other.DynamicMetadata);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata();
                if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) {
                  subBuilder.MergeFrom(DynamicMetadata);
                }
                input.ReadMessage(subBuilder);
                DynamicMetadata = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata subBuilder = new global::Envoy.Config.Route.V3.RateLimit.Types.Override.Types.DynamicMetadata();
                if (overrideSpecifierCase_ == OverrideSpecifierOneofCase.DynamicMetadata) {
                  subBuilder.MergeFrom(DynamicMetadata);
                }
                input.ReadMessage(subBuilder);
                DynamicMetadata = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Override message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Fetches the override from the dynamic metadata.
          /// </summary>
          public sealed partial class DynamicMetadata : pb::IMessage<DynamicMetadata>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<DynamicMetadata> _parser = new pb::MessageParser<DynamicMetadata>(() => new DynamicMetadata());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<DynamicMetadata> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Route.V3.RateLimit.Types.Override.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetadata() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetadata(DynamicMetadata other) : this() {
              metadataKey_ = other.metadataKey_ != null ? other.metadataKey_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public DynamicMetadata Clone() {
              return new DynamicMetadata(this);
            }

            /// <summary>Field number for the "metadata_key" field.</summary>
            public const int MetadataKeyFieldNumber = 1;
            private global::Envoy.Type.Metadata.V3.MetadataKey metadataKey_;
            /// <summary>
            /// Metadata struct that defines the key and path to retrieve the struct value.
            /// The value must be a struct containing an integer "requests_per_unit" property
            /// and a "unit" property with a value parseable to :ref:`RateLimitUnit
            /// enum &lt;envoy_v3_api_enum_type.v3.RateLimitUnit>`
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Envoy.Type.Metadata.V3.MetadataKey MetadataKey {
              get { return metadataKey_; }
              set {
                metadataKey_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as DynamicMetadata);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(DynamicMetadata other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(MetadataKey, other.MetadataKey)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (metadataKey_ != null) hash ^= MetadataKey.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (metadataKey_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(MetadataKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (metadataKey_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(MetadataKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (metadataKey_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataKey);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(DynamicMetadata other) {
              if (other == null) {
                return;
              }
              if (other.metadataKey_ != null) {
                if (metadataKey_ == null) {
                  MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                }
                MetadataKey.MergeFrom(other.MetadataKey);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (metadataKey_ == null) {
                      MetadataKey = new global::Envoy.Type.Metadata.V3.MetadataKey();
                    }
                    input.ReadMessage(MetadataKey);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// .. attention::
  ///
  ///   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``
  ///   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
  ///
  /// .. attention::
  ///
  ///   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both
  ///   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
  ///
  ///   .. code-block:: json
  ///
  ///     {
  ///       "name": ":method",
  ///       "exact_match": "POST"
  ///     }
  ///
  /// .. attention::
  ///   In the absence of any header match specifier, match will default to :ref:`present_match
  ///   &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
  ///   &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
  ///   value.
  ///
  ///  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
  /// [#next-free-field: 15]
  /// </summary>
  public sealed partial class HeaderMatcher : pb::IMessage<HeaderMatcher>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HeaderMatcher> _parser = new pb::MessageParser<HeaderMatcher>(() => new HeaderMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HeaderMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HeaderMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HeaderMatcher(HeaderMatcher other) : this() {
      name_ = other.name_;
      invertMatch_ = other.invertMatch_;
      treatMissingHeaderAsEmpty_ = other.treatMissingHeaderAsEmpty_;
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SafeRegexMatch:
          SafeRegexMatch = other.SafeRegexMatch.Clone();
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          RangeMatch = other.RangeMatch.Clone();
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.ContainsMatch:
          ContainsMatch = other.ContainsMatch;
          break;
        case HeaderMatchSpecifierOneofCase.StringMatch:
          StringMatch = other.StringMatch.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HeaderMatcher Clone() {
      return new HeaderMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of the header in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "exact_match" field.</summary>
    public const int ExactMatchFieldNumber = 4;
    /// <summary>
    /// If specified, header match will be performed based on the value of the header.
    /// This field is deprecated. Please use :ref:`string_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExactMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.ExactMatch;
      }
    }

    /// <summary>Field number for the "safe_regex_match" field.</summary>
    public const int SafeRegexMatchFieldNumber = 11;
    /// <summary>
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex.
    /// This field is deprecated. Please use :ref:`string_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.RegexMatcher SafeRegexMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch ? (global::Envoy.Type.Matcher.V3.RegexMatcher) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.SafeRegexMatch;
      }
    }

    /// <summary>Field number for the "range_match" field.</summary>
    public const int RangeMatchFieldNumber = 6;
    /// <summary>
    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting of
    /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    /// the header value does not represent an integer. Match will fail for empty values, floating
    /// point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,
    ///   ``-1somestring``
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.V3.Int64Range RangeMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch ? (global::Envoy.Type.V3.Int64Range) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.RangeMatch;
      }
    }

    /// <summary>Field number for the "present_match" field.</summary>
    public const int PresentMatchFieldNumber = 7;
    /// <summary>
    /// If specified as true, header match will be performed based on whether the header is in the
    /// request. If specified as false, header match will be performed based on whether the header is absent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PresentMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch ? (bool) headerMatchSpecifier_ : false; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PresentMatch;
      }
    }

    /// <summary>Field number for the "prefix_match" field.</summary>
    public const int PrefixMatchFieldNumber = 9;
    /// <summary>
    /// If specified, header match will be performed based on the prefix of the header value.
    /// Note: empty prefix is not allowed, please use present_match instead.
    /// This field is deprecated. Please use :ref:`string_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    ///
    /// Examples:
    ///
    /// * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PrefixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PrefixMatch;
      }
    }

    /// <summary>Field number for the "suffix_match" field.</summary>
    public const int SuffixMatchFieldNumber = 10;
    /// <summary>
    /// If specified, header match will be performed based on the suffix of the header value.
    /// Note: empty suffix is not allowed, please use present_match instead.
    /// This field is deprecated. Please use :ref:`string_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    ///
    /// Examples:
    ///
    /// * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SuffixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.SuffixMatch;
      }
    }

    /// <summary>Field number for the "contains_match" field.</summary>
    public const int ContainsMatchFieldNumber = 12;
    /// <summary>
    /// If specified, header match will be performed based on whether the header value contains
    /// the given value or not.
    /// Note: empty contains match is not allowed, please use present_match instead.
    /// This field is deprecated. Please use :ref:`string_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
    ///
    /// Examples:
    ///
    /// * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ContainsMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ContainsMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.ContainsMatch;
      }
    }

    /// <summary>Field number for the "string_match" field.</summary>
    public const int StringMatchFieldNumber = 13;
    /// <summary>
    /// If specified, header match will be performed based on the string match of the header value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.StringMatcher StringMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch ? (global::Envoy.Type.Matcher.V3.StringMatcher) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.StringMatch;
      }
    }

    /// <summary>Field number for the "invert_match" field.</summary>
    public const int InvertMatchFieldNumber = 8;
    private bool invertMatch_;
    /// <summary>
    /// If specified, the match result will be inverted before checking. Defaults to false.
    ///
    /// Examples:
    ///
    /// * The regex ``\d{3}`` does not match the value ``1234``, so it will match when inverted.
    /// * The range [-10,0) will match the value -1, so it will not match when inverted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool InvertMatch {
      get { return invertMatch_; }
      set {
        invertMatch_ = value;
      }
    }

    /// <summary>Field number for the "treat_missing_header_as_empty" field.</summary>
    public const int TreatMissingHeaderAsEmptyFieldNumber = 14;
    private bool treatMissingHeaderAsEmpty_;
    /// <summary>
    /// If specified, for any header match rule, if the header match rule specified header
    /// does not exist, this header value will be treated as empty. Defaults to false.
    ///
    /// Examples:
    ///
    /// * The header match rule specified header "header1" to range match of [0, 10],
    ///   :ref:`invert_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
    ///   is set to true and :ref:`treat_missing_header_as_empty &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
    ///   is set to true; The "header1" header is not present. The match rule will
    ///   treat the "header1" as an empty header. The empty header does not match the range,
    ///   so it will match when inverted.
    /// * The header match rule specified header "header2" to range match of [0, 10],
    ///   :ref:`invert_match &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
    ///   is set to true and :ref:`treat_missing_header_as_empty &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
    ///   is set to false; The "header2" header is not present and the header
    ///   matcher rule for "header2" will be ignored so it will not match.
    /// * The header match rule specified header "header3" to a string regex match
    ///   ``^$`` which means an empty string, and
    ///   :ref:`treat_missing_header_as_empty &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
    ///   is set to true; The "header3" header is not present.
    ///   The match rule will treat the "header3" header as an empty header so it will match.
    /// * The header match rule specified header "header4" to a string regex match
    ///   ``^$`` which means an empty string, and
    ///   :ref:`treat_missing_header_as_empty &lt;envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
    ///   is set to false; The "header4" header is not present.
    ///   The match rule for "header4" will be ignored so it will not match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TreatMissingHeaderAsEmpty {
      get { return treatMissingHeaderAsEmpty_; }
      set {
        treatMissingHeaderAsEmpty_ = value;
      }
    }

    private object headerMatchSpecifier_;
    /// <summary>Enum of possible cases for the "header_match_specifier" oneof.</summary>
    public enum HeaderMatchSpecifierOneofCase {
      None = 0,
      ExactMatch = 4,
      SafeRegexMatch = 11,
      RangeMatch = 6,
      PresentMatch = 7,
      PrefixMatch = 9,
      SuffixMatch = 10,
      ContainsMatch = 12,
      StringMatch = 13,
    }
    private HeaderMatchSpecifierOneofCase headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HeaderMatchSpecifierOneofCase HeaderMatchSpecifierCase {
      get { return headerMatchSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHeaderMatchSpecifier() {
      headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
      headerMatchSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HeaderMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HeaderMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (ExactMatch != other.ExactMatch) return false;
      if (!object.Equals(SafeRegexMatch, other.SafeRegexMatch)) return false;
      if (!object.Equals(RangeMatch, other.RangeMatch)) return false;
      if (PresentMatch != other.PresentMatch) return false;
      if (PrefixMatch != other.PrefixMatch) return false;
      if (SuffixMatch != other.SuffixMatch) return false;
      if (ContainsMatch != other.ContainsMatch) return false;
      if (!object.Equals(StringMatch, other.StringMatch)) return false;
      if (InvertMatch != other.InvertMatch) return false;
      if (TreatMissingHeaderAsEmpty != other.TreatMissingHeaderAsEmpty) return false;
      if (HeaderMatchSpecifierCase != other.HeaderMatchSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) hash ^= ExactMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) hash ^= SafeRegexMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) hash ^= RangeMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) hash ^= PresentMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) hash ^= PrefixMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) hash ^= SuffixMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ContainsMatch) hash ^= ContainsMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) hash ^= StringMatch.GetHashCode();
      if (InvertMatch != false) hash ^= InvertMatch.GetHashCode();
      if (TreatMissingHeaderAsEmpty != false) hash ^= TreatMissingHeaderAsEmpty.GetHashCode();
      hash ^= (int) headerMatchSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        output.WriteRawTag(34);
        output.WriteString(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        output.WriteRawTag(50);
        output.WriteMessage(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(56);
        output.WriteBool(PresentMatch);
      }
      if (InvertMatch != false) {
        output.WriteRawTag(64);
        output.WriteBool(InvertMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        output.WriteRawTag(74);
        output.WriteString(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        output.WriteRawTag(82);
        output.WriteString(SuffixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
        output.WriteRawTag(90);
        output.WriteMessage(SafeRegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ContainsMatch) {
        output.WriteRawTag(98);
        output.WriteString(ContainsMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) {
        output.WriteRawTag(106);
        output.WriteMessage(StringMatch);
      }
      if (TreatMissingHeaderAsEmpty != false) {
        output.WriteRawTag(112);
        output.WriteBool(TreatMissingHeaderAsEmpty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        output.WriteRawTag(34);
        output.WriteString(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        output.WriteRawTag(50);
        output.WriteMessage(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(56);
        output.WriteBool(PresentMatch);
      }
      if (InvertMatch != false) {
        output.WriteRawTag(64);
        output.WriteBool(InvertMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        output.WriteRawTag(74);
        output.WriteString(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        output.WriteRawTag(82);
        output.WriteString(SuffixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
        output.WriteRawTag(90);
        output.WriteMessage(SafeRegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ContainsMatch) {
        output.WriteRawTag(98);
        output.WriteString(ContainsMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) {
        output.WriteRawTag(106);
        output.WriteMessage(StringMatch);
      }
      if (TreatMissingHeaderAsEmpty != false) {
        output.WriteRawTag(112);
        output.WriteBool(TreatMissingHeaderAsEmpty);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SafeRegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        size += 1 + 1;
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SuffixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ContainsMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainsMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StringMatch);
      }
      if (InvertMatch != false) {
        size += 1 + 1;
      }
      if (TreatMissingHeaderAsEmpty != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HeaderMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.InvertMatch != false) {
        InvertMatch = other.InvertMatch;
      }
      if (other.TreatMissingHeaderAsEmpty != false) {
        TreatMissingHeaderAsEmpty = other.TreatMissingHeaderAsEmpty;
      }
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SafeRegexMatch:
          if (SafeRegexMatch == null) {
            SafeRegexMatch = new global::Envoy.Type.Matcher.V3.RegexMatcher();
          }
          SafeRegexMatch.MergeFrom(other.SafeRegexMatch);
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          if (RangeMatch == null) {
            RangeMatch = new global::Envoy.Type.V3.Int64Range();
          }
          RangeMatch.MergeFrom(other.RangeMatch);
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.ContainsMatch:
          ContainsMatch = other.ContainsMatch;
          break;
        case HeaderMatchSpecifierOneofCase.StringMatch:
          if (StringMatch == null) {
            StringMatch = new global::Envoy.Type.Matcher.V3.StringMatcher();
          }
          StringMatch.MergeFrom(other.StringMatch);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            ExactMatch = input.ReadString();
            break;
          }
          case 50: {
            global::Envoy.Type.V3.Int64Range subBuilder = new global::Envoy.Type.V3.Int64Range();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
              subBuilder.MergeFrom(RangeMatch);
            }
            input.ReadMessage(subBuilder);
            RangeMatch = subBuilder;
            break;
          }
          case 56: {
            PresentMatch = input.ReadBool();
            break;
          }
          case 64: {
            InvertMatch = input.ReadBool();
            break;
          }
          case 74: {
            PrefixMatch = input.ReadString();
            break;
          }
          case 82: {
            SuffixMatch = input.ReadString();
            break;
          }
          case 90: {
            global::Envoy.Type.Matcher.V3.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatcher();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
              subBuilder.MergeFrom(SafeRegexMatch);
            }
            input.ReadMessage(subBuilder);
            SafeRegexMatch = subBuilder;
            break;
          }
          case 98: {
            ContainsMatch = input.ReadString();
            break;
          }
          case 106: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) {
              subBuilder.MergeFrom(StringMatch);
            }
            input.ReadMessage(subBuilder);
            StringMatch = subBuilder;
            break;
          }
          case 112: {
            TreatMissingHeaderAsEmpty = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            ExactMatch = input.ReadString();
            break;
          }
          case 50: {
            global::Envoy.Type.V3.Int64Range subBuilder = new global::Envoy.Type.V3.Int64Range();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
              subBuilder.MergeFrom(RangeMatch);
            }
            input.ReadMessage(subBuilder);
            RangeMatch = subBuilder;
            break;
          }
          case 56: {
            PresentMatch = input.ReadBool();
            break;
          }
          case 64: {
            InvertMatch = input.ReadBool();
            break;
          }
          case 74: {
            PrefixMatch = input.ReadString();
            break;
          }
          case 82: {
            SuffixMatch = input.ReadString();
            break;
          }
          case 90: {
            global::Envoy.Type.Matcher.V3.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.V3.RegexMatcher();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
              subBuilder.MergeFrom(SafeRegexMatch);
            }
            input.ReadMessage(subBuilder);
            SafeRegexMatch = subBuilder;
            break;
          }
          case 98: {
            ContainsMatch = input.ReadString();
            break;
          }
          case 106: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.StringMatch) {
              subBuilder.MergeFrom(StringMatch);
            }
            input.ReadMessage(subBuilder);
            StringMatch = subBuilder;
            break;
          }
          case 112: {
            TreatMissingHeaderAsEmpty = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Query parameter matching treats the query string of a request's :path header
  /// as an ampersand-separated list of keys and/or key=value elements.
  /// [#next-free-field: 7]
  /// </summary>
  public sealed partial class QueryParameterMatcher : pb::IMessage<QueryParameterMatcher>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<QueryParameterMatcher> _parser = new pb::MessageParser<QueryParameterMatcher>(() => new QueryParameterMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<QueryParameterMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QueryParameterMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QueryParameterMatcher(QueryParameterMatcher other) : this() {
      name_ = other.name_;
      switch (other.QueryParameterMatchSpecifierCase) {
        case QueryParameterMatchSpecifierOneofCase.StringMatch:
          StringMatch = other.StringMatch.Clone();
          break;
        case QueryParameterMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QueryParameterMatcher Clone() {
      return new QueryParameterMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of a key that must be present in the requested
    /// ``path``'s query string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "string_match" field.</summary>
    public const int StringMatchFieldNumber = 5;
    /// <summary>
    /// Specifies whether a query parameter value should match against a string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Envoy.Type.Matcher.V3.StringMatcher StringMatch {
      get { return queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch ? (global::Envoy.Type.Matcher.V3.StringMatcher) queryParameterMatchSpecifier_ : null; }
      set {
        queryParameterMatchSpecifier_ = value;
        queryParameterMatchSpecifierCase_ = value == null ? QueryParameterMatchSpecifierOneofCase.None : QueryParameterMatchSpecifierOneofCase.StringMatch;
      }
    }

    /// <summary>Field number for the "present_match" field.</summary>
    public const int PresentMatchFieldNumber = 6;
    /// <summary>
    /// Specifies whether a query parameter should be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PresentMatch {
      get { return queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch ? (bool) queryParameterMatchSpecifier_ : false; }
      set {
        queryParameterMatchSpecifier_ = value;
        queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.PresentMatch;
      }
    }

    private object queryParameterMatchSpecifier_;
    /// <summary>Enum of possible cases for the "query_parameter_match_specifier" oneof.</summary>
    public enum QueryParameterMatchSpecifierOneofCase {
      None = 0,
      StringMatch = 5,
      PresentMatch = 6,
    }
    private QueryParameterMatchSpecifierOneofCase queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QueryParameterMatchSpecifierOneofCase QueryParameterMatchSpecifierCase {
      get { return queryParameterMatchSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQueryParameterMatchSpecifier() {
      queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.None;
      queryParameterMatchSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as QueryParameterMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(QueryParameterMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(StringMatch, other.StringMatch)) return false;
      if (PresentMatch != other.PresentMatch) return false;
      if (QueryParameterMatchSpecifierCase != other.QueryParameterMatchSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) hash ^= StringMatch.GetHashCode();
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) hash ^= PresentMatch.GetHashCode();
      hash ^= (int) queryParameterMatchSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
        output.WriteRawTag(42);
        output.WriteMessage(StringMatch);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(48);
        output.WriteBool(PresentMatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
        output.WriteRawTag(42);
        output.WriteMessage(StringMatch);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(48);
        output.WriteBool(PresentMatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StringMatch);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(QueryParameterMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      switch (other.QueryParameterMatchSpecifierCase) {
        case QueryParameterMatchSpecifierOneofCase.StringMatch:
          if (StringMatch == null) {
            StringMatch = new global::Envoy.Type.Matcher.V3.StringMatcher();
          }
          StringMatch.MergeFrom(other.StringMatch);
          break;
        case QueryParameterMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 42: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
              subBuilder.MergeFrom(StringMatch);
            }
            input.ReadMessage(subBuilder);
            StringMatch = subBuilder;
            break;
          }
          case 48: {
            PresentMatch = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 42: {
            global::Envoy.Type.Matcher.V3.StringMatcher subBuilder = new global::Envoy.Type.Matcher.V3.StringMatcher();
            if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
              subBuilder.MergeFrom(StringMatch);
            }
            input.ReadMessage(subBuilder);
            StringMatch = subBuilder;
            break;
          }
          case 48: {
            PresentMatch = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HTTP Internal Redirect :ref:`architecture overview &lt;arch_overview_internal_redirects>`.
  /// </summary>
  public sealed partial class InternalRedirectPolicy : pb::IMessage<InternalRedirectPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InternalRedirectPolicy> _parser = new pb::MessageParser<InternalRedirectPolicy>(() => new InternalRedirectPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InternalRedirectPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InternalRedirectPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InternalRedirectPolicy(InternalRedirectPolicy other) : this() {
      MaxInternalRedirects = other.MaxInternalRedirects;
      redirectResponseCodes_ = other.redirectResponseCodes_.Clone();
      predicates_ = other.predicates_.Clone();
      allowCrossSchemeRedirect_ = other.allowCrossSchemeRedirect_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InternalRedirectPolicy Clone() {
      return new InternalRedirectPolicy(this);
    }

    /// <summary>Field number for the "max_internal_redirects" field.</summary>
    public const int MaxInternalRedirectsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxInternalRedirects_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxInternalRedirects_;
    /// <summary>
    /// An internal redirect is not handled, unless the number of previous internal redirects that a
    /// downstream request has encountered is lower than this value.
    /// In the case where a downstream request is bounced among multiple routes by internal redirect,
    /// the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
    /// &lt;envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
    /// will pass the redirect back to downstream.
    ///
    /// If not specified, at most one redirect will be followed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint? MaxInternalRedirects {
      get { return maxInternalRedirects_; }
      set {
        maxInternalRedirects_ = value;
      }
    }


    /// <summary>Field number for the "redirect_response_codes" field.</summary>
    public const int RedirectResponseCodesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint> _repeated_redirectResponseCodes_codec
        = pb::FieldCodec.ForUInt32(18);
    private readonly pbc::RepeatedField<uint> redirectResponseCodes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
    /// only 302 will be treated as internal redirect.
    /// Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<uint> RedirectResponseCodes {
      get { return redirectResponseCodes_; }
    }

    /// <summary>Field number for the "predicates" field.</summary>
    public const int PredicatesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Config.Core.V3.TypedExtensionConfig> _repeated_predicates_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Config.Core.V3.TypedExtensionConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> predicates_ = new pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig>();
    /// <summary>
    /// Specifies a list of predicates that are queried when an upstream response is deemed
    /// to trigger an internal redirect by all other criteria. Any predicate in the list can reject
    /// the redirect, causing the response to be proxied to downstream.
    /// [#extension-category: envoy.internal_redirect_predicates]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Envoy.Config.Core.V3.TypedExtensionConfig> Predicates {
      get { return predicates_; }
    }

    /// <summary>Field number for the "allow_cross_scheme_redirect" field.</summary>
    public const int AllowCrossSchemeRedirectFieldNumber = 4;
    private bool allowCrossSchemeRedirect_;
    /// <summary>
    /// Allow internal redirect to follow a target URI with a different scheme than the value of
    /// x-forwarded-proto. The default is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowCrossSchemeRedirect {
      get { return allowCrossSchemeRedirect_; }
      set {
        allowCrossSchemeRedirect_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InternalRedirectPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InternalRedirectPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxInternalRedirects != other.MaxInternalRedirects) return false;
      if(!redirectResponseCodes_.Equals(other.redirectResponseCodes_)) return false;
      if(!predicates_.Equals(other.predicates_)) return false;
      if (AllowCrossSchemeRedirect != other.AllowCrossSchemeRedirect) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (maxInternalRedirects_ != null) hash ^= MaxInternalRedirects.GetHashCode();
      hash ^= redirectResponseCodes_.GetHashCode();
      hash ^= predicates_.GetHashCode();
      if (AllowCrossSchemeRedirect != false) hash ^= AllowCrossSchemeRedirect.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (maxInternalRedirects_ != null) {
        _single_maxInternalRedirects_codec.WriteTagAndValue(output, MaxInternalRedirects);
      }
      redirectResponseCodes_.WriteTo(output, _repeated_redirectResponseCodes_codec);
      predicates_.WriteTo(output, _repeated_predicates_codec);
      if (AllowCrossSchemeRedirect != false) {
        output.WriteRawTag(32);
        output.WriteBool(AllowCrossSchemeRedirect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (maxInternalRedirects_ != null) {
        _single_maxInternalRedirects_codec.WriteTagAndValue(ref output, MaxInternalRedirects);
      }
      redirectResponseCodes_.WriteTo(ref output, _repeated_redirectResponseCodes_codec);
      predicates_.WriteTo(ref output, _repeated_predicates_codec);
      if (AllowCrossSchemeRedirect != false) {
        output.WriteRawTag(32);
        output.WriteBool(AllowCrossSchemeRedirect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (maxInternalRedirects_ != null) {
        size += _single_maxInternalRedirects_codec.CalculateSizeWithTag(MaxInternalRedirects);
      }
      size += redirectResponseCodes_.CalculateSize(_repeated_redirectResponseCodes_codec);
      size += predicates_.CalculateSize(_repeated_predicates_codec);
      if (AllowCrossSchemeRedirect != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InternalRedirectPolicy other) {
      if (other == null) {
        return;
      }
      if (other.maxInternalRedirects_ != null) {
        if (maxInternalRedirects_ == null || other.MaxInternalRedirects != 0) {
          MaxInternalRedirects = other.MaxInternalRedirects;
        }
      }
      redirectResponseCodes_.Add(other.redirectResponseCodes_);
      predicates_.Add(other.predicates_);
      if (other.AllowCrossSchemeRedirect != false) {
        AllowCrossSchemeRedirect = other.AllowCrossSchemeRedirect;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxInternalRedirects_codec.Read(input);
            if (maxInternalRedirects_ == null || value != 0) {
              MaxInternalRedirects = value;
            }
            break;
          }
          case 18:
          case 16: {
            redirectResponseCodes_.AddEntriesFrom(input, _repeated_redirectResponseCodes_codec);
            break;
          }
          case 26: {
            predicates_.AddEntriesFrom(input, _repeated_predicates_codec);
            break;
          }
          case 32: {
            AllowCrossSchemeRedirect = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            uint? value = _single_maxInternalRedirects_codec.Read(ref input);
            if (maxInternalRedirects_ == null || value != 0) {
              MaxInternalRedirects = value;
            }
            break;
          }
          case 18:
          case 16: {
            redirectResponseCodes_.AddEntriesFrom(ref input, _repeated_redirectResponseCodes_codec);
            break;
          }
          case 26: {
            predicates_.AddEntriesFrom(ref input, _repeated_predicates_codec);
            break;
          }
          case 32: {
            AllowCrossSchemeRedirect = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
  /// map value in
  /// :ref:`VirtualHost.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
  /// :ref:`Route.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
  /// or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config&lt;envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
  /// to add additional flags to the filter.
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class FilterConfig : pb::IMessage<FilterConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FilterConfig> _parser = new pb::MessageParser<FilterConfig>(() => new FilterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FilterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Route.V3.RouteComponentsReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterConfig(FilterConfig other) : this() {
      config_ = other.config_ != null ? other.config_.Clone() : null;
      isOptional_ = other.isOptional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FilterConfig Clone() {
      return new FilterConfig(this);
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Any config_;
    /// <summary>
    /// The filter config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Any Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    /// <summary>Field number for the "is_optional" field.</summary>
    public const int IsOptionalFieldNumber = 2;
    private bool isOptional_;
    /// <summary>
    /// If true, the filter is optional, meaning that if the client does
    /// not support the specified filter, it may ignore the map entry rather
    /// than rejecting the config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsOptional {
      get { return isOptional_; }
      set {
        isOptional_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FilterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FilterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Config, other.Config)) return false;
      if (IsOptional != other.IsOptional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (config_ != null) hash ^= Config.GetHashCode();
      if (IsOptional != false) hash ^= IsOptional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (IsOptional != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (config_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Config);
      }
      if (IsOptional != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsOptional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (IsOptional != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FilterConfig other) {
      if (other == null) {
        return;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Google.Protobuf.WellKnownTypes.Any();
        }
        Config.MergeFrom(other.Config);
      }
      if (other.IsOptional != false) {
        IsOptional = other.IsOptional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Config);
            break;
          }
          case 16: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (config_ == null) {
              Config = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            input.ReadMessage(Config);
            break;
          }
          case 16: {
            IsOptional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
